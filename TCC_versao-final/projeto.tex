\chapter{Veículos Autônomos} \label{direcao_autonoma}

Este capítulo apresenta os principais conceitos, fundamentos teóricos e tecnologias que alicerçam o desenvolvimento de VA, fornecendo uma base sólida de conhecimento para embasar os capítulos subsequentes. Essa compreensão dos elementos essenciais que possibilitam a condução autônoma é fundamental para o desenvolvimento de sistemas seguros e eficientes, abrangendo desde a definição formal de níveis de automação estabelecidos pela \citeonline{SAE} até as técnicas avançadas de simulação aplicadas ao contexto de validação e teste destes sistemas complexos.

Inicialmente, será discutida a Classificação de Níveis de Automação (Seção \ref{levelcla}), explorando os diferentes graus de automação existentes conforme padronização internacional e os critérios técnicos que os diferenciam. Esta análise é fundamental para estabelecer o contexto tecnológico atual e compreender a evolução progressiva das capacidades associadas aos VA.

Na sequência, abordaremos a Tarefa de Condução (Seção \ref{componentes_da_tarefa_de_conducao}), decompondo sistematicamente um dos aspectos mais desafiadores no desenvolvimento de VA. Esta seção detalhará a arquitetura hierárquica necessária para a execução da tarefa autônoma, incluindo sensores, algoritmos de percepção e técnicas de detecção e classificação de objetos, estabelecendo os fundamentos para a integração desses componentes em tempo real.

Posteriormente, a seção dedicada à Simulação de Carros Autônomos (Seção \ref{controlador_controle_de_VA-simulador}) destacará o papel estratégico e metodológico dos simuladores na pesquisa e desenvolvimento de VA. Serão apresentados diferentes ambientes de simulação disponíveis, suas características técnicas e contribuições para validação experimental, permitindo teste e verificação de algoritmos em ambientes controlados e reprodutíveis antes da implementação em cenários reais.

Finalmente, este capítulo contará com uma análise crítica dos Trabalhos Relacionados (Seção \ref{trabalhos_relacionados}), na qual serão examinados estudos prévios que abordam soluções metodológicas, desafios técnicos e avanços científicos no contexto de simulação e detecção de objetos em tempo real para VA. Esta revisão do estado da arte servirá como fundamentação científica para identificar lacunas de conhecimento, estabelecer tendências emergentes e justificar as direções de pesquisa adotadas neste estudo.

Com essa estrutura sistemática e abordagem progressiva, este capítulo estabelece um alicerce teórico-conceitual robusto para o desenvolvimento do trabalho, consolidando os fundamentos científicos e referências metodológicas necessários para sustentar as soluções propostas e validar experimentalmente os resultados obtidos ao longo deste estudo.

\section{Classificação de Níveis de Automação} \label{levelcla}

A classificação dos níveis de automação veicular constitui um \textit{framework} fundamental para a compreensão e desenvolvimento de VA, estabelecendo critérios técnicos precisos que definem o grau de intervenção humana necessária em cada estágio tecnológico. Esta taxonomia, desenvolvida pela \citeonline{SAE}, organização internacional de padronização automotiva, representa o padrão industrial mais amplamente adotado para categorizar sistemas de condução automatizada \cite[p.~30]{SAE}.

A norma SAE J3016, ilustrada na Figura \ref{Graph_PT}, estabelece seis níveis distintos de automação (0-5), baseados em três critérios fundamentais: a capacidade do sistema de executar a tarefa dinâmica de condução (\textit{Dynamic Driving Task} - DDT), o monitoramento do ambiente operacional, e a resposta a situações críticas (\textit{fallback} performance) \cite[p.~28]{SAE}. Cada nível representa um incremento progressivo na autonomia do sistema, desde a ausência total de automação até a condução completamente autônoma.

\begin{figure}[H]
\centering
\includegraphics[width=15cm]{Figures/IC-Graph1.png}
\caption{Taxonomia dos níveis de automação veicular segundo padrão SAE J3016. Modificado de \cite{SAE}.}
\label{Graph_PT}
\end{figure}

\subsection{Definições Técnicas dos Níveis de Automação}

Conforme estabelecido pela \citeonline{SAE}, os seis níveis de automação são formalmente definidos como:

\begin{enumerate}
\item \textbf{Nível 0 - Sem Automação:} o sistema não executa nenhum aspecto da DDT sustentadamente. O condutor humano é responsável por todas as funções de controle veicular, incluindo direção, aceleração, frenagem e monitoramento ambiental. Sistemas de alerta ou avisos momentâneos não constituem automação;

\item \textbf{Nível 1 - Assistência ao Condutor:} o sistema executa sustentadamente o controle de direção OU aceleração/desaceleração, utilizando informações sobre o ambiente de condução. O condutor humano executa os demais aspectos da DDT e mantém total responsabilidade pelo monitoramento ambiental. Exemplos incluem controle de cruzeiro (\textit{cruise control}) ou assistência de manutenção de faixa;

\item \textbf{Nível 2 - Automação Parcial:} o sistema executa sustentadamente tanto o controle de direção quanto aceleração/desaceleração, utilizando informações sobre o ambiente. O condutor humano executa os demais aspectos da DDT, incluindo monitoramento constante do ambiente e preparação para retomar controle imediato quando necessário;

\item \textbf{Nível 3 - Automação Condicional:} o sistema executa todos os aspectos da DDT com a expectativa de que um usuário habilitado responda adequadamente a solicitações de intervenção. O sistema monitora o ambiente de condução e identifica quando suas capacidades são excedidas, solicitando intervenção humana com tempo suficiente para resposta;

\item \textbf{Nível 4 - Alta Automação:} o sistema executa todos os aspectos da DDT e resposta de \textit{fallback} dentro de seu Domínio Operacional de Projeto (\textit{Operational Design Domain} - ODD)\footnote{ODD define as condições operacionais específicas sob as quais um sistema autônomo foi projetado para funcionar, incluindo limitações geográficas, ambientais, temporais e de velocidade \cite[p.~33]{SAE}.}. Não há expectativa de que um usuário responda a solicitações de intervenção dentro do ODD;

\item \textbf{Nível 5 - Automação Completa:} o sistema executa todos os aspectos da DDT e resposta de \textit{fallback} em todas as condições operacionais gerenciáveis por um condutor humano. Não existe limitação de ODD para este nível de automação;
\end{enumerate}

A Figura \ref{niveis-auto} apresenta uma representação esquemática dos diferentes níveis de automação e suas características operacionais distintivas.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{Figures/level-auto_translated.png}
\caption{Representação esquemática dos níveis de automação SAE \cite{review-auto}}
\label{niveis-auto}
\end{figure}

\subsection{Estado Atual da Implementação Industrial}

A implementação comercial destes níveis de automação varia significativamente entre fabricantes e mercados. Atualmente, a maioria dos veículos comerciais opera nos níveis 1 e 2, caracterizados como Sistemas Avançados de Assistência ao Condutor ou (ADAS - \textit{Advanced Driver Assistance Systems}) \cite{4cenarios_ocidental}. Por exemplo, empresas como Tesla mantêm sistemas de nível 2 em seus veículos de produção, requerendo supervisão constante do condutor.

Um marco significativo foi alcançado em 2023, quando a Mercedes-Benz obteve certificação para operar sistemas de nível 3 (DRIVE PILOT) no mercado norte-americano, inicialmente no estado de Nevada \cite{mercedes3}. Segundo declaração oficial da empresa:

\begin{quote}
"No mundo moderno, o tempo é um dos bens mais preciosos, e devolver o tempo aos nossos clientes é um elemento central em nossa estratégia [...] DRIVE PILOT dá um grande passo para alcançar [...] condução autônoma [...]" \cite{mercedes3}.
\end{quote}

Paralelamente, empresas como Waymo e Cruise operam serviços comerciais limitados com veículos de nível 4 em áreas geográficas específicas nos Estados Unidos, demonstrando a viabilidade técnica de sistemas de alta automação sob condições controladas de ODD \cite{Houser2023-dn}.

\subsection{Implicações para Desenvolvimento de VA} \label{subsec:implicacoes_validacao}

A taxonomia \citeonline{SAE} estabelece \textit{benchmarks} críticos para o desenvolvimento tecnológico, definindo requisitos funcionais específicos para cada nível de autonomia que têm implicações diretas na arquitetura e implementação dos sistemas propostos neste trabalho.

Os níveis 1-3 caracterizam-se pela necessidade de supervisão humana ativa, demandando sistemas de assistência que forneçam \textit{feedback} visual e alerta em tempo real ao condutor. Esta característica alinha-se diretamente com a Hipótese \ref{hipotese} deste trabalho, que propõe um sistema de assistência à condução capaz de oferecer \textit{feedback} visual de placas de trânsito em tempo real. Especificamente, o sistema desenvolvido neste estudo enquadra-se no contexto dos níveis 1-2 SAE, onde a detecção e classificação de objetos serve como suporte ao motorista, mantendo a responsabilidade final da condução sob supervisão humana.

Os níveis 4-5, por sua vez, representam sistemas verdadeiramente autônomos dentro de seus respectivos ODDs, requerendo capacidades avançadas de percepção, planejamento e controle sem intervenção humana. O \textit{framework} tecnológico desenvolvido neste trabalho, integrando algoritmos YOLO para percepção, planejamento de movimento baseado em máquinas de estado, e controladores PID para controle longitudinal, representa uma base fundamental para a evolução em direção a esses níveis superiores de automação.

Esta distinção entre níveis de automação é fundamental para o desenvolvimento das arquiteturas de software apresentadas no Capítulo \ref{ModelagemConceitual}, onde são detalhadas as três camadas essenciais: percepção ambiental (Seção \ref{per_visual_carro}), planejamento de movimento (Seção \ref{planejamento}), e controle veicular (Seção \ref{modelagem_veiculos}). A modularidade desta arquitetura permite que o sistema proposto seja expandido e adaptado para atender requisitos de níveis de automação superiores, conforme demonstrado na validação experimental do Capítulo \ref{resultados}.

Sabendo desses critérios, estipulamos métricas de validação utilizadas neste trabalho, onde critérios como tempo de detecção com resposta inferior a 100ms e precisão de detecção superior a 90\% são estabelecidos considerando os requisitos de segurança e confiabilidade necessários para sistemas de assistência à condução \cite[p. ~105]{castro2009human}, conforme especificado nos Objetivos \ref{objetivos_esp} desta pesquisa.

\section{Tarefa de Condução}\label{componentes_da_tarefa_de_conducao}

A tarefa de condução em VA constitui um processo complexo e multifacetado que pode ser decomposto em três subsistemas fundamentais e hierarquicamente organizados: Percepção, Planejamento de Movimento e Controle do Veículo. Esta decomposição funcional, amplamente adotada na literatura especializada \citeonline[p. 4]{sensors-yet}, permite uma abordagem sistemática para o desenvolvimento e validação de sistemas autônomos.

Cada subsistema executa operações específicas e interdependentes, formando uma arquitetura em camadas onde o desempenho satisfatório de cada nível é pré-requisito para o funcionamento adequado dos níveis subsequentes. A Figura \ref{perception_pt} ilustra esta organização hierárquica e as principais interfaces entre os módulos.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/perception.png}
\caption{Arquitetura hierárquica dos subsistemas de condução autônoma \cite[p. ~4]{sensors-yet}}
\label{perception_pt}
\end{figure}

\subsection{Subsistemas da Tarefa de Condução}

Os três subsistemas que compõem a tarefa de condução podem ser formalmente definidos como:

\begin{enumerate}
\item \textbf{Percepção:} responsável pela interpretação e compreensão do ambiente operacional através da fusão de dados sensoriais. Este subsistema utiliza recursos embarcados como sensores multiespectrais (detalhados na Subseção \ref{sensor}), mapas digitais pré-armazenados, sistemas de localização global e conectividade de rede para construir uma representação em tempo real do estado do mundo;


\item \textbf{Planejamento:} encarregado de determinar as ações necessárias para que o VA alcance seus objetivos de navegação, respeitando as restrições impostas pelo ODD. Este subsistema integra informações de percepção com objetivos de alto nível para gerar trajetórias exequíveis;

\item \textbf{Controle:} responsável pela execução das trajetórias planejadas através da geração de comandos de atuação apropriados. Este subsistema traduz as decisões de planejamento em comandos específicos para os atuadores (freios, acelerador, direção), garantindo que o veículo siga precisamente a trajetória especificada.
\end{enumerate}

A Figura \ref{layer_specific} apresenta uma visão detalhada da comunicação e interdependência entre os componentes de cada subsistema, evidenciando o fluxo de informações necessário para a operação coordenada do sistema completo.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/layer_specific.png}
\caption{Relações funcionais e fluxos de dados entre subsistemas \cite[p. ~4]{sensors-yet}}
\label{layer_specific}
\end{figure}

A compreensão desta arquitetura modular é fundamental para o desenvolvimento de sistemas robustos, uma vez que permite a otimização independente de cada subsistema enquanto mantém interfaces bem definidas para integração sistêmica. Os conceitos e componentes específicos de cada subsistema serão explorados em detalhes nas seções subsequentes deste trabalho, fornecendo a base técnica necessária para a implementação da solução proposta.
%added from 2022-2023

\subsection{Tecnologias Essenciais para as Tarefas de Condução} \label{Requisitos}

Esta subseção apresenta uma análise sistemática das tecnologias fundamentais que viabilizam a execução eficaz das tarefas de condução autônoma. O foco principal concentra-se no subsistema de percepção, explorando seus requisitos operacionais, componentes tecnológicos, desafios associados e soluções aplicadas neste aspecto crucial dos VA, conforme estabelecido na Seção \ref{componentes_da_tarefa_de_conducao}.

\subsubsection{Percepção e Tarefas Relacionadas}\label{percepcao}

O subsistema de percepção constitui o alicerce informacional da condução autônoma, responsável por duas funções críticas e complementares: (1) a construção de uma representação compreensiva e em tempo real do ambiente operacional circundante, e (2) o suporte à tomada de decisões informadas durante a execução da tarefa de condução \cite{zheng2023simultaneous}.

Para alcançar estes objetivos, o sistema de percepção deve processar e integrar dados multissensoriais provenientes dos dispositivos apresentados na Figura \ref{figura-sensores}, categorizando os elementos detectados conforme sua natureza dinâmica. Esta taxonomia, estabelecida por \citeonline{zheng2023simultaneous}, distingue duas categorias fundamentais:

\begin{description}
\item[\textbf{Elementos Estáticos:}] compreendem características fixas da infraestrutura viária, incluindo marcações de faixa, sinalizações de trânsito, meio-fios, placas de sinalização e elementos paisagísticos como vegetação \cite[p. ~3]{zheng2023simultaneous}. Estes elementos constituem o foco principal deste trabalho.

\item[\textbf{Elementos Dinâmicos:}] englobam entidades móveis no ambiente operacional, incluindo veículos de diferentes categorias (automóveis, motocicletas, veículos comerciais), ciclistas, pedestres e fauna \cite[p. ~17]{zheng2023simultaneous}.
\end{description}

É importante destacar que esta taxonomia apresenta natureza dinâmica, uma vez que determinados objetos podem transitar entre classificações dependendo de seu estado operacional instantâneo. Um exemplo paradigmático são os semáforos, que podem alternar entre diferentes estados visuais (verde, amarelo, vermelho), modificando sua relevância para as decisões de controle do veículo em tempo real.

\subsubsection{Localização Ego-Referencial e Percepção Ambiental} \label{subsubsec:ego-referencial_per-ambiental}

Complementarmente à classificação de elementos ambientais vistos na subseção \ref{percepcao}, o subsistema de percepção abrange duas dimensões fundamentais: a localização ego-referencial e a percepção ambiental propriamente dita.

A \textbf{localização ego-referencial} refere-se à determinação precisa do estado interno do veículo, incluindo posição, orientação e velocidade no referencial global. Embora não seja abordada em detalhes neste estudo devido ao escopo limitado a trajetórias predefinidas, esta componente representa um elemento essencial para futuras expansões do trabalho que contemplem aspectos dinâmicos de geração de trajetórias em tempo real. A localização ego-referencial integra tipicamente dados provenientes de múltiplas fontes, incluindo Sistemas Globais de Navegação por Satélite, Unidades de Medição Inercial e sensores de odometria, proporcionando estimativas precisas do estado veicular para suporte às decisões de controle.

Por sua vez, a \textbf{percepção ambiental} constitui o foco principal deste trabalho, sendo responsável pela interpretação do ambiente circundante via sensores exteroceptivos (apresentados na Subseção \ref{sensor}) como câmeras, radar, LiDAR e sensores ultrassônicos. Esta modalidade de percepção visa identificar, classificar e localizar elementos estáticos e dinâmicos relevantes para a navegação segura do veículo.

Neste trabalho, as câmeras constituem o sensor primário para detecção e classificação de objetos, fundamentando-se em sua pontuação superior (4) na matriz de adequação sensorial apresentada na Figura \ref{all-sense}. Esta seleção justifica-se pela capacidade das câmeras de fornecer informações visuais ricas e detalhadas, essenciais para algoritmos de visão computacional baseados em redes neurais convolucionais, como veremos na subseção \ref{yolo_section}. Entretanto, é importante ressaltar que sistemas comerciais de condução autônoma tipicamente empregam estratégias de fusão sensorial, combinando múltiplas modalidades para otimizar o desempenho e aumentar a robustez em cenários operacionais variados \cite[p. ~9]{zheng2023simultaneous}.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/translated_image_pt.png}
\caption{Componentes funcionais de um sistema de direção autônomo e arquitetura \cite[p. ~2]{zheng2023simultaneous}.}
\label{componentes-funcionais}
\end{figure}


A Figura \ref{componentes-funcionais} ilustra a integração entre esses sistemas de ego e percepção ambiental. Os VA podem utilizar tanto mapas pré-armazenados (contendo coordenadas de trajetórias) quanto serviços de mapeamento dinâmico para navegação em ambientes desconhecidos \cite[p. ~2]{zheng2023simultaneous}.

\subsubsection{Componentes de Hardware} \label{sensor}

Esta subseção apresenta uma taxonomia abrangente dos sistemas sensoriais fundamentais para a percepção em VA, estabelecendo as bases tecnológicas necessárias para a compreensão ambiental visto na subseção \ref{subsubsec:ego-referencial_per-ambiental} anterior. Como veremos nesta subseção, os sensores constituem as interfaces primárias entre o sistema autônomo e seu ambiente operacional, sendo comumente classificados em duas categorias principais conforme \citeonline[p. ~737]{sensors}:

\begin{enumerate}
\item \textbf{Sensores Proprioceptivos:} responsáveis pelo monitoramento do estado interno do sistema, registrando parâmetros dinâmicos como força, velocidade angular, pressão de pneus e voltagem de sistemas. Incluem unidades de medição inercial, codificadores, sensores inerciais (giroscópios e magnetômetros) e sensores de localização. Normalmente, usados para localização de ego visto na subseção \ref{subsubsec:ego-referencial_per-ambiental} e ilustrado na Figura \ref{figura_compone};

\item \textbf{Sensores Exteroceptivos:} dedicados à percepção do ambiente (apresentado na subseção \ref{subsubsec:ego-referencial_per-ambiental}) externo, coletando informações sobre distância, intensidade luminosa e características dos objetos circundantes. Compreendem câmeras, sistemas radar e LiDAR, e sensores ultrassônicos, conforme ilustrado nas Figuras \ref{figura_compone} e \ref{figura-sensores}.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{Figures/compo.png}
\caption{Configuração de componentes sensoriais em veículo autônomo \cite[p. ~15]{aplicacao2}}
\label{figura_compone}
\end{figure}

A Figura \ref{figura-sensores} ilustra a disposição estratégica dos sensores em um VA típico, evidenciando a necessidade de cobertura de todas as direções para operação segura.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/sensors_needed_for_perception-week2-v1-9m.png}
\caption{Configuração sensorial em VA: tipos e posicionamento estratégico \cite[Week 2 - Lesson 1: Sensors and Computing Hardware. ~9min00s]{University_of_Toronto2018-fe}}
\label{figura-sensores}
\end{figure}

A integração sensorial, conforme demonstrado nas Figuras \ref{figura-sensores} e \ref{all-sense}, é fundamental para viabilizar o desempenho satisfatório dos VA em uma ampla gama de cenários que demandam percepção, tais como: condições de chuva em dias ensolarados, terrenos escorregadios com lama, neblina, entre outros. Considerando que a percepção está sujeita a incertezas provenientes dos sensores, como desafios de visibilidade, leituras de GPS corrompidas e retornos ruidosos dos sensores, a combinação destes componentes sensoriais constitui estratégia essencial para aprimorar o desempenho dos VA em cenários variados.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/all-sense.png}
\caption{Matriz de adequação sensorial para diferentes condições operacionais \cite[p. ~6]{sensors-yet}}
\label{all-sense}
\end{figure}

A seguir veremos uma visão geral dos principais sensores da Figura \ref{all-sense}:

\textbf{Câmeras:} constituem sensores exteroceptivos (veja \ref{subsubsec:ego-referencial_per-ambiental}) fundamentais, capturando informações detalhadas do ambiente através da produção de imagens nítidas dos arredores, detectando luzes emitidas a partir de uma superfície fotossensível (plano de imagem) usando uma lente de câmera posicionada na frente do sensor \cite[p. ~738]{sensors} e acoplada, normalmente, na frente do veículo para detecção e reconhecimento de objetos. Sendo essa a característica de destaque das câmeras, detecção e reconhecimento de objetos, fornecendo detalhes mais ricos e auxiliando na compreensão dos objetos com ou sem informações de profundidade, características geralmente não detectadas por outros tipos de sensores \cite[p. ~4]{yao2023radar}.

\textbf{LiDAR:} sistemas de \textit{Light Detection and Ranging}, concebidos pela primeira vez na década de 1960, desempenham um papel fundamental no mapeamento de terrenos nas esferas aeronáutica e aeroespacial \cite[p. ~738]{sensors}. No contexto dos VA, os sensores LiDAR destacam-se como instrumentos que empregam a luz como meio para mensurar distâncias, através do cálculo do tempo necessário para a luz ser refletida no receptor \cite[p. ~1911]{mao20233d}.

\textbf{Radar:} os \textbf{Radio Detection and Ranging}, desenvolvidos antes da Segunda Guerra Mundial, utilizam ondas eletromagnéticas para detecção, emitindo ondas na região de interesse e recebendo as ondas dispersas (reflexões) provenientes de alvos \cite[p. ~738]{sensors}. O Radar opera de maneira análoga ao LiDAR, porém utiliza ondas de rádio para medir a distância entre o sensor e os objetos. Adicionalmente, pode observar a velocidade relativa entre o sensor e o objeto através da medição do deslocamento Doppler, permitindo distinguir entre objetos estacionários e em movimento. Quando comparado ao LiDAR, o Radar apresenta vantagens em termos de custo mais baixo, menor consumo de energia e menor sensibilidade às condições atmosféricas. Entretanto, possui resolução de medição inferior e suas detecções são mais espaçadas \cite[p. ~8]{zheng2023simultaneous}.

\textbf{Sensores Ultrassônicos:} empregam a técnica de medição \textit{Time-of-Flight} para determinar a distância até objetos, funcionando por meio do envio e recebimento de ondas sonoras. Similar ao Radar, este tipo de sensor adquire informações de maneira dispersa, resultando em uma extração imprecisa de recursos e em tempo de processamento prolongado. Sua aplicabilidade é restrita em contextos que envolvem veículos de alta velocidade. Adicionalmente, possuem alcance de detecção limitado, podendo ser impactados pelo ruído ambiental e por outras plataformas que utilizam ultrassom com a mesma frequência \cite[p. ~8]{zheng2023simultaneous}.

%Iniciando a apresentação dos principais sensores proprioceptivos e seus papéis fundamentais na obtenção de informações cruciais para a navegação veicular, destacam-se os GNSS e IMUs, responsáveis por mensurar diversos parâmetros, tais como posição, velocidade, direção, taxa de rotação angular e acelerações do veículo ego \cite[p. ~2]{zheng2023simultaneous}. A fusão de dados provenientes da IMU com sensores como Câmera ou LiDAR contribui significativamente para a estimativa de estado, abrangendo elementos como posição, velocidade e atitude do veículo. A utilização da IMU torna as atitudes, especialmente o direcionamento, observáveis, e a integração das medições demonstra melhorias substanciais no desempenho do rastreamento de movimento durante períodos nos quais as observações são interrompidas momentaneamente \cite[p. ~9]{zheng2023simultaneous}.

%Associados a esses dispositivos, encontram-se também os sensores de odometria das rodas, cuja função é rastrear informações provenientes das rodas para estimar tanto a velocidade quanto a taxa de mudança de direção do veículo, elementos cruciais para o eficaz controle veicular.

Esses sensores apresentados anteriormente, são estrategicamente posicionados no veículo buscando otimizar a cobertura ambiental, atendendo às necessidades específicas de diferentes manobras. A análise de cobertura, apresentada na Figura \ref{coverage}, destaca os requisitos de sensores de longo alcance com campos de visão angulares mais estreitos e sensores de amplo campo angular para percepção de diferentes direções.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/coverage.png}
\caption{Matriz de cobertura sensorial e requisitos operacionais \cite[Week 2 - Lesson 2: Hardware Configuration Design. ~9min00s]{University_of_Toronto2018-fe}}
\label{coverage}
\end{figure}

Conforme os cenários se tornam mais complexos, evidencia-se a demanda pela fusão desses sensores e por cobertura de 360 graus para curtas distâncias e alcances longitudinais estendidos. Neste trabalho, daremos foco a cobertura de médio e longo alcance mediante ao uso de câmaras. %A configuração de sensores na Figura \ref{coverage} ilustra a necessidade de uma variedade de sensores, incluindo: Ultrassônico e Sonar necessários para entrada 3D em curto alcance, úteis em manobras de estacionamento e detecção de objetos próximos; LiDAR essencial para entrada 3D em todas as condições, permitindo a detecção precisa e abrangente de obstáculos e veículos à frente; Radar importante para avaliar e identificar a velocidade, movimentação e posição de veículos em todos os ambientes; Câmera necessária para identificar objetos, veículos, pedestres e sinais de trânsito, com campo de visão amplo para monitorar movimentos em todas as direções, especialmente em interseções. O alcance desses sensores é modificado conforme a necessidade do fabricante \cite[Week 2 - Lesson 2: Hardware Configuration Design]{University_of_Toronto2018-fe}.

\subsubsection{Detecção e Classificação de Objetos} \label{yolo_section}


 Soluções de detecção e classificação de objetos, com destaque especial para a arquitetura You Only Look Once (YOLO), introduzida por \citeonline{redmon2016lookonceunifiedrealtime}. Esta abordagem formula a detecção e classificação de objetos como um problema unificado de regressão, integrando a identificação de regiões de interesse com a atribuição de classes em um processo singular.

Esta estratégia confere significativas vantagens computacionais, possibilitando processamento em tempo real com latência inferior a 50 milissegundos \cite[p. ~1]{redmon2016lookonceunifiedrealtime}, característica essencial para aplicações críticas como VA. O YOLO oferece uma solução integrada para detecção, refinamento e classificação que observa a imagem somente uma vez (You Only Look Once), reduzindo assim a complexidade e os custos computacionais envolvidos no processo \cite{redmon2016lookonceunifiedrealtime}.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/YOLO.jpg}
\caption{Pipeline de processamento do sistema YOLO: (1) redimensionamento da imagem para 448×448 pixels, (2) processamento através de rede convolucional única, (3) filtragem baseada em confiança do modelo \cite[p. ~1]{redmon2016lookonceunifiedrealtime}}
\label{YOLO_}
\end{figure}

O processamento YOLO, ilustrado na Figura \ref{YOLO_}, segue três etapas principais: redimensionamento das imagens de entrada para o tamanho esperado pela rede neural convolucional, processamento via rede neural para geração de predições de áreas de interesse e classes correspondentes, e filtragem mediante \textit{Non-Maximum Suppression} para eliminação de detecções redundantes, mantendo somente as predições com maior confiança \cite{redmon2016lookonceunifiedrealtime}.

Ao combinar a identificação de áreas de interesse com a classificação em um único processo, o YOLO se torna um dos algoritmos mais rápidos de sua classe, embora, em algumas circunstâncias, sacrifique ligeiramente a precisão em relação a métodos mais lentos. A principal vantagem da arquitetura YOLO reside na consideração de contexto global da imagem, facilitando a distinção entre o plano de fundo e os objetos de interesse, cometendo menos da metade do número de erros em comparação ao Fast Region-based Convolutional Networks (Fast R-CNN) \cite[p. ~2]{redmon2016lookonceunifiedrealtime}.

Desde sua versão inicial, a família YOLO tem experimentado melhorias substanciais, estabelecendo-se como referência em detecção de objetos. As versões posteriores introduziram aprimoramentos significativos: YOLOv2 expandiu a capacidade de classes e melhorias de desempenho, lidando com até 9.000 classes de objetos \cite{redmon2016yolo9000betterfasterstronger}; YOLOv3 trouxe avanços na detecção de objetos pequenos e na precisão geral \cite{redmon2018yolov3incrementalimprovement}; e YOLOv4 introduziu otimizações adicionais, mantendo o foco em velocidade e precisão \cite{bochkovskiy2020yolov4optimalspeedaccuracy}.

O progresso da metodologia YOLO expandiu-se para áreas correlatas, incluindo segmentação de instâncias, rastreamento de múltiplos objetos, análise comportamental, reconhecimento facial, entre outras. Isso reflete sua importância como um pilar tecnológico para aplicações em direção autônoma, robótica industrial, autenticação de identidade, saúde inteligente e vigilância visual \cite{wang_yolov1_to_yolov10}.

A capacidade do YOLO de se adaptar a diferentes contextos e sua contínua evolução são características fundamentais que sustentam sua popularidade. As versões mais consolidadas e de livre acesso, como YOLOv7 e YOLOv8, continuam a superar desafios em cenários complexos, como ambientes com objetos pequenos ou parcialmente ocluídos. Por exemplo, uma das versões mais recentes, YOLOv10, representa uma convergência entre precisão e eficiência computacional, demonstrando que a pesquisa em torno deste \textit{framework} continua avançando \cite{wang_yolov1_to_yolov10}. A Figura \ref{YOLO10} apresenta uma análise comparativa demonstrando os avanços em termos de latência-precisão entre diferentes versões.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/yolo10.png}
\caption{Análise comparativa de desempenho: trade-offs latência-precisão (esquerda) e tamanho-precisão (direita) para diferentes arquiteturas YOLO \cite[p. ~1]{wang2024yolov10realtimeendtoendobject}. Modificado pelo autor, \textit{label} como (Nosso) mostrando a versão YOLO usada neste trabalho.}
\label{YOLO10}
\end{figure}

\subsection{Arquitetura da Tarefa de Condução} \label{ar_soft}

Esta subseção apresenta uma arquitetura de software modular representativa para VA, fundamentada na decomposição hierárquica das funções de condução autônoma. A arquitetura proposta integra componentes de \textit{hardware} e \textit{software} para alcançar o objetivo de navegação autônoma, estruturando-se em diferentes módulos essenciais que operam de forma coordenada e interdependente.

A pilha de software, ilustrada na Figura \ref{soft_ar}, compreende os seguintes subsistemas: percepção do ambiente, mapeamento do ambiente, planejamento de movimento, controle do veículo e supervisão do sistema. Esta decomposição modular, amplamente adotada na literatura de VA \cite[p. ~4]{paden2016survey}, facilita o desenvolvimento, manutenção e validação de cada componente de forma independente, enquanto mantém interfaces bem definidas para integração sistêmica.

\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/arquitetura_Software.png}
\caption{Arquitetura de software para veículos autônomos: decomposição modular e fluxo de dados entre subsistemas \cite[Week 2 - Lesson 3: Software Architecture. ~3min49s]{University_of_Toronto2018-fe}}
\label{soft_ar}
\end{figure}

A seguir, apresenta-se uma análise detalhada de cada módulo, destacando suas funções específicas, entradas de dados, processamentos realizados e saídas geradas:

\begin{itemize}
\item \textbf{Aquisição de Dados Sensoriais:} a implementação da condução autônoma fundamenta-se na coleta sistemática de dados provenientes de múltiplos sensores embarcados, conforme discutido na Subseção \ref{sensor} e exemplificado na matriz de adequação sensorial da Figura \ref{all-sense}. O conjunto sensorial típico inclui todos os apresentados na Subseção \ref{sensor}. Por exemplo, câmaras adicionadas em veículos são responsáveis pela aquisição de dados brutos do ambiente circundante, os quais são posteriormente processados e integrados nos módulos subsequentes da arquitetura. 

\item \textbf{Mapeamento e Representação Ambiental:} o módulo de mapeamento é responsável pela geração de diferentes representações espaciais do ambiente operacional, fundamentais para a prevenção de colisões e o planejamento de trajetórias. Este subsistema produz três categorias principais de mapas, cada uma otimizada para funções específicas \cite[Week 2 - Lesson 3: Software Architecture. ~6min24s]{University_of_Toronto2018-fe}:

\textbf{Mapa de Grade de Ocupação:} construído primariamente a partir de dados LiDAR processados, este tipo de mapa identifica e localiza objetos estáticos no ambiente, como edificações, vegetação e infraestrutura viária. A representação utiliza uma grade bidimensional onde cada célula possui uma probabilidade associada de ocupação, calculada mediante algoritmos de filtragem que removem ruídos e pontos irrelevantes dos dados sensoriais \cite[p. ~14]{zheng2023simultaneous}.

\textbf{Mapa de Localização:} gerado pela fusão de dados LiDAR e/ou câmeras, este mapa cria uma representação tridimensional do ambiente em nuvem de pontos, otimizada para estimativa precisa do estado ego-referencial do veículo. Durante a operação, os dados sensoriais em tempo real são correlacionados com este mapa pré-construído para determinar a posição e orientação do veículo com alta precisão \cite[p. ~14]{zheng2023simultaneous}. 

\textbf{Mapa Detalhado de Estradas:} este tipo especializado de mapa incorpora informações semânticas sobre a infraestrutura viária, incluindo geometria de faixas, sinalização vertical e horizontal, e elementos regulamentares. Combina dados pré-processados com informações em tempo real coletadas pelo módulo de percepção, fornecendo contexto essencial para o planejamento de manobras \cite[p. ~15]{zheng2023simultaneous}.

\item \textbf{Percepção e Interpretação Ambiental:} o módulo de percepção constitui o sistema responsável pela interpretação inteligente do ambiente operacional através da integração de dados proprioceptivos e exteroceptivos, conforme apresentado anteriormente na subseção \ref{sensor}. Esta modalidade identifica e classifica entidades como veículos, pedestres, ciclistas, sinalização de trânsito e marcações viárias \cite[p. ~2]{zheng2023simultaneous}, \cite[p. ~737]{sensors}.

\item \textbf{Planejamento Hierárquico de Movimento:} o planejamento de movimento implementa uma abordagem hierárquica que decompõe o problema complexo de navegação em três níveis de abstração temporal e espacial, cada um otimizado para escalas específicas de decisão \cite[Week 2 - Lesson 3: Software Architecture. ~6min24s]{University_of_Toronto2018-fe}:

\textbf{Planejamento de Missão:} opera em escala global, determinando a sequência ótima de segmentos viários desde a posição atual até o destino. Este problema é modelado como busca de caminho mínimo em um grafo direcionado, onde vértices representam interseções e arestas correspondem a segmentos viários com custos associados. Embora redes viárias possam conter milhões de elementos, algoritmos especializados permitem computação de rotas ótimas em redes continentais em tempo de milissegundos \cite[p. ~3-4]{paden2016survey}. A solução encontrada para este trabalho pode ser vista na Subseção \ref{subsec:planejamento_de_missao}.

\textbf{Planejamento Comportamental:} aborda decisões táticas de médio prazo, estabelecendo sequências de manobras seguras e regulamentares ao longo da rota definida pela missão. Este nível determina comportamentos como mudanças de faixa, precedência em interseções e respostas a sinalização de trânsito \cite[p. ~4]{paden2016survey}. A solução encontrada para este trabalho pode ser vista na Subseção \ref{subsec:planejamento_comportamental}.

\textbf{Planejamento Local:} executa o planejamento operacional imediato, gerando trajetórias específicas e perfis de velocidade para execução pelo sistema de controle. Este módulo deve produzir trajetórias suaves, seguras e eficientes, respeitando restrições cinemáticas e dinâmicas do veículo (apresentados na subseção \ref{modelagem_2D}), bem como limitações impostas pelo ambiente operacional \cite[p. ~3]{paden2016survey}. A solução encontrada para este trabalho pode ser vista na Subseção \ref{subsec:planejamento_local}.

\item \textbf{Controle de Movimento:} o módulo de controle é responsável pela execução precisa das trajetórias geradas pelo planejamento de movimento, traduzindo comandos de alto nível em sinais de atuação específicos. Este subsistema decompõe o problema de controle em duas dimensões: controle longitudinal (vistos na Subseção \ref{PID}), que regula aceleração e frenagem para manutenção de velocidades desejadas, e controle lateral (vistos na Subseção \ref{intro_controle_lateral}), que ajusta o ângulo de direção para seguimento preciso da trajetória planejada \cite[Week 2 - Lesson 3: Software Architecture. ~10min54s]{University_of_Toronto2018-fe}. As soluções encontrada para este trabalho pode ser vista na Subseção \ref{modelagem_veiculos}.

\item \textbf{Supervisão e Monitoramento Sistêmico:} o supervisor constitui um sistema de monitoramento contínuo que assegura a operação segura e confiável de todos os componentes do VA. Este módulo implementa duas funções críticas: supervisão de hardware, responsável pela detecção de falhas em sensores e atuadores, e supervisão de software, que valida a consistência e coerência das saídas de todos os módulos, identificando possíveis inconsistências ou comportamentos anômalos \cite[Week 2 - Lesson 3: Software Architecture. ~11min37s]{University_of_Toronto2018-fe}.

\item \textbf{\textit{Interface} de Atuação:} o estágio final da arquitetura converte comandos de controle em sinais de atuação física, interfaceando com os sistemas mecânicos e eletrônicos do veículo. Esta \textit{interface} traduz comandos abstratos de velocidade e direção em sinais específicos para acelerador, freios, direção e outros atuadores, garantindo a execução precisa das decisões tomadas pelos módulos superiores. No presente trabalho, a \textit{interface} está relacionada à conexão do cliente do simulador, conforme apresentaremos na Subseção \ref{subsubsec:simulador_carla}.
\end{itemize}

Esta arquitetura modular facilita a implementação, teste e manutenção de sistemas autônomos complexos, permitindo desenvolvimento e otimização independente de cada subsistema enquanto mantém interfaces bem definidas para integração sistêmica robusta e confiável. A arquitetura escolhida para este trabalho pode ser observada no Capítulo \ref{ModelagemConceitual}, que implementa uma variação da arquitetura da Figura \ref{soft_ar} apresentada pelo trabalho \citeonline{University_of_Toronto2018-fe}.


\section{Simulação de Carros Autônomos}\label{controlador_controle_de_VA-simulador}

Esta seção aborda os fundamentos metodológicos e tecnológicos da simulação computacional aplicada ao desenvolvimento de VA, constituindo uma ferramenta essencial para validação experimental e mitigação de riscos no processo de desenvolvimento de sistemas autônomos. A simulação representa uma metodologia consolidada que permite a integração e validação dos conceitos teóricos discutidos nas Seções \ref{levelcla} e \ref{componentes_da_tarefa_de_conducao} anteriores em um ambiente controlado e reprodutível.

Os ambientes de simulação oferecem um contexto experimental no qual algoritmos, sistemas de controle e estratégias de percepção podem ser rigorosamente testados sem os custos, riscos e limitações logísticas associados à implementação em veículos reais. Esta abordagem permite a execução sistemática de cenários complexos, envolvendo múltiplos agentes autônomos, condições ambientais variadas e situações de tráfego diversificadas, possibilitando a repetição de experimentos centenas ou milhares de vezes para garantir a robustez estatística dos resultados \cite[p. ~1]{dosovitskiy2017carla}.

A validação por simulação constitui, portanto, uma etapa metodológica fundamental para o cumprimento dos objetivos específicos estabelecidos na Seção \ref{objetivos_esp} deste trabalho, particularmente no que se refere à implementação e validação experimental do sistema integrado de detecção e controle proposto.

\subsection{Panorama de Ambientes de Simulação para Veículos Autônomos}

O desenvolvimento de VA tem sido historicamente acompanhado pela evolução paralela de plataformas de simulação especializadas, desenvolvidas tanto pela indústria quanto por instituições acadêmicas. Conforme destacado por \citeonline[p. ~1]{dosovitskiy2017carla}, os simuladores têm sido utilizados desde os primeiros estágios da pesquisa em condução autônoma, servindo como ferramentas fundamentais para treinamento e avaliação de sistemas de percepção veicular.

Uma prática comum na área tem sido a utilização \textit{ad hoc}\footnote{O termo "\textit{ad hoc}" deriva do latim e refere-se a soluções desenvolvidas especificamente para resolver um problema particular, não sendo passíveis de generalização para outros contextos \cite{noauthor_undated-sq}.} de jogos comerciais para extração de dados visuais de alta fidelidade destinados ao treinamento de sistemas de percepção. Embora esta abordagem tenha demonstrado utilidade em cenários específicos, a maioria das plataformas de simulação existentes apresenta limitações significativas para aplicações em VA.

\subsubsection{Limitações de Simuladores Existentes}

Os simuladores de corrida de código aberto, exemplificados pelo TORCS (\textit{The Open Racing Car Simulator}), apresentam deficiências substanciais para reproduzir a complexidade da condução urbana. Estes ambientes carecem de elementos essenciais ao contexto urbano, incluindo pedestres, interseções semaforizadas, tráfego cruzado, sinalização viária e regulamentações de trânsito que caracterizam a condução em ambientes urbanos complexos \cite[p. ~1]{dosovitskiy2017carla}.

Similarmente, jogos comerciais que simulam ambientes urbanos com alta fidelidade visual, como \textit{Grand Theft Auto V}, não fornecem suporte adequado para avaliação quantitativa de políticas de condução autônoma. Entretanto, estas plataformas apresentam limitações críticas, incluindo: (i) controle limitado sobre parâmetros ambientais e configurações de cenário, (ii) conjunto restrito de sensores virtuais disponíveis, (iii) ausência de \textit{feedback} detalhado sobre violações de regras de trânsito, e (iv) incompatibilidade com objetivos de pesquisa científica devido à sua natureza comercial e código proprietário.

\subsubsection{O Simulador CARLA como Plataforma de Desenvolvimento} \label{subsubsec:simulador_carla}

Em função das limitações identificadas nas plataformas existentes, este trabalho adota o simulador CARLA (\textit{Car Learning to Act}) \citeonline{dosovitskiy2017carla} como ambiente de desenvolvimento e validação. O CARLA representa uma plataforma de simulação de código aberto especificamente projetada para pesquisa em condução autônoma, desenvolvida colaborativamente pelo \textit{Computer Vision Center} da Universidade Autônoma de Barcelona, Intel Labs e Toyota Research Institute, utilizando o motor gráfico \textit{Unreal Engine 4} e, recentemente em 2025, o \textit{5}\footnote{Um motor gráfico (\textit{game engine}) constitui um conjunto integrado de bibliotecas de software projetado para facilitar o desenvolvimento de aplicações gráficas em tempo real, incluindo simulações e jogos eletrônicos \cite{lewis2002game}.}.

As características técnicas que justificam a seleção do CARLA incluem \cite{dosovitskiy2017carla}:

\begin{enumerate}
\item \textbf{Ambientes Urbanos Realistas:} o simulador oferece representações detalhadas de cenários urbanos, desenvolvidas por equipes especializadas de artistas digitais, abrangendo modelos precisos de veículos, infraestrutura viária, pedestres e sinalização de trânsito;

\item \textbf{Configurabilidade Sensorial:} permite a configuração flexível de conjuntos de sensores virtuais, incluindo câmeras RGB, sensores LiDAR, radar e sensores de profundidade, com parâmetros customizáveis para diferentes cenários experimentais, conforme apresentaremos na Subseção \ref{camera};

\item \textbf{Interface de Programação Robusta:} fornece APIs (\textit{Application Programming Interfaces}) em Python que permitem controle programático completo sobre veículos, coleta de dados sensoriais e configuração de cenários de teste.

\item \textbf{Métricas de Avaliação Integradas:} Disponibiliza dados detalhados sobre colisões, violações de trânsito, coordenadas GPS, velocidade, aceleração e outros parâmetros relevantes para avaliação quantitativa de desempenho.
\end{enumerate}

\subsubsection{Capacidades Ambientais e Configurações de Teste}

O CARLA oferece versatilidade significativa em termos de condições ambientais simuladas, permitindo variações em condições climáticas, iluminação e características do ambiente urbano. A Figura \ref{carla_weather} ilustra as diferentes configurações ambientais disponíveis, incluindo condições de clima claro, nublado e chuvoso, bem como os mapas urbanos predefinidos: \textit{Town01} (Mapa para nossa solução, conforme veremos no Capítulo \ref{Implementação}), \textit{Town02}, \textit{RaceTrack} e \textit{Town03}.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/carla_all-weather_all-maps.png}
\caption{Ambientes de simulação CARLA: variações climáticas e mapas urbanos disponíveis no CARLA \cite{noauthor_undated} (adaptado pelo autor).}
\label{carla_weather}
\end{figure}

A arquitetura cliente-servidor que o CARLA oferece, permite controle externo completo sobre a simulação, possibilitando o envio de comandos de controle ao veículo, coleta sistemática de dados experimentais e execução automatizada de cenários de teste para avaliação quantitativa de desempenho. Esta configuração é fundamental para a implementação da metodologia experimental proposta neste trabalho, conforme detalhado no Capítulo \ref{Implementação}.

Esta infraestrutura de simulação constitui, portanto, a base tecnológica necessária para validação experimental dos módulos de percepção, planejamento e controle desenvolvidos, permitindo avaliação rigorosa da hipótese de pesquisa estabelecida na Seção \ref{hipotese} em condições controladas e reprodutíveis.

\section{Trabalhos Relacionados} \label{trabalhos_relacionados}

Esta seção, conforme estabelecido nos métodos da Seção \ref{metodo}, apresenta uma revisão sistemática da literatura científica relacionada à aplicação de algoritmos de detecção de objetos, especificamente YOLO, em simuladores para desenvolvimento de VA. A análise está organizada em quatro categorias principais: (i) integração de YOLO com simuladores, (ii) desafios em condições ambientais adversas, (iii) sistemas de assistência ao condutor baseado em visão computacional, e (iv) otimizações arquiteturais do algoritmo YOLO.

\subsection{Integração de YOLO com Simuladores}

Conforme estabelecido nas Subseções \ref{yolo_section} e \ref{subsubsec:simulador_carla}, a integração de algoritmos YOLO com ambientes de simulação constitui uma abordagem fundamental para o desenvolvimento e validação de sistemas complexos de VA. Esta integração permite testes controlados e reprodutíveis, essenciais para a validação de hipóteses científicas em condições operacionais variadas. Conforme feito nos seguintes trabalhos:

\citeonline{andrade_object_detection_distance} desenvolveu uma solução que utiliza YOLOv4 para detecção de objetos e estimativa de distância entre veículos no simulador CARLA. Este trabalho demonstra a viabilidade técnica de integrar algoritmos de visão computacional com simuladores para aplicações de condução autônoma, estabelecendo um precedente metodológico relevante para esta pesquisa.

Paralelamente, \citeonline{sanchez_speed_sign_detection} apresenta em sua dissertação de mestrado um sistema para detecção de placas de velocidade com \textit{feedback} ao motorista. Embora este trabalho compartilhe objetivos similares com a presente pesquisa, diferencia-se fundamentalmente pela abordagem: enquanto \citeonline{sanchez_speed_sign_detection} foca somente na assistência ao condutor humano, o presente trabalho propõe um sistema de condução autônoma completo que integra detecção de placas de parada e assistência ao condutor humano com controle veicular autônomo no simulador CARLA.

\subsection{Desafios em Condições Ambientais Adversas}

A robustez de algoritmos de detecção em condições ambientais variadas constitui um desafio crítico para sistemas de VA. Sabendo disso, \citeonline{kim2023challenges} conduziram uma análise abrangente das limitações dos algoritmos de detecção de objetos, incluindo YOLO, em condições adversas. Os autores identificaram que métodos baseados em aprendizado profundo apresentam alta dependência dos dados de treinamento, limitando sua aplicabilidade em cenários não representados adequadamente nos conjuntos de dados originais.

Especificamente, \citeonline{kim2023challenges} demonstraram que modelos treinados com imagens de precipitação de 10mm/h apresentaram degradação significativa de desempenho quando testados em condições de precipitação superior, evidenciando o problema de generalização em cenários climáticos extremos. Para mitigar essas limitações, os autores propuseram o uso de ambientes virtuais como o CARLA para geração de dados sintéticos, facilitando a coleta sistemática de dados para treinamento em condições climáticas controladas.

Complementando estes resultados, \citeonline{Gao_2021} realizaram uma análise comparativa entre YOLOv4, CenterNet e Faster-RCNN no simulador CARLA, identificando o YOLOv4 como o algoritmo mais eficiente para detecção de objetos sem otimizações específicas no ano de sua publicação. Este estudo reforça o potencial do YOLO em diferentes condições experimentais e valida a escolha metodológica adotada no presente trabalho.

\subsection{Sistemas de Assistência Baseados em Visão Computacional}

A aplicação de YOLO em sistemas de assistência ao condutor tem demonstrado resultados promissores em diversos contextos operacionais. \citeonline{ahammed2024computer} desenvolveram um sistema baseado em YOLO para detecção de obstáculos em zonas de construção, alcançando precisão de 94\% com tempos de inferência de 1,6ms. Este trabalho demonstra a viabilidade de sistemas de assistência em tempo real para cenários específicos de aplicação.

Ademais, \citeonline{W4389342036} apresenta uma abordagem integrada para detecção de faixas e sinais de trânsito em sistemas de assistência avançada ao motorista. Utilizando o simulador CARLA, o autor implementa modelos baseados em redes neurais convolucionais, incluindo SegNet para segmentação semântica e YOLO para detecção de objetos. A arquitetura proposta, ilustrada na Figura \ref{trabalhos_relacionados_block}, integra sensores RGB com OCR (Tesseract) em um \textit{pipeline} de duas etapas: identificação e reconhecimento.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/trabalhos_relacionados_block.png}
\caption{Arquitetura de sistema para detecção de sinais de trânsito proposta por \citeonline{W4389342036}}
\label{trabalhos_relacionados_block}
\end{figure}

O sistema proposto por \citeonline{W4389342036} alcançou métricas de desempenho significativas: o modelo SegNet obteve mAP\footnote{A métrica \textit{mean Average Precision} (mAP) representa a média da precisão média em todos os valores de \textit{recall}, constituindo uma métrica padrão para avaliação de algoritmos de detecção de objetos.} de 93,33\% para detecção de faixas, enquanto o modelo YOLO atingiu mAP de 93,67\% para detecção de sinais de trânsito. O fluxograma de processamento, apresentado na Figura \ref{trabalhos_relacionados_fluxo}, demonstra a integração sistemática entre detecção e reconhecimento textual.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/trabalhos_relacionados_fluxo.png}
\caption{Fluxograma de processamento para detecção de sinais de trânsito \cite[p. ~2065]{W4389342036}}
\label{trabalhos_relacionados_fluxo}
\end{figure}

Os experimentos foram conduzidos em conjunto de dados contendo 612 imagens extraídas do CARLA, abrangendo diferentes condições climáticas e cenários urbanos, incluindo placas de velocidade (30, 60, 90 km/h) e sinais de parada. Esta metodologia experimental apresenta similaridades significativas com a abordagem adotada no presente trabalho, particularmente na utilização do CARLA para validação de sistemas de detecção em tempo real.

\subsection{Otimizações Arquiteturais do YOLO}

A evolução contínua da arquitetura YOLO tem sido impulsionada por modificações específicas para aplicações especializadas. \citeonline{Wu_2022} propuseram melhorias no YOLOv4 para detecção de sinais de trânsito, incorporando redes mais eficientes como MobileNetV2 para extração de características, resultando em redução de complexidade computacional mantendo precisão adequada.

\citeonline{s23167145} focaram na melhoria da detecção de objetos pequenos, desenvolvendo aprimoramentos no YOLOv7 através de camadas específicas para alvos pequenos e métricas de distância otimizadas. Estas modificações demonstram a adaptabilidade da arquitetura YOLO para cenários específicos e complexos, reforçando sua adequação para aplicações críticas em VA.

A implementação prática destes avanços tem sido majoritariamente realizada através do \textit{framework} Darknet \cite{darknet13}, uma biblioteca de redes neurais de código aberto em C e CUDA que oferece suporte tanto para CPU quanto GPU. A escolha pelo Darknet fundamenta-se em sua simplicidade, baixo custo computacional e ampla compatibilidade com diferentes ambientes de desenvolvimento \cite{redmon2016lookonceunifiedrealtime}.

Para aplicações em tempo real, versões otimizadas como YOLOv3-Tiny têm sido amplamente adotadas devido à sua arquitetura reduzida (16 camadas convolucionais comparadas às 75 da versão completa), proporcionando maior velocidade de processamento com ligeira redução na precisão \cite{redmon2018yolov3incrementalimprovement}.

\subsection{Limitações e Desafios Identificados} \label{subsec:limitacoes}

Apesar dos avanços significativos, a literatura revela limitações importantes que devem ser consideradas. \citeonline{wu_physical_adversarial_attack} demonstraram vulnerabilidades de redes neurais a ataques adversários, evidenciando a possibilidade de criar camuflagens que impedem detecção ou causam classificações errôneas. Estas vulnerabilidades ressaltam a necessidade de desenvolvimento de modelos mais robustos para aplicações críticas de segurança e ambientes de validação são essenciais para isso.

\subsection{Posicionamento do Trabalho Atual}

A análise da literatura revela uma lacuna significativa na integração completa de sistemas de detecção com controle veicular autônomo em ambientes simulados. Enquanto trabalhos anteriores focam predominantemente em assistência ao condutor ou detecção isolada, o presente trabalho propõe uma arquitetura integrada que combina:

\begin{enumerate}
\item Detecção de objetos em tempo real usando YOLOv8;
\item Sistema de controle veicular autônomo completo;
\item Validação experimental sistemática no simulador CARLA;
\item \textit{Feedback} visual para assistência ao condutor.
\end{enumerate}

Esta abordagem integrada diferencia-se fundamentalmente dos trabalhos anteriores ao propor uma solução holística que abrange desde a percepção até a atuação, contribuindo para o avanço do conhecimento em sistemas de condução autônoma validados por simulação.

A revisão da literatura confirma a adequação metodológica das escolhas técnicas adotadas neste trabalho, incluindo a utilização do algoritmo YOLO, do simulador CARLA, e da arquitetura cliente-servidor para processamento distribuído. Adicionalmente, os resultados reportados na literatura estabelecem \textit{benchmarks} relevantes para validação dos resultados experimentais apresentados no Capítulo \ref{resultados}.

\chapter{Modelagem Conceitual para simulação de Carros Autônomos} \label{ModelagemConceitual}

Neste capítulo, formularemos a modelagem conceitual do artefato que será implementado no Capítulo \ref{Implementação}. A fundamentação teórica apresentada no Capítulo \ref{direcao_autonoma} oferece a base necessária para a concepção desta arquitetura. Dessa forma, tomamos como referência a Arquitetura da Tarefa de Condução \ref{ar_soft} para elaborar uma solução que atende aos objetivos delineados nos Objetivos \ref{objetivos}, validando, consequentemente, a Hipótese \ref{hipotese} proposta neste trabalho.
\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/ArquiteturadeSoftware.png}
\caption{Arquitetura do Software.}
\label{Arquitetura_soft_autor}
\end{figure}
A arquitetura desenvolvida, ilustrada na Figura \ref{Arquitetura_soft_autor}, é composta por múltiplas camadas que refletem os diferentes módulos necessários para a operação de um carro autônomo em um ambiente simulado. O sensor escolhido para a primeira camada é a câmera, devido à sua versatilidade e à riqueza de dados visuais, essenciais para tarefas de percepção ambiental, como elaboraremos na seção \ref{per_visual_carro}. Essa camada 1 será a responsável por detectar e classificar os objetos e o seu resultado permitirá o \textit{feedback} ao usuário. Baseado nesses resultados da Camada 1, a Camada 2 (Seção \ref{planejamento}) ditará os movimentos necessários para a Camada 3 exercer no simulador (Seção \ref{modelagem_veiculos}). Como descritas a seguir de maneira objetiva e com ilustrações dos módulos:
\begin{itemize}
\item \textbf{Camada 1 - Percepção Ambiental:} A primeira camada processa os dados provenientes da câmera do simulador. O módulo realiza a análise da cena para identificar objetos: placas de parada, veículos, etc. Este módulo utiliza técnicas de visão computacional, a detecção de objetos baseada no algoritmo YOLO, descrito na Subseção \ref{YOLO_metodo}. Além disso, a partir dos resultados dessa camada podemos assistir o condutor via \textit{feedbacks} em tempo real, conforme visto no fluxograma da Figura \ref{fluxo_percepcao}% essa camada disponibiliza os resultados% para dá feedback em tempo real 
 %para o feedback ao condutor possibilitando a assistência ao condutor em tempo real
, ampliando a segurança e a confiabilidade na direção. O modelo geral da Camada 1 para a percepção do ambiente pode ser visto na Figura \ref{percepcao_ambiental}.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/percepcao_ambiental2.png}
\caption{Arquitetura de Software da Percepção do Ambiente. Baseado em \citeonline{University_of_Toronto2018-fe}.}
\label{percepcao_ambiental}
\end{figure}

\item \textbf{Camada 2 - Planejamento de Movimento:} Baseado nas informações fornecidas pela camada de percepção, o módulo de planejamento de movimento gera perfil de velocidade, e calcula trajetórias eficientes para o veículo. Este módulo considera restrições dinâmicas, regras de trânsito e a previsão de movimentos de outros agentes na cena, descrito na seção \ref{planejamento}.  O modelo geral da camada 2 pode ser visto na Figura \ref{planejador_movimento}.
\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/planejador_movimento.png}
\caption{Arquitetura de Software do Planejador de Movimento. Baseado em \citeonline{University_of_Toronto2018-fe}.}
\label{planejador_movimento}
\end{figure}

\item \textbf{Camada 3 - Controlador e Atuação:} A terceira camada é responsável por traduzir as saídas da Camada 2 em comandos de controle de aceleração e direção, aplicadas ao simulador. Controladores são utilizados para garantir que o veículo siga a trajetória planejada com precisão, ajustando continuamente os comandos, como elaborado na Seção \ref{modelagem_veiculos}. O modelo geral da camada 3 pode ser visto na Figura \ref{controlador}.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/controlador.png}
\caption{Arquitetura de Software do Controlador do Veículo. Baseado em \citeonline{University_of_Toronto2018-fe}.}
\label{controlador}
\end{figure}
\end{itemize}

Em síntese, o fluxo de dados é iniciado pela captura de informações visuais na saída da câmera do simulador. Em seguida, esses dados percorrem as camadas descritas anteriormente neste Capítulo \ref{ModelagemConceitual}, resultando na atuação final no ambiente simulado. O fluxo também inclui o \textit{feedback} para assistência ao condutor a partir da camada de percepção, assegurando a atualização contínua das informações percebidas, conforme podemos identificar no fluxograma da Figura \ref{fluxo_percepcao}.


\begin{figure}[H]
\centering
\includegraphics[width=16cm]{Figures/image_process.drawio.png}
\caption{Fluxo da Execução da Solução.}
\label{fluxo_percepcao}
\end{figure}

O fluxograma da Figura \ref{fluxo_percepcao} apresenta de maneira detalhada o processo completo de percepção, \textit{feedback}, planejamento e controle, em etapas distribuídas entre as camadas da arquitetura.
Como podemos identificar na Figura \ref{fluxo_percepcao}, o processo é iniciado com o carregamento do modelo de detecção YOLO, responsável pela detecção e classificação de objetos na cena. Em seguida, a câmera é inicializada e instanciada na simulação, garantindo a captura contínua de imagens em tempo real. As imagens capturadas são processadas pelo modelo, que realiza inferências para identificar os objetos de interesse.
Após a inferência, os resultados são processados e exibidos visualmente, permitindo a validação e interpretação das informações detectadas. Se uma placa de pare for identificada, o sistema retorna os dados para o próximo módulo, possibilitando ajustes dinâmicos. Esse ajuste é permitido pela Camada 2, o planejamento de movimento é computado com base nos dados fornecidos para o módulo. Caso, por exemplo, a velocidade atual do veículo não corresponda ao requisito da placa de pare, uma resposta é feita pela Camada 2 para a mudança do perfil de velocidade e então o fluxo avança para a Camada 3, onde é realizado o ajuste da velocidade, enviando comandos ao simulador para adequação em tempo real.

Esse fluxo segue iterativamente enquanto a solução permanece em execução. Caso o processo seja encerrado, o sistema interrompe a captura de dados e finaliza as operações.

Enriquecidos por essas informações, as Seções \ref{modelagem_veiculos}, \ref{planejamento} e \ref{per_visual_carro} subsequentes desenvolverão como cada camada descritas neste Capítulo \ref{ModelagemConceitual} serão projetadas.

\section{Controle Veicular para Sistemas Autônomos} \label{modelagem_veiculos}

A implementação eficaz da arquitetura de condução autônoma apresentada na Seção \ref{ar_soft} requer fundamentação teórica sólida em modelagem e controle veicular. Conforme estabelecido na decomposição hierárquica da tarefa de condução (Seção \ref{componentes_da_tarefa_de_conducao}), o módulo de controle constitui a camada responsável pela execução precisa das trajetórias geradas pelo planejamento de movimento, traduzindo comandos de alto nível em sinais de atuação específicos para os sistemas mecânicos do veículo.

Esta seção desenvolve os fundamentos matemáticos necessários para a implementação do módulo de controle veicular, estruturando-se em três componentes hierárquicos que refletem a progressão natural do conhecimento teórico para a aplicação prática:

\begin{enumerate}
\item \textbf{Modelagem Cinemática} (Subseções \ref{modelagem_2D} e \ref{bicicleta}): estabelece os fundamentos geométricos do movimento veicular, descrevendo relações entre posições, velocidades e orientações sem considerar forças atuantes. Esta abordagem demonstra-se adequada para cenários de baixa velocidade onde acelerações são desprezíveis \cite{paden2016survey}, constituindo base essencial para o desenvolvimento de controladores geométricos;

\item \textbf{Modelagem Dinâmica} (Subseção \ref{dinamica_2D}): incorpora forças e momentos que influenciam o movimento veicular, proporcionando representação mais precisa do comportamento em condições operacionais variadas. Esta extensão torna-se fundamental para aplicações que envolvem altas velocidades ou condições de aderência limitada \cite{jacobson2020vehicle};

\item \textbf{Sistemas de Controle} (Subseções \ref{PID} e \ref{intro_controle_lateral}): desenvolve algoritmos de controle longitudinal e lateral que utilizam os modelos cinemáticos e dinâmicos para garantir seguimento preciso de trajetórias planejadas.
\end{enumerate}

A progressão metodológica adotada fundamenta-se na necessidade de compreender as restrições geométricas do movimento veicular antes de abordar complexidades dinâmicas, seguindo abordagem consolidada na literatura de robótica móvel \cite{lavalle2006planning}. Esta estrutura modular facilita a implementação da arquitetura de três camadas apresentada na Figura \ref{Arquitetura_soft_autor}, onde cada nível de modelagem suporta funcionalidades específicas do sistema de controle.

Os conceitos desenvolvidos nesta seção constituem fundamento direto para a implementação experimental apresentada no Capítulo \ref{Implementação}, onde os modelos teóricos são integrados ao simulador CARLA (Subseção \ref{subsubsec:simulador_carla}) para validação das estratégias de controle propostas. A articulação entre modelagem teórica e implementação prática representa contribuição essencial para o alcance dos objetivos específicos estabelecidos na Seção \ref{objetivos_esp}, particularmente no que se refere ao desenvolvimento de sistemas de controle veicular integrados com algoritmos de detecção de objetos.



\subsection{Modelagem Cinemática Bidimensional} \label{modelagem_2D}

A implementação eficaz dos sistemas de controle veicular propostos neste trabalho (Seção \ref{objetivos_esp}) fundamenta-se na compreensão rigorosa dos princípios que governam o movimento de veículos. Conforme estabelecido na arquitetura hierárquica da tarefa de condução (Seção \ref{componentes_da_tarefa_de_conducao}), o módulo de controle representa a interface crítica entre o planejamento de trajetórias e a atuação física do veículo no ambiente simulado.

A modelagem matemática do movimento veicular pode ser abordada através de duas metodologias fundamentais, cada uma apropriada para diferentes cenários operacionais e requisitos de precisão \cite{paden2016survey}:

\begin{enumerate}
\item \textbf{Modelagem Cinemática}: concentra-se exclusivamente nas relações geométricas entre posição, velocidade e orientação, negligenciando as forças e momentos atuantes. Esta abordagem demonstra-se adequada para cenários de baixa velocidade (< 5 m/s) onde as acelerações são desprezíveis e as restrições geométricas dominam o comportamento do sistema;

\item \textbf{Modelagem Dinâmica}: incorpora explicitamente todas as forças e momentos que influenciam o movimento veicular, proporcionando representação mais precisa em condições de alta velocidade, superfícies com baixa aderência ou manobras agressivas \cite{jacobson2020vehicle}.
\end{enumerate}

Para os objetivos específicos deste trabalho, que envolvem navegação autônoma em ambiente urbano simulado com velocidades moderadas (conforme especificado na Subseção \ref{subsubsec:simulador_carla}), a abordagem cinemática oferece o equilíbrio adequado entre simplicidade computacional e precisão representativa. Esta escolha metodológica alinha-se com as práticas estabelecidas na literatura de VA para aplicações de simulação e desenvolvimento de algoritmos de controle \cite{University_of_Toronto2018-fe} e \cite{lavalle2006planning}.

\subsubsection{Sistemas de Coordenadas e Transformações Geométricas} \label{trans}

A representação matemática precisa do movimento veicular requer o estabelecimento de sistemas de coordenadas consistentes e bem definidos. Em consonância com a arquitetura sensorial apresentada na Subseção \ref{sensor}, onde múltiplos sensores operam simultaneamente, torna-se fundamental compreender as transformações entre diferentes referenciais espaciais.

\begin{figure}[htb]
 %\label{teste}
 \centering
  \begin{minipage}{0.3\textwidth}
    \centering
    \includegraphics[scale=0.5]{Figures/coordinate_planet.png}
        %\caption{Robô com rodas e uma câmera omnidirecional \cite[p. ~9]{francis2016models}.}
        \legend{Glogal}
    %\label{two_robot}
  \end{minipage}
  \hfill
  \begin{minipage}{0.3\textwidth}
    \centering
    \includegraphics[scale=0.5]{Figures/coordinate_car.png}
      %\caption{Modelo de bicicleta \cite[p. ~13]{francis2016models}.}
      \legend{Corpo}
    %\label{bicycle}
  \end{minipage}
  \hfill
  \begin{minipage}{0.3\textwidth}
    \centering
    \includegraphics[scale=0.5]{Figures/coordinate_sensor.png}
      %\caption{Modelo de bicicleta \cite[p. ~13]{francis2016models}.}
      \legend{Sensor}
    %\label{bicycle}
  \end{minipage}
  \caption{Sistemas de coordenadas fundamentais para modelagem veicular: (a) referencial global (inercial), (b) referencial do corpo, (c) referencial do sensor \cite[p.~33]{jacobson2016vehicle}.}
\label{coordenadas}
\end{figure}

Três categorias principais de sistemas de coordenadas são empregadas na modelagem de VA, conforme ilustrado na Figura \ref{coordenadas}:

\begin{description}
\item[\textbf{Sistema Global (Inercial):}] estabelece referência fixa ligada à Terra, tipicamente representado em coordenadas \textit{East-North-Up} ou \textit{Earth-Centered Earth-Fixed}. Este sistema serve como base para localização absoluta e navegação global;

\item[\textbf{Sistema do Corpo:}] fixado à estrutura do veículo, geralmente posicionado no centro de gravidade ou eixo traseiro. Este sistema move-se e rotaciona com o veículo, facilitando a descrição das dinâmicas internas e comandos de controle;

\item[\textbf{Sistema do Sensor:}] associado individualmente a cada sensor embarcado (câmeras, LiDAR, etc.), definindo as coordenadas específicas para as medições de posicionamento sensoriais conforme apresentado na arquitetura da Figura \ref{figura-sensores}.
\end{description}

A necessidade de transformações entre estes referenciais torna-se evidente quando consideramos que mesmo um robô simples de duas rodas requer o gerenciamento de três sistemas de coordenadas, enquanto um VA típico pode envolver dezenas deles \cite{University_of_Toronto2018-fe}. No contexto deste trabalho, esta complexidade manifesta-se concretamente na integração entre os módulos de percepção e controle: as detecções de objetos obtidas pelo algoritmo YOLO (Seção \ref{YOLO_metodo}) fornecem coordenadas em \textit{pixels} no referencial da câmera, que devem ser transformadas para o referencial do veículo para permitir o cálculo de distâncias e posicionamento relativo necessários ao planejamento de trajetórias (Seção \ref{planejamento}). Simultaneamente, o sistema de controle lateral (Subseção \ref{intro_controle_lateral}) requer transformações entre o referencial global dos \textit{waypoints} (Subseção \ref{subsec:planejamento_de_missao}) planejados e o referencial local do veículo para gerar comandos de direção precisos, enquanto o módulo de verificação de colisões (implementado conforme apresentada na Subseção \ref{verificacao_colisoes}) necessita de transformações consistentes entre múltiplos referenciais para avaliar a proximidade de obstáculos detectados. Para manter representação consistente dos dados sensoriais destinados ao módulo de percepção (Subseção \ref{percepcao}), é imprescindível implementar transformações geométricas precisas entre os diferentes quadros de coordenadas, garantindo coerência espacial ao longo de todo o \textit{pipeline} de processamento desde a aquisição sensorial até a execução dos comandos de controle.

\subsubsection{Modelo Cinemático da Bicicleta} \label{bicicleta}

O modelo cinemático da bicicleta constitui uma aproximação fundamental amplamente adotada na literatura de VA para representar o comportamento de veículos com configuração Ackermann (rodas dianteiras direcionáveis) \cite{francis2016models}. Esta modelagem simplificada, embora não replique fidedignamente todos os aspectos de um veículo real, captura as características essenciais do movimento planar, proporcionando base sólida para desenvolvimento de algoritmos de controle que serão integrados ao ambiente de simulação CARLA.

O conceito central desta modelagem fundamenta-se no Centro Instantâneo de Rotação ou (ICR), que define o ponto geométrico ao redor do qual o veículo executa movimento circular instantâneo. A compreensão rigorosa deste conceito é fundamental para o desenvolvimento dos controladores laterais que serão implementados na Subseção \ref{intro_controle_lateral}, particularmente o algoritmo de perseguição pura \textit{pure pursuit} utilizado para seguimento de trajetórias.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/bicycle_model_car.png}
\caption{Representação do modelo cinemático da bicicleta no referencial inercial $F_I$ com identificação dos elementos geométricos fundamentais \cite{University_of_Toronto2018-fe}}
\label{FI}
\end{figure}

Conforme ilustrado na Figura \ref{FI}, o modelo opera sob as seguintes premissas fundamentais que definem seu domínio de validade:

\begin{enumerate}
\item \textbf{Movimento planar}: o veículo é restrito ao movimento bidimensional no plano horizontal, assumindo superfície plana sem inclinações significativas;
\item \textbf{Condição de não-deslizamento}: os pneus mantêm aderência perfeita com a superfície, impedindo deslizamento lateral ou longitudinal, válida para velocidades moderadas (< 15 m/s) e condições de alta aderência;
\item \textbf{Simplificação estrutural}: as duas rodas dianteiras são representadas por uma única roda equivalente posicionada no centro do eixo dianteiro, assim como as rodas traseiras no eixo traseiro.
\end{enumerate}

\textbf{Definição das Variáveis de Estado e Parâmetros}

Considerando o ponto de referência posicionado no centro do eixo traseiro para a formulação inicial, as variáveis de estado e parâmetros do sistema são definidas como:

\begin{conditions}
(x_r, y_r) & coordenadas do ponto de referência no eixo traseiro; \\
\theta & ângulo de orientação do veículo (ângulo de guinada); \\
\delta & ângulo de direção da roda dianteira; \\
v & velocidade linear do veículo; \\
L & distância entre eixos (wheelbase); \\
\omega & velocidade angular do veículo; \\
R & raio instantâneo de curvatura.
\end{conditions}

\textbf{Derivação das Equações Fundamentais}

A partir da geometria do ICR e das restrições cinemáticas impostas pela condição de não-deslizamento, estabelece-se a relação fundamental entre velocidade angular e raio de curvatura \cite{University_of_Toronto2018-fe}:

\begin{equation} \label{icr_basic}
\dot{\theta} = \omega = \frac{v}{R}
\end{equation}


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Figures/bicycle_icr.png}
\caption{Ponto de referência da roda traseira no modelo de bicicleta 2D \cite[Week 4 - Lesson 2: The Kinematic Bicycle Model. ~3min00s]{University_of_Toronto2018-fe}.}
\label{bicycle_icr}
\end{figure}

Aplicando a análise de triângulos semelhantes na configuração geométrica ilustrada na Figura \ref{bicycle_icr}, demonstra-se que a tangente do ângulo de direção relaciona-se diretamente com as dimensões características do veículo \cite{University_of_Toronto2018-fe}:

\begin{equation} \label{geometric_relation}
\tan \delta = \frac{L}{R}
\end{equation}

Combinando as Equações \ref{icr_basic} e \ref{geometric_relation}, obtém-se a relação cinemática fundamental que conecta velocidade angular, velocidade linear e ângulo de direção:

\begin{equation} \label{icr_relation}
\dot{\theta} = \frac{v \tan \delta}{L}
\end{equation}

\textbf{Modelo Cinemático Completo - Referencial do Eixo Traseiro}

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/read_axle_model.png}
\caption{Ponto de referência na roda traseira no modelo de bicicleta 2D \cite[Week 4 - Lesson 2: The Kinematic Bicycle Model. ~3min46s]{University_of_Toronto2018-fe}.}
\label{rear_axle}
\end{figure}

Considerando a configuração apresentada na Figura \ref{rear_axle}, os componentes da velocidade do ponto de referência nas direções $x$ e $y$ são expressos em função da velocidade linear $v$ e da orientação $\theta$ \cite{University_of_Toronto2018-fe}:

\begin{equation} \label{bicycle_rear_model}
\begin{aligned}
\dot{x}_r &= v \cos \theta \\
\dot{y}_r &= v \sin \theta \\
\dot{\theta} &= \frac{v \tan \delta}{L}
\end{aligned}
\end{equation}

Este sistema de Equações \ref{bicycle_rear_model} diferenciais define completamente a evolução temporal do estado do veículo para o referencial do eixo traseiro, constituindo a base para implementação dos algoritmos de controle lateral.

\textbf{Formulações Alternativas para Diferentes Referenciais}

Para atender diferentes requisitos de controle e aplicações específicas, o modelo pode ser reformulado considerando outros pontos de referência estratégicos \cite{University_of_Toronto2018-fe}:

\textbf{Referencial do Eixo Dianteiro:}

Quando o ponto de referência é posicionado no centro do eixo dianteiro, a velocidade $v$ aponta na direção definida pela soma dos ângulos $\theta$ e $\delta$, conforme as Equações \ref{bicycle_front_model}:

\begin{equation} \label{bicycle_front_model}
\begin{aligned}
\dot{x}_f &= v \cos(\theta + \delta) \\
\dot{y}_f &= v \sin(\theta + \delta) \\
\dot{\theta} &= \frac{v \sin \delta}{L}
\end{aligned}
\end{equation}

\textbf{Referencial do Centro de Gravidade:}

A formulação mais complexa considera o ponto de referência no centro de gravidade, introduzindo o conceito de ângulo de deriva lateral $\beta$, conforme as Equações \ref{bicycle_cg_model}:

\begin{equation} \label{bicycle_cg_model}
\begin{aligned}
\dot{x}_c &= v \cos(\theta + \beta) \\
\dot{y}_c &= v \sin(\theta + \beta) \\
\dot{\theta} &= \frac{v \cos \beta \tan \delta}{L}
\end{aligned}
\end{equation}

onde o ângulo de deriva lateral é calculado considerando a geometria do veículo, conforme a Equação \ref{slip_angle}:

\begin{equation} \label{slip_angle}
\beta = \arctan\left(\frac{l_r \tan \delta}{L}\right)
\end{equation}

sendo $l_r$ a distância do eixo traseiro ao centro de gravidade.

\textbf{Modelo Estendido com Dinâmica do Ângulo de Direção}

Reconhecendo que mudanças instantâneas no ângulo de direção são fisicamente irrealizáveis, o modelo pode ser estendido para incluir a dinâmica do sistema de direção, proporcionando representação mais realística do comportamento veicular, conforme as Equações \ref{extended_bicycle_model}:

\begin{equation} \label{extended_bicycle_model}
\begin{aligned}
\dot{x}_c &= v \cos(\theta + \beta) \\
\dot{y}_c &= v \sin(\theta + \beta) \\
\dot{\theta} &= \frac{v \cos \beta \tan \delta}{L} \\
\dot{\delta} &= \varphi
\end{aligned}
\end{equation}

onde $\varphi$ representa a taxa de variação do ângulo de direção, constituindo uma entrada de controle mais realística que considera as limitações físicas do sistema de direção veicular.

\textbf{Limitações e Domínio de Validade}

O modelo cinemático apresentado opera sob hipóteses simplificadoras que impõem limitações práticas importantes para sua aplicação:

\begin{enumerate}
\item \textbf{Hipótese de não-deslizamento}: válida apenas para condições de alta aderência entre pneus e superfície, velocidades moderadas (< 15 m/s) e acelerações limitadas, características típicas de navegação urbana;
\item \textbf{Desprezar efeitos dinâmicos}: apropriado para cenários onde forças inerciais são negligíveis comparadas às restrições geométricas, justificando sua aplicação no ambiente de simulação urbana do CARLA;
\item \textbf{Simplificação estrutural}: a representação por duas rodas equivalentes é adequada para análise de movimento planar, mas não captura efeitos de diferencial ou distribuição de cargas entre rodas.
\end{enumerate}

\textbf{Aplicação no Contexto do Trabalho}

O modelo cinemático da bicicleta estabelecido nesta subseção fornece a fundamentação matemática essencial para múltiplos aspectos do sistema de navegação autônoma desenvolvido:

\begin{enumerate}
\item \textbf{Desenvolvimento dos controladores laterais} (Subseção \ref{intro_controle_lateral}): o modelo do eixo traseiro (Equação \ref{bicycle_rear_model}) serve como base para implementação do controlador de perseguição pura, permitindo cálculo preciso dos comandos de direção necessários para seguimento de trajetórias;

\item \textbf{Geração e otimização de trajetórias} (Seção \ref{planejamento}): as formulações alternativas dos referenciais (Equações \ref{bicycle_front_model} e \ref{bicycle_cg_model}) são utilizadas na validação de viabilidade cinemática das trajetórias geradas pelo módulo de planejamento e permite predição da trajetória futura do veículo, essencial para avaliação de riscos de colisão com objetos enviados para o sistema;

\end{enumerate}

A escolha por esta abordagem cinemática justifica-se pela adequação aos cenários operacionais propostos (navegação urbana em velocidades moderadas), pela simplicidade computacional necessária para implementação em tempo real, e pela precisão suficiente para validação dos algoritmos de detecção e controle que constituem a contribuição principal deste trabalho.

\subsection{Modelagem Dinâmica Bidimensional} \label{dinamica_2D}

A modelagem dinâmica constitui uma extensão fundamental da abordagem cinemática apresentada nas Subseções \ref{modelagem_2D} e \ref{bicicleta}, incorporando explicitamente as forças e momentos que governam o movimento veicular. Esta metodologia torna-se imprescindível quando as hipóteses simplificadoras da modelagem cinemática, particularmente a condição de não-deslizamento, são violadas devido a condições operacionais específicas que incluem manobras em altas velocidades, superfícies com baixo coeficiente de atrito, ou acelerações bruscas \cite[p.~89]{jacobson2020vehicle}.

\subsubsection{Domínio de Aplicabilidade}

Para os objetivos específicos deste trabalho (Seção \ref{objetivos_esp}), que envolvem navegação urbana em velocidades moderadas no simulador CARLA, a abordagem cinemática demonstra-se adequada. Contudo, a compreensão dos fundamentos dinâmicos é essencial para validação dos limites operacionais dos controladores implementados e estabelecimento de fundamentos teóricos para o desenvolvimento dos controladores PID (Subseção \ref{PID}) e laterais (Subseção \ref{intro_controle_lateral}).

\subsubsection{Metodologia para Desenvolvimento de Modelos Dinâmicos}

O desenvolvimento sistemático de modelos dinâmicos segue uma metodologia estruturada em quatro etapas fundamentais, conforme ilustrado na Figura \ref{modelo_dinamico}:

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/modelo_dinamico.png}
\caption{Metodologia para desenvolvimento de modelos dinâmicos \cite{University_of_Toronto2018-fe}.}
\label{modelo_dinamico}
\end{figure}

\begin{enumerate}
\item \textbf{Definição de Sistemas de Coordenadas:} estabelecimento dos referenciais inercial e do corpo, conforme apresentado na Subseção \ref{trans};

\item \textbf{Decomposição em Elementos Concentrados:} identificação de componentes dinâmicos discretos (massas, molas, amortecedores) que representam as características distribuídas do sistema;

\item \textbf{Análise de Forças e Momentos:} construção de diagramas de corpo livre, identificando todas as forças externas e momentos atuantes;

\item \textbf{Aplicação das Leis de Newton:} formulação das equações diferenciais através da segunda lei de Newton para dinâmica translacional ($\sum \vec{F} = m\vec{a}$) e rotacional ($\sum \vec{M} = I\vec{\alpha}$).
\end{enumerate}

Usando os passos descritos anteriormente, podemos construir um modelo dinâmico para um carrinho de correr, visto na Figura \ref{carrinho}, cuja posição nos interessa. 

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/carrinho.png}
\caption{Modelagem Dinâmica \cite[Week 4 - Lesson 3: Dynamic Modeling in 2D. ~4min20s]{University_of_Toronto2018-fe}.}
\label{carrinho}
\end{figure}


Daremos partida definindo o sistema de coordenadas, apresentado na subseção \ref{trans}, para a posição do carrinho, indicado por $x$, como feito no passo a passo da modelagem dinâmica na Figura \ref{modelo_dinamico}. Em seguida, identificamos o corpo rígido, que, neste caso, é o carrinho de massa $M$. Posteriormente, elaboramos um diagrama de corpo livre e definimos todas as forças atuantes no carrinho. Neste caso específico, observamos três forças atuando no carrinho: $f_1$, que puxa o carrinho para a direita, e $f_2$ e $f_3$, que puxam o carrinho para a esquerda.
Finalmente, a lei de Newton é aplicada na direção $x$ para formar o modelo dinâmico. A equação dinâmica resultante que descreve o movimento do carrinho é apresentada a seguir \ref{newton_eq}: 
\begin{equation} \label{newton_eq}
\begin{aligned}
Ma = \sum F \\
M\ddot{x} = f_1 - f_2 - f_3 \\
\end{aligned}
\end{equation} 


Esse mesmo passo a passo de modelagem dinâmica podem ser aplicados para outros exemplos, como o de um amortecedor. Segundo o autor, \citeonline{University_of_Toronto2018-fe}, a modelagem ajuda os engenheiros a projetar e ajustar a suspensão do veículo para melhor conforto e dirigibilidade do veículo. Esse exemplo de modelagem, incluindo o de uma roda, pode ser encontrado a partir do autor \cite[Week 4 - Lesson 3: Dynamic Modeling in 2D. ~4min41s]{University_of_Toronto2018-fe}, e muitos outros exemplos a partir do autor \citeonline{jacobson2020vehicle}.

\subsubsection{Aplicação em Veículos Autônomos}

Esses modelos dinâmicos têm aplicação direta nos controladores implementados neste trabalho, por exemplo: (i) validação de trajetórias no módulo de planejamento (Seção \ref{planejamento}), (ii) sintonia de parâmetros dos controladores PID, e (iii) determinação de limites operacionais seguros no ambiente CARLA.

A complexidade dos modelos dinâmicos completos motiva uma abordagem de decomposição que separa os efeitos longitudinais e laterais. A dinâmica longitudinal (Subseções \ref{mod_longitudinal} e \ref{PID}) fundamenta os controladores de velocidade, enquanto a dinâmica lateral (Subseções \ref{mod_lateral} e \ref{intro_controle_lateral}) suporta os controladores de direção, estabelecendo as bases necessárias para implementação e validação experimental dos algoritmos propostos.

\subsubsection{Modelagem Longitudinal} \label{mod_longitudinal}

Em complemento à modelagem cinemática apresentada na subseção \ref{bicicleta}, esta seção desenvolve a modelagem dinâmica longitudinal, componente essencial para a implementação dos sistemas de controle autônomo abordados na subseção \ref{PID}. A análise longitudinal constitui parte fundamental da arquitetura hierárquica de controle veicular apresentada na Figura \ref{Arquitetura_soft_autor}, representando a base matemática necessária para o módulo de controle de aceleração e frenagem.

A modelagem longitudinal caracteriza-se pela investigação das forças que atuam paralelamente ao eixo principal de movimento do veículo, permitindo compreensão quantitativa dos fatores que influenciam aceleração, desaceleração e manutenção de velocidade constante. Esta abordagem fornece a fundamentação teórica necessária para o desenvolvimento dos controladores PID longitudinais que serão implementados na solução proposta.

Conforme estabelecido por \citeonline{University_of_Toronto2018-fe}, o modelo longitudinal considera um sistema de forças atuantes no veículo em movimento sobre uma superfície inclinada, como ilustrado na Figura \ref{longitudinal_motion}. Este modelo será posteriormente utilizado para implementação do controle de velocidade e resposta a sinais de trânsito, conforme os objetivos específicos \ref{objetivos_esp} deste trabalho.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/longitudinal_motion.png}
\caption{Diagrama de forças do modelo dinâmico longitudinal para veículo em superfície inclinada \cite[Week 4 - Lesson 4: Longitudinal Vehicle Modeling. ~1min43s]{University_of_Toronto2018-fe}.}
\label{longitudinal_motion}
\end{figure}

Na Figura \ref{longitudinal_motion}, identificam-se as principais forças que determinam a dinâmica longitudinal do veículo:

\begin{itemize}
\item $F_{xf}$ e $F_{xr}$: forças de tração/frenagem nos eixos dianteiro e traseiro, respectivamente;
\item $F_{aero}$: força de arrasto aerodinâmico, proporcional ao quadrado da velocidade;
\item $R_{xf}$ e $R_{xr}$: resistências ao rolamento nos eixos dianteiro e traseiro;
\item $mg\sin\alpha$: componente longitudinal da força gravitacional, onde $\alpha$ representa a inclinação da via.
\end{itemize}

Conforme demonstrado por \citeonline{University_of_Toronto2018-fe}, a aplicação da segunda lei de Newton a este sistema de forças resulta na equação diferencial que define a aceleração longitudinal do veículo, conforme Equação \ref{longitudinal_motion_eq}:

\begin{equation} \label{longitudinal_motion_eq}
    m\ddot{x} = F_{xf} + F_{xr} - F_{aero} - R_{xf} - R_{xr} - mg \sin \alpha
\end{equation}

\begin{conditions}
    m\ddot{x} & Produto da massa pela aceleração longitudinal (N); \\
    F_{xf} & Força de tração/frenagem no eixo dianteiro (N); \\
    F_{xr} & Força de tração/frenagem no eixo traseiro (N); \\
    F_{aero} & Força de arrasto aerodinâmico (N); \\
    R_{xf} & Resistência ao rolamento nos pneus dianteiros (N); \\
    R_{xr} & Resistência ao rolamento nos pneus traseiros (N); \\
    mg\sin{\alpha} & Componente longitudinal da força gravitacional (N).
\end{conditions}

Para aplicação prática no contexto do controlador PID que será apresentado em detalhes na Seção \ref{PID}, é possível simplificar a Equação \ref{longitudinal_motion_eq} agrupando termos similares. Define-se a força de tração total como $F_x = F_{xf} + F_{xr}$ e a resistência total ao rolamento como $R_x = R_{xf} + R_{xr}$. Adicionalmente, para inclinações moderadas, aplica-se a aproximação de pequenos ângulos, onde $\sin \alpha \approx \alpha$. Estas simplificações resultam no modelo dinâmico longitudinal apresentado na Equação \ref{longitudinal_motion_eq_simplificada}:

\begin{equation} \label{longitudinal_motion_eq_simplificada}
    m\ddot{x} = F_{x} - F_{aero} - R_{x} - mg\alpha
\end{equation}

\begin{conditions}
    m\ddot{x} & Termo inercial (N); \\
    F_{x} & Força total de tração ou propulsão (N); \\
    F_{aero} & Arrasto aerodinâmico (N); \\
    R_{x} & Resistência total ao rolamento (N); \\
    mg\alpha & Componente longitudinal da força gravitacional (N).
\end{conditions}

Na Equação \ref{longitudinal_motion_eq_simplificada}, a diferença entre a força de tração $F_x$ e as forças resistivas ($F_{\text{aero}}$, $R_x$ e $mg\alpha$) determina a aceleração longitudinal do veículo. Para fins de implementação do controlador descrito na seção \ref{PID}, as forças resistivas podem ser agrupadas em uma força resultante $F_{\text{load}}$, estabelecendo uma relação direta entre o comando de aceleração e a resposta dinâmica do veículo.

Este modelo fundamenta matematicamente o desenvolvimento do controlador PID longitudinal que será implementado no Capítulo \ref{Implementação}, fornecendo as bases para o controle preciso de velocidade necessário para a realização do objetivo específico de resposta comportamental, conforme estabelecido na seção \ref{objetivos_esp}.

\subsubsection{Modelagem Lateral} \label{mod_lateral}

Em complemento à modelagem longitudinal apresentada na Subseção \ref{mod_longitudinal}, esta subseção aborda os aspectos conceituais da dinâmica lateral veicular que fundamentam o controlador implementado neste trabalho. Enquanto a modelagem longitudinal foca no controle de velocidade, a modelagem lateral constitui a base teórica para o desenvolvimento do controlador de direção que mantém o veículo na trajetória desejada, conforme apresentaremos na Subseção \ref{pure_persuit}.

O modelo cinemático da bicicleta, introduzido na Subseção \ref{bicicleta}, é expandido para incorporar considerações sobre o comportamento lateral do veículo. Esta abordagem, fundamentada nos conceitos apresentados por \citeonline{University_of_Toronto2018-fe}, estabelece uma representação simplificada, mas eficiente das relações geométricas envolvidas no controle direcional do veículo.

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/modelo_car_to_bike.png}
\caption{Representação esquemática da simplificação de um veículo de quatro rodas para o modelo da bicicleta \cite[Week 4 - Lesson 5: Lateral Dynamics of Bicycle Model. ~0min48s]{University_of_Toronto2018-fe}.}
\label{modelo_car_to_bike}
\end{figure}

Para o desenvolvimento da modelagem lateral aplicada neste trabalho, adotam-se premissas que possibilitam uma implementação computacionalmente eficiente, adequada aos objetivos estabelecidos na Seção \ref{objetivos}:

\begin{enumerate}
    \item \textbf{Desacoplamento das dinâmicas}: assume-se que os controles longitudinal e lateral podem ser tratados separadamente, conforme implementado nos módulos de controle de velocidade e direção do sistema proposto.
    
    \item \textbf{Agregação das rodas por eixo}: as rodas esquerda e direita em cada eixo são representadas por uma única roda equivalente posicionada no centro do respectivo eixo, conforme ilustrado na Figura \ref{modelo_car_to_bike}. Esta simplificação, característica do modelo da bicicleta, reduz significativamente a complexidade matemática sem comprometer a eficácia do controle para as aplicações pretendidas.
    
    \item \textbf{Aproximação geométrica}: o controle lateral é implementado principalmente através de relações geométricas entre o veículo e a trajetória desejada, utilizando o algoritmo de perseguição pura (Pure Pursuit) que será detalhado na Seção \ref{pure_persuit}.
\end{enumerate}

Esta modelagem simplificada é particularmente adequada para implementações em tempo real, como a proposta neste trabalho, onde a eficiência computacional é crucial. O algoritmo de perseguição pura, baseado nesta modelagem lateral simplificada, determina o ângulo de direção necessário calculando a curvatura entre a posição atual do veículo e um ponto-alvo na trajetória desejada, a uma distância predefinida à frente do veículo (distância de look-ahead).

A relação fundamental que governa este controlador pode ser expressa, conforme Equação \ref{eq:pure_pursuit}:

\begin{equation} \label{eq:pure_pursuit}
\delta = \tan^{-1}\left(\frac{2L\sin\alpha}{l_d}\right)
\end{equation}

\begin{conditions}
    \delta & Ângulo de direção a ser aplicado (rad); \\
    L & Distância entre eixos do veículo (m); \\
    \alpha & Ângulo entre o eixo longitudinal do veículo e o vetor ao ponto-alvo (rad); \\
    l_d & Distância de look-ahead (m).
\end{conditions}

Esta abordagem, embora não incorpore explicitamente os efeitos dinâmicos completos como forças laterais nos pneus e derrapagem, demonstra excelente desempenho nas condições operacionais previstas para o sistema, conforme será evidenciado nos resultados experimentais apresentados no Capítulo \ref{resultados}.

É importante ressaltar que, para aplicações que envolvam manobras em alta velocidade, superfícies com baixo coeficiente de atrito ou acelerações laterais significativas, modelos dinâmicos mais complexos seriam necessários, conforme discutido por \citeonline{jacobson2020vehicle}. No entanto, para os objetivos estabelecidos na Seção \ref{objetivos}, a abordagem simplificada, apresentada aqui, estabelece um equilíbrio adequado entre precisão e eficiência computacional.

\subsection{Controle Longitudinal de Veículos}\label{PID}

O controle eficaz da dinâmica longitudinal constitui elemento essencial na implementação de VA, representando a interface crítica entre o planejamento de movimento, discutido na Seção \ref{planejamento}, e a execução das trajetórias planejadas. Esta subseção desenvolve os fundamentos teóricos dos sistemas de controle necessários para regular a velocidade veicular, complementando a modelagem longitudinal apresentada na Subseção \ref{mod_longitudinal} e estabelecendo as bases para a implementação experimental detalhada no Capítulo \ref{Implementação}.

\subsubsection{Sistemas de Controle em Malha Fechada} \label{subsubsec:malha_fechada}

A arquitetura de controle em malha fechada constitui o núcleo funcional dos controladores implementados neste trabalho, conforme ilustrado na Figura \ref{fluxo_percepcao}, onde aparece como componente essencial da camada de controle. Esta configuração, implementada nos módulos do controlador no arquivo \texttt{controller2d.py}, conforme veremos na Seção \ref{controladores_imple}, fundamenta-se no conceito de realimentação (\textit{feedback}), que permite ao sistema continuamente corrigir seu comportamento com base na diferença entre o estado desejado e o estado atual.

Na Figura \ref{fluxo_percepcao}, o sistema de malha fechada é representado pelo fluxo circular de informações: os dados sensoriais capturados do ambiente são processados pelo módulo de percepção, alimentando o planejador de trajetória que estabelece os estados de referência. O controlador, com base nestas referências e no estado atual do veículo, gera os comandos para os atuadores, que por sua vez modificam o estado veicular. Este novo estado é novamente captado pelos sensores, fechando o ciclo de realimentação. Esta estrutura cíclica é a essência do controle em malha fechada implementado, permitindo correções contínuas para garantir a convergência entre o estado desejado e o estado real do veículo.

Para o controle longitudinal implementado neste trabalho, o sistema monitora a velocidade atual do veículo $v_{atual}$ e a compara com a velocidade de referência $v_{ref}$, a qual é dinamicamente ajustada com base nas informações enviadas para o sistema, conforme detalhado na Subseção \ref{subsec:planejamento_de_missao}. O erro resultante $e(t) = v_{ref} - v_{atual}$ alimenta o controlador PID, que calcula os comandos apropriados de aceleração ou frenagem para minimizar esta diferença.

O princípio fundamental do sistema de controle em malha fechada implementado pode ser descrito em quatro etapas sequenciais:

\begin{enumerate}
    \item \textbf{Medição}: os sensores virtuais do simulador CARLA capturam o estado atual do veículo (posição, velocidade, orientação);
    
    \item \textbf{Comparação}: o sistema compara estes valores com os estados desejados, derivados do planejamento de trajetória e das restrições impostas pelas detecções do sistema de percepção;
    
    \item \textbf{Processamento}: o controlador processa o erro e calcula os sinais de controle necessários para minimizá-lo, considerando tanto a magnitude atual do erro quanto sua evolução temporal;
    
    \item \textbf{Atuação}: os comandos de aceleração, frenagem e direção são enviados aos atuadores virtuais do veículo simulado.
\end{enumerate}

Esta abordagem de controle em malha fechada proporciona robustez ao sistema implementado, permitindo que o veículo mantenha o comportamento desejado mesmo na presença de perturbações externas ou imprecisões no modelo do sistema. A adaptabilidade resultante deste modelo de controle é particularmente relevante para o cenário implementado neste trabalho, onde o veículo deve responder adequadamente aos obstáculos e sinalizações fornecidos para o sistema.

\subsubsection{Representação no Domínio de Laplace e Análise de Controladores} \label{subsubsec:dominio_laplace}

O controle longitudinal de VA enfrenta desafios particulares relacionados à dinâmica não-linear dos sistemas veiculares, às variações nas condições ambientais e às necessidades de precisão e robustez. Neste contexto, a transformada de Laplace emerge como ferramenta matemática fundamental, permitindo converter as equações diferenciais que regem o comportamento temporal do veículo em representações algébricas no domínio da frequência. Esta abordagem facilita consideravelmente a análise e o projeto de controladores, sendo particularmente valiosa para o estudo de controladores PID aplicados ao controle veicular, ao permitir \cite{University_of_Toronto2018-fe}:

\begin{enumerate}
    \item Analisar a estabilidade do sistema através da localização de polos e zeros;
    \item Prever a resposta do sistema a diferentes entradas sem resolver equações diferenciais;
    \item Simplificar a integração do controlador com o modelo do processo em malha fechada apresentado na Subseção \ref{subsubsec:malha_fechada};
    \item Facilitar o projeto e a sintonia do controlador para atingir o desempenho desejado.
\end{enumerate}

Na representação matemática de sistemas de controle, a função de transferência constitui uma expressão que relaciona as entradas e saídas no domínio de Laplace, conforme a Equação \ref{transf_eq}:

\begin{equation} \label{transf_eq}
Y(s) = G(s)U(s)
\end{equation}

\begin{conditions}
Y(s) & Saída do sistema no domínio de Laplace; \\
G(s) & Função de transferência; \\
U(s) & Entrada do sistema no domínio de Laplace. 
\end{conditions}

A variável complexa $s$ estabelece a transição entre os domínios do tempo e da frequência, conforme Equação \ref{complexe_va_eq}:

\begin{equation} \label{complexe_va_eq}
s = \sigma + j\omega
\end{equation}

\begin{conditions}
s & Variável de frequência complexa; \\
\sigma & Parte real (taxa de amortecimento); \\
j & Unidade imaginária; \\
\omega & Frequência angular. 
\end{conditions}

Na análise de funções de transferência, as raízes do numerador (zeros) e do denominador (polos) determinam características fundamentais da resposta dinâmica do sistema, conforme a Equação \ref{dominio_laplace_eq} \cite{University_of_Toronto2018-fe}:

\begin{equation} \label{dominio_laplace_eq}
Y(s) = G(s)U(s) = \frac{N(s)}{D(s)}U(s)
\end{equation}

\begin{conditions}
Y(s) & Resposta de saída no domínio de Laplace; \\
G(s) & Função de transferência; \\
U(s) & Sinal de entrada no domínio de Laplace; \\
N(s) & Numerador da função de transferência (zeros); \\
D(s) & Denominador da função de transferência (polos).
\end{conditions}

Esta representação matemática é fundamental para o projeto do controlador PID, ao permitir analisar como cada parâmetro do controlador afeta o comportamento do sistema em malha fechada, conforme apresentado na Subseção \ref{subsubsec:malha_fechada}. Entre as diversas estratégias de controle disponíveis para sistemas veiculares, além do controlador PID, destacam-se também os controladores do tipo \textit{lead-lag}, que operam com funções de transferência específicas para aprimorar características particulares da resposta dinâmica \cite{University_of_Toronto2018-fe}. A opção pelo controlador PID neste trabalho justifica-se pela sua combinação favorável de simplicidade matemática e eficácia prática, além da facilidade de implementação no ambiente de simulação CARLA utilizado.

\subsubsection{Estrutura Matemática do Controlador PID}

Conforme apresentado na Subseção \ref{subsubsec:dominio_laplace}, o controlador Proporcional-Integral-Derivativo (PID) destaca-se por sua eficácia, robustez e simplicidade de implementação \cite{University_of_Toronto2018-fe}. Este controlador combina três termos distintos, cada um respondendo a uma característica específica do sinal de erro, conforme expresso na Equação \ref{PID_ed}:

\begin{equation} \label{PID_ed}
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau)d\tau + K_d\frac{de(t)}{dt}
\end{equation}

\begin{conditions}
u(t) & Sinal de controle (comando de aceleração/frenagem); \\
K_p & Ganho proporcional; \\
e(t) & Erro de velocidade $(v_{ref} - v_{atual})$; \\
K_i & Ganho integral; \\
\int_{0}^{t} e(\tau)d\tau & Integral do erro (acumulação histórica); \\
K_d & Ganho derivativo; \\
\frac{de(t)}{dt} & Taxa de variação do erro (tendência futura).
\end{conditions}

Cada componente do controlador PID contribui distintamente para o desempenho do sistema:

\begin{itemize}
\item \textbf{Termo Proporcional:} produz uma resposta proporcional à magnitude atual do erro, proporcionando reação imediata aos desvios;
\item \textbf{Termo Integral:} acumula o erro ao longo do tempo, eliminando erros estacionários residuais e garantindo precisão em regime permanente;
\item \textbf{Termo Derivativo:} responde à taxa de variação do erro, proporcionando amortecimento e antecipando comportamentos futuros.
\end{itemize}

A aplicação da transformada de Laplace, apresentada na Subseção \ref{subsubsec:dominio_laplace}, ao controlador PID, definido pela Equação \ref{PID_ed} no domínio do tempo, produz uma representação matemática equivalente no domínio da frequência complexa. Esta transformação fundamenta-se nas propriedades da transformada de Laplace, onde a multiplicação por $s$ corresponde à operação de diferenciação no domínio temporal, enquanto a divisão por $s$ representa a integração. Assim, obtém-se a função de transferência expressa pela Equação \ref{laprace_pid_eq}:

\begin{equation} \label{laprace_pid_eq}
G_c(s) = K_p + \frac{K_i}{s} + K_ds = \frac{K_d s^2 + K_p s + K_i}{s}
\end{equation}

\begin{conditions}
G_c(s) & Função de transferência do controlador; \\
K_d s^2 & Termo derivativo na função de transferência; \\
K_p s & Termo proporcional na função de transferência; \\
K_i & Termo integral na função de transferência; \\
s & Variável de Laplace com polo na origem.
\end{conditions}

Esta representação evidencia importantes características estruturais do controlador PID: a presença de um polo na origem (proveniente do termo integral) e dois zeros que podem ser posicionados estrategicamente no plano complexo através da sintonia apropriada dos ganhos $K_p$, $K_i$ e $K_d$ \cite{University_of_Toronto2018-fe}. A análise desta função de transferência permite compreender como cada parâmetro influencia o comportamento dinâmico do sistema controlado, conforme veremos na Subseção \ref{subsubsec:parametrosPID}.

\subsubsection{Sintonia e Efeitos dos Parâmetros PID} \label{subsubsec:parametrosPID}

A eficácia de um controlador PID depende criticamente da seleção adequada dos parâmetros $K_p$, $K_i$ e $K_d$. A Tabela \ref{table:PID} sintetiza os efeitos de cada parâmetro sobre características fundamentais da resposta do sistema.

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Parâmetro} & \textbf{Tempo de} & \textbf{Sobres-} & \textbf{Tempo de} & \textbf{Erro de Estado} \\ 
\textbf{Aumentado} & \textbf{Subida} & \textbf{sinal} & \textbf{Acomodação} & \textbf{Estacionário} \\ 
\hline
$K_p$ & Diminui & Aumenta & Pequena alteração & Diminui \\ 
$K_i$ & Diminui & Aumenta & Aumenta & Elimina \\ 
$K_d$ & Pequena alteração & Diminui & Diminui & Pequena alteração \\
\hline
\end{tabular}
\caption{Efeitos dos parâmetros PID nas características da resposta do sistema \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~8min11s]{University_of_Toronto2018-fe}.}
\label{table:PID}
\end{table}

Conforme evidenciado na Tabela \ref{table:PID}, a sintonia dos parâmetros PID envolve compromissos entre características conflitantes. Por exemplo, o aumento de $K_p$ reduz o tempo de subida, mas aumenta o sobressinal, conforme veremos na prática na Subseção \ref{subsubsec:analise_PID}. A integração de todos os três termos, quando adequadamente sintonizados, permite alcançar um equilíbrio ótimo entre rapidez de resposta, estabilidade e precisão em regime permanente, características essenciais para o controle longitudinal de VA.

Para a determinação prática dos parâmetros do controlador, diversos métodos sistemáticos podem ser aplicados, destacando-se o método de Ziegler-Nichols, que oferece uma abordagem empírica baseada na resposta do sistema em malha fechada. Neste método, aumenta-se, inicialmente, o ganho proporcional até o sistema apresentar oscilações sustentadas (ganho crítico), e a partir deste valor e do período das oscilações, determinam-se os parâmetros $K_p$, $K_i$ e $K_d$ mediante relações predefinidas \cite{University_of_Toronto2018-fe}. Alternativamente, métodos baseados em modelos, como o critério da integral do erro (ISE, IAE, ITAE), podem ser empregados quando um modelo matemático preciso do sistema está disponível \cite{Vilanova2012}. Na implementação experimental deste trabalho (Capítulo \ref{Implementação}), adota-se uma abordagem híbrida, iniciando com valores baseados em heurísticas e refinando-os iterativamente com base no desempenho observado no ambiente simulado, seguindo as recomendações do trabalho \cite{University_of_Toronto2018-fe}.

Apesar da eficácia comprovada dos controladores PID, sua implementação prática em sistemas veiculares apresenta desafios importantes que devem ser considerados. Entre estes desafios destacam-se: a saturação dos atuadores (acelerador e freios têm limites físicos de operação); presença de atrasos nos sensores e atuadores; não-linearidades inerentes à dinâmica veicular (como atrito variável, forças aerodinâmicas dependentes do quadrado da velocidade); e perturbações ambientais (variações na inclinação da via, condições climáticas). Estas limitações podem comprometer o desempenho teórico do controlador PID, especialmente em situações extremas, exigindo adaptações para lidar com a saturação de atuadores ou ajuste dinâmico de parâmetros para diferentes condições operacionais \cite{University_of_Toronto2018-fe}.

\subsubsection{Implementação e Análise do Controlador PID} \label{subsubsec:analise_PID}

Para demonstrar os efeitos práticos de diferentes configurações de controle, \citeonline{University_of_Toronto2018-fe} apresenta um sistema massa-mola-amortecedor de segunda ordem como caso de estudo analógico, ilustrado na Figura \ref{Sistema Massa-Mola-Amortecedor}.

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/mass_spring_dumper_system.png}
\caption{Sistema massa-mola-amortecedor utilizado como modelo analógico para análise de controladores \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~9min00s]{University_of_Toronto2018-fe}.}
\label{Sistema Massa-Mola-Amortecedor}
\end{figure}

As Figuras \ref{controle_P}, \ref{controle_D}, \ref{controle_I} e \ref{controle_pid} apresentam as respostas ao degrau para diferentes configurações de controle aplicadas a este sistema, permitindo análise comparativa do desempenho.

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Figures/p_controle.png}
\caption{Resposta do controlador proporcional puro ($G_P(s) = K_p$), demonstrando tempo de subida rápido mas com sobressinal significativo e oscilação prolongada \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~12min13s]{University_of_Toronto2018-fe}.}
\label{controle_P}
\end{figure}

O controlador proporcional puro (Figura \ref{controle_P}) apresenta resposta inicial rápida, característica desejável para aceleração veicular, porém com sobressinal significativo e oscilações persistentes que comprometeriam o conforto dos passageiros em um VA.

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Figures/pd_controle.png}
\caption{Resposta do controlador proporcional-derivativo ($G_{PD}(s) = K_p + sK_d$), demonstrando melhor amortecimento das oscilações \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~12min13s]{University_of_Toronto2018-fe}.}
\label{controle_D}
\end{figure}

O controlador proporcional-derivativo (Figura \ref{controle_D}) reduz o sobressinal e as oscilações através do efeito amortecedor do termo derivativo, que antecipa as tendências do sistema, característica particularmente relevante para manutenção de distância segura entre veículos.

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Figures/pi_controle.png}
\caption{Resposta do controlador proporcional-integral ($G_{PI}(s) = K_p + \frac{K_i}{s}$), demonstrando eliminação do erro estacionário \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~12min13s]{University_of_Toronto2018-fe}.}
\label{controle_I}
\end{figure}

O controlador proporcional-integral (Figura \ref{controle_I}) elimina o erro estacionário residual, garantindo que a velocidade do veículo convirja precisamente para o valor de referência, mesmo na presença de perturbações como variações de inclinação da via ou alterações nas condições aerodinâmicas.

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{Figures/pid_controle.png}
\caption{Resposta do controlador PID completo, combinando os benefícios dos três termos para obter resposta rápida, sem sobressinal e com erro estacionário nulo \cite[Week 5 - Lesson 1: Proportional-Integral-Derivative (PID) Control. ~12min50s]{University_of_Toronto2018-fe}.}
\label{controle_pid}
\end{figure}

O controlador PID completo (Figura \ref{controle_pid}) integra as vantagens dos três componentes, resultando em resposta rápida, sem sobressinal e com erro estacionário nulo. Esta configuração apresenta características ideais para o controle longitudinal de VA, onde precisão, estabilidade e conforto são requisitos fundamentais. A capacidade de atingir rapidamente a velocidade desejada sem oscilações é essencial para a fluidez do tráfego em ambientes urbanos, enquanto a eliminação do erro estacionário garante precisão na manutenção da velocidade em trechos constantes, como rodovias. Ademais, a ausência de sobressinal contribui significativamente para o conforto dos passageiros e para a eficiência energética do veículo, reduzindo acelerações e desacelerações desnecessárias.

Embora o controlador PID represente uma solução robusta e eficaz para o controle longitudinal de VA, é importante reconhecer que abordagens mais avançadas são desenvolvidas para lidar com cenários complexos e requisitos mais exigentes. Entre estas técnicas destaca-se o Controle Preditivo baseado em Modelo ou (MPC), capaz de antecipar o comportamento futuro do sistema e otimizar as ações de controle considerando múltiplos objetivos e restrições; controladores adaptativos que ajustam seus parâmetros em tempo real conforme as condições operacionais; e abordagens baseadas em aprendizado de máquina, como controladores baseados em redes neurais \cite{University_of_Toronto2018-fe}. Estas técnicas, embora promissoras, apresentam maior complexidade computacional e de implementação, justificando a escolha do controlador PID como solução inicial adequada aos objetivos deste trabalho, estabelecendo uma base sólida para futuros desenvolvimentos.

A análise destes resultados demonstra a superioridade do controlador PID completo para aplicações de controle longitudinal veicular, justificando sua adoção na arquitetura proposta neste trabalho (Figura \ref{fluxo_percepcao}). Os princípios teóricos estabelecidos nesta subseção fundamentam a implementação experimental detalhada no Capítulo \ref{Implementação}, onde o controlador PID longitudinal será integrado ao simulador CARLA. Especificamente, na Seção \ref{controladores_imple}, serão descritos os algoritmos que traduzem estes conceitos em código, incluindo os mecanismos de cálculo do erro, aplicação dos ganhos PID e geração dos comandos de aceleração. %Os valores específicos dos parâmetros $K_p$, $K_i$ e $K_d$ serão determinados mediante processo iterativo de ajuste, buscando otimizar o desempenho do veículo conforme métricas relacionadas aos objetivos estabelecidos na Seção \ref{objetivos}.

\subsection{Controle Lateral de Veículos} \label{intro_controle_lateral}

Em complemento à modelagem longitudinal apresentada na Subseção \ref{mod_longitudinal} e ao controle longitudinal explorado na Seção \ref{PID}, esta subseção aborda os aspectos teóricos do controle lateral, componente fundamental para garantir o seguimento preciso de trajetórias em VA. A integração destes dois sistemas de controle, longitudinal e lateral, constitui a base da arquitetura hierárquica estabelecida no Capítulo \ref{ModelagemConceitual} para implementação de sistemas autônomos de condução.

O controle lateral representa um elemento crítico na arquitetura de três camadas proposta na Figura \ref{Arquitetura_soft_autor}, sendo responsável por traduzir as trajetórias definidas pelo módulo de planejamento em comandos de direção que garantam o alinhamento do veículo ao caminho desejado. Conforme estabelecido por \citeonline{zheng2023simultaneous}, o objetivo fundamental deste sistema é selecionar o ângulo de direção necessário para minimizar os desvios laterais e angulares em relação à trajetória de referência, mantendo o veículo no percurso planejado mesmo diante de perturbações externas.

De acordo com \citeonline{University_of_Toronto2018-fe}, o projeto de um controlador lateral eficaz deve considerar três requisitos essenciais:

\begin{enumerate}
    \item Quantificação precisa dos erros entre a posição atual do veículo e as coordenadas desejadas da trajetória de referência;
    \item Desenvolvimento de estratégias de controle que minimizem estes erros, respeitando os limites físicos de ângulo de direção do veículo;
    \item Incorporação das restrições dinâmicas do veículo e das características desejáveis da trajetória, como aceleração lateral máxima e minimização de solavancos.
\end{enumerate}

Em todos os casos, o sistema de controle deve operar nas capacidades físicas do veículo, considerando especialmente as forças disponíveis nos pneus para execução das manobras corretivas, evitando assim instabilidades dinâmicas durante o seguimento da trajetória.

\subsubsection*{Representações de Trajetórias para Controle Lateral} \label{subsubsec:representacao-trajetorias}

A implementação de sistemas de controle lateral requer representações matemáticas adequadas da trajetória de referência. \citeonline{University_of_Toronto2018-fe} identifica três abordagens principais para esta representação, cada uma com características específicas que impactam diretamente a complexidade e o desempenho do sistema de controle:

\begin{enumerate}
    \item \textbf{Segmentos de linha reta:} constitui a abordagem mais simples, definida por uma sequência de vértices conectados linearmente, conforme ilustrado na Figura \ref{straight_path}. Esta representação oferece vantagens significativas em termos de compacidade e facilidade de construção, particularmente em ambientes que privilegiam movimentos retilíneos, como malhas urbanas regulares. Entretanto, as descontinuidades de direção nas junções entre segmentos introduzem desafios consideráveis para o seguimento preciso da trajetória.
    
    \begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figures/straight_path.png}
    \caption{Representação de trajetória por segmentos de linha reta, evidenciando as descontinuidades nas junções que desafiam o controle lateral \cite[Week 6 - Lesson 1: Introduction to Lateral Vehicle Control.  ~2min52s]{University_of_Toronto2018-fe}}
    \label{straight_path}
    \end{figure}

    \item \textbf{Pontos de referência (\textit{waypoints}):} representa uma evolução da abordagem anterior, estabelecendo pontos discretos ao longo do percurso desejado, geralmente distribuídos em intervalos regulares de distância ou tempo, como demonstrado na Figura \ref{waypoints_path}. Segundo \citeonline{University_of_Toronto2018-fe}, esta representação apresenta vantagens práticas significativas pela facilidade de obtenção a partir de dados de GPS ou estimativas de estado de operações anteriores, além de permitir ajustes nas posições relativas dos pontos para satisfazer restrições de curvatura. Esta abordagem será adotada na implementação apresentada na Subseção \ref{subsec:planejamento_de_missao}, onde os \textit{waypoints} constituirão a base da trajetória a ser seguida pelo VA.
    
    \begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figures/waypoints_path.png}
    \caption{Representação de trajetória por pontos de referência (\textit{waypoints}), utilizada na implementação apresentada na Seção \ref{subsec:planejamento_de_missao} \cite[Week 6 - Lesson 1: Introduction to Lateral Vehicle Control.  ~3min00s]{University_of_Toronto2018-fe}.}
    \label{waypoints_path}
    \end{figure}

    \item \textbf{Curvas parametrizadas:} constitui a abordagem mais sofisticada, utilizando sequências de funções matemáticas contínuas para representar o caminho, conforme ilustrado na Figura \ref{parametrizado_path}. Estas curvas podem ser derivadas de um conjunto predefinido de primitivas de movimento ou obtidas por métodos de otimização durante o planejamento, como discutido na Subseção \ref{otimizacao_caminho}. A principal vantagem desta representação reside na continuidade matemática, que proporciona derivadas suaves em todos os pontos da trajetória, facilitando o cálculo consistente de erros e taxas de variação essenciais para controle lateral preciso.
    
    \begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{Figures/parametrizado_path.png}
    \caption{Representação de trajetória por curvas parametrizadas, evidenciando a continuidade matemática que facilita o controle lateral preciso \cite[Week 6 - Lesson 1: Introduction to Lateral Vehicle Control.  ~3min30s]{University_of_Toronto2018-fe}.}
    \label{parametrizado_path}
    \end{figure}
\end{enumerate}

Independentemente da representação adotada, o objetivo fundamental do controlador lateral permanece constante: eliminar os desvios do veículo em relação à trajetória desejada e alinhar sua orientação com a direção do caminho, garantindo seguimento preciso e estável.

\subsubsection*{Métricas de Erro para Controle Lateral}

Para implementação eficaz do controle lateral, é necessário quantificar matematicamente o desvio do veículo em relação à trajetória desejada. Utilizando o modelo cinemático da bicicleta apresentado na Subseção \ref{bicicleta} como base teórica, e considerando um segmento de reta como trajetória de referência (Figura \ref{caminho_ref_bike_model}), podem-se definir duas métricas de erro fundamentais: o erro de rumo e o erro de trajetória cruzada.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{Figures/caminho_ref_bike_model.png}
\caption{Trajetória de referência retilínea utilizada para derivação das métricas de erro de controle lateral \cite[Week 6 - Lesson 1: Introduction to Lateral Vehicle Control.  ~6min23s]{University_of_Toronto2018-fe}.}
\label{caminho_ref_bike_model}
\end{figure}

O \textbf{erro de rumo} representa a discrepância angular entre a orientação atual do veículo e a direção da trajetória de referência, constituindo uma medida essencial do alinhamento direcional. A evolução temporal deste erro pode ser calculada a partir das equações cinemáticas do modelo da bicicleta \cite[p.~18]{snider2009automatic}, resultando na expressão da Equação \ref{eq:taxa_erro_rumo}:

\begin{equation}\label{eq:taxa_erro_rumo}
    \dot{\psi}_\text{des}(t) - \dot{\psi}(t) = \frac{v_f(t) \sin \delta(t)}{L}
\end{equation}

\begin{conditions}
     \dot{\psi}_\text{des}(t) & Taxa de variação da orientação desejada no tempo \(t\); \\
    \dot{\psi}(t) & Taxa de variação da orientação atual no tempo \(t\); \\
    v_f(t) & Velocidade longitudinal no tempo \(t\); \\
    \delta(t) & Ângulo de direção no tempo \(t\); \\
    L & Distância entre eixos do veículo.
\end{conditions}

Para trajetórias retilíneas, a taxa de variação da orientação desejada é nula ($\dot{\psi}_\text{des}(t) = 0$), simplificando a expressão para a Equação \ref{eq:taxa_erro_rumo_reta}:

\begin{equation}\label{eq:taxa_erro_rumo_reta}
   \dot{\psi}(t) = \frac{-v_f(t) \sin \delta(t)}{L}
\end{equation}

O \textbf{erro de trajetória cruzada} (\textit{crosstrack error}), ilustrado na Figura \ref{caminho_ref_bike_model_crosstrack}, representa a distância perpendicular entre o veículo e a trajetória desejada, constituindo a medida primária do desvio posicional. A taxa de variação deste erro pode ser derivada calculando a componente lateral da velocidade de avanço:

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{Figures/caminho_ref_bike_model_crosstrack.png}
\caption{Representação do erro de trajetória cruzada, medida fundamental para avaliação do desempenho do controle lateral \cite[Week 6 - Lesson 1: Introduction to Lateral Vehicle Control.  ~8min31s]{University_of_Toronto2018-fe}.}
\label{caminho_ref_bike_model_crosstrack}
\end{figure}

\begin{equation}\label{eq:erro_trajetoria_cruzada}
\dot{e}(t) = v_f(t) \sin(\psi(t) - \delta(t))
\end{equation}

\begin{conditions}
\dot{e}(t) & Taxa de variação do erro de trajetória cruzada no tempo \(t\); \\
v_f(t) & Velocidade longitudinal no tempo \(t\); \\
\psi(t) & Ângulo de orientação do veículo no tempo \(t\); \\
\delta(t) & Ângulo de direção no tempo \(t\); \\
\sin(\psi(t) - \delta(t)) & Seno da diferença entre orientação do veículo e ângulo de direção.
\end{conditions}

A Equação \ref{eq:erro_trajetoria_cruzada} evidencia uma relação diretamente proporcional entre a velocidade do veículo e a taxa de variação do erro de trajetória cruzada, implicando que velocidades mais elevadas requerem ângulos de direção proporcionalmente menores para efetuar correções de magnitude similar, um princípio fundamental que será aplicado no controlador de perseguição pura apresentado na Subseção \ref{pure_persuit}.

As formulações matemáticas aqui apresentadas constituem a base teórica para o desenvolvimento do controlador lateral que será implementado no sistema proposto, conectando diretamente os conceitos de modelagem cinemática (Subseção \ref{bicicleta}) com as estratégias de controle necessárias para execução precisa das trajetórias geradas pelo módulo de planejamento (Seção \ref{planejamento}). Na Subseção \ref{pure_persuit}, a seguir, desenvolveremos especificamente o controlador de perseguição pura, selecionado para implementação prática neste trabalho pela sua eficácia e simplicidade computacional.

\subsubsection{Controle Lateral Geométrico - Controlador de Perseguição Pura} \label{pure_persuit}

Em complemento à fundamentação teórica apresentada na Subseção \ref{intro_controle_lateral}, esta subseção desenvolve especificamente o controlador de perseguição pura (\textit{Pure Pursuit}), algoritmo selecionado para implementação do controle lateral no sistema proposto neste trabalho. Esta escolha metodológica fundamenta-se nas características de robustez e simplicidade computacional deste controlador, aspectos essenciais para sua integração na arquitetura hierárquica apresentada na Figura \ref{Arquitetura_soft_autor}.

O controlador de perseguição pura pertence à categoria dos controladores geométricos, que fundamentam suas decisões de controle exclusivamente nas relações geométricas entre o veículo e a trajetória de referência, conforme estabelecido por \citeonline{University_of_Toronto2018-fe}. Esta abordagem distingue-se de métodos baseados em dinâmica por desconsiderar forças inerciais e aerodinâmicas, baseando-se na hipótese de não-deslizamento apresentada na modelagem cinemática da Subseção \ref{bicicleta}. Tal característica torna este controlador particularmente adequado para aplicações em ambientes urbanos com velocidades moderadas, como o cenário de simulação implementado neste trabalho.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{Figures/look-ahead.png}
\caption{Princípio de funcionamento do controlador de perseguição pura: seleção de um ponto-alvo (vermelho) a uma distância predeterminada ao longo da trajetória de referência \cite[Week 6 - Lesson 2: Geometric Lateral Control - Pure Pursuit. ~2min27s]{University_of_Toronto2018-fe}.}
\label{look-ahead}
\end{figure}

O princípio fundamental do controlador de perseguição pura, ilustrado na Figura \ref{look-ahead}, consiste na identificação de um ponto-alvo situado na trajetória de referência a uma distância predeterminada à frente do veículo, denominada distância de antecipação (\textit{lookahead distance}). O controlador então calcula o ângulo de direção necessário para o veículo executar um arco circular que intercepte este ponto-alvo. Como destacado por \citeonline[p.~9]{snider2009automatic}, à medida que o veículo se aproxima da trajetória seguindo este arco, o ponto-alvo avança continuamente, resultando em uma redução gradual do ângulo de direção e conduzindo o veículo suavemente para a trajetória desejada.

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{Figures/pure_pursuit_img.png}
\caption{Configuração geométrica do controlador de perseguição pura: distância de antecipação $l_d$ e ângulo de busca $\alpha$ \cite[Week 6 - Lesson 2: Geometric Lateral Control - Pure Pursuit. ~3min15s]{University_of_Toronto2018-fe}.}
\label{pure_pursuit_img}
\end{figure}

A implementação deste controlador utiliza o centro do eixo traseiro como ponto de referência no veículo, conforme ilustrado na Figura \ref{pure_pursuit_img}. O segmento de reta que conecta este ponto ao ponto-alvo na trajetória define a distância de antecipação $l_d$, enquanto o ângulo formado entre a orientação longitudinal do veículo e esta linha é denominado ângulo de busca $\alpha$. Estes dois parâmetros constituem os elementos fundamentais para o cálculo do ângulo de direção.

A formulação matemática do controlador baseia-se na análise do centro instantâneo de rotação ou (ICR), conceito fundamental da cinemática veicular apresentado na Subseção \ref{bicicleta}. Como demonstrado na Figura \ref{pure_pursuit_formulation}, o ponto-alvo, o centro do eixo traseiro e o ICR formam um triângulo com propriedades geométricas específicas que podem ser exploradas para derivar a lei de controle.

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{Figures/pure_pursuit_formulation.png}
\caption{Relação geométrica entre o centro instantâneo de rotação (ICR), a distância de antecipação $l_d$ e o raio de curvatura $R$ \cite[Week 6 - Lesson 2: Geometric Lateral Control - Pure Pursuit. ~3min52s]{University_of_Toronto2018-fe}.}
\label{pure_pursuit_formulation}
\end{figure}

Para desenvolver a lei de controle, é necessário determinar o arco circular que conecta o ponto de referência do veículo ao ponto-alvo na trajetória. Este arco corresponde a um segmento do círculo definido pelo ICR, abrangendo um ângulo central de $2\alpha$. Aplicando a lei dos senos ao triângulo formado, obtém-se a relação expressa na Equação \ref{eq:low_of_sines} \cite[p.~9]{snider2009automatic}:

\begin{equation}\label{eq:low_of_sines}
\frac{l_d}{\sin 2\alpha} = \frac{R}{\sin \left(\frac{\pi}{2} - \alpha \right)}
\end{equation}

Utilizando as identidades trigonométricas $\sin 2\alpha = 2\sin\alpha\cos\alpha$ e $\sin(\frac{\pi}{2} - \alpha) = \cos\alpha$, a Equação \ref{eq:low_of_sines} pode ser simplificada para Equação \ref{eq:low_of_sines_simplificada}:

\begin{equation}\label{eq:low_of_sines_simplificada}
\frac{l_d}{2 \sin \alpha \cos \alpha} = \frac{R}{\cos\alpha}
\end{equation}

Simplificando adicionalmente, obtém-se a expressão compacta da Equação \ref{eq:low_of_sines_simplificada_compactada}:

\begin{equation}\label{eq:low_of_sines_simplificada_compactada}
\frac{l_d}{\sin \alpha} = 2R
\end{equation}

A curvatura $\kappa$, definida como o inverso do raio de curvatura $R$, pode então ser expressa conforme a Equação \ref{eq:curvatura}:

\begin{equation}\label{eq:curvatura}
\kappa = \frac{1}{R} = \frac{2\sin\alpha}{l_d}
\end{equation}

Esta formulação relaciona diretamente a curvatura necessária com o ângulo de busca $\alpha$ e a distância de antecipação $l_d$, constituindo a base para o cálculo do ângulo de direção. Conforme estabelecido no modelo cinemático da bicicleta (Subseção \ref{bicicleta}), o ângulo de direção $\delta$ que produz uma determinada curvatura é dado pela Equação \ref{eq:angulo_direcao_eq} \cite[p.~10]{snider2009automatic}:

\begin{equation} \label{eq:angulo_direcao_eq}
\delta = \tan^{-1}(\kappa L)
\end{equation}

onde $L$ representa a distância entre eixos do veículo.

Combinando as Equações \ref{eq:curvatura} e \ref{eq:angulo_direcao_eq}, deriva-se a expressão da Equação \ref{eq:angulo_di_para_curvatura} para o ângulo de direção em função dos parâmetros geométricos:

\begin{equation}\label{eq:angulo_di_para_curvatura}
\delta = \tan^{-1} \left( \frac{2L \sin \alpha}{l_d} \right)
\end{equation}

Para aprofundar a compreensão do comportamento dinâmico deste controlador, é útil analisar sua relação com o erro de trajetória cruzada, apresentado na Subseção \ref{intro_controle_lateral}. Conforme ilustrado na Figura \ref{cross_track_error-e}, o erro de trajetória cruzada $e$ pode ser relacionado com o ângulo de busca $\alpha$ através da relação da Equação \ref{eq:cross_track-e}:

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/cross_track_error-e.png}
\caption{Relação geométrica entre o erro de trajetória cruzada $e$ e o ângulo de busca $\alpha$ \cite[Week 6 - Lesson 2: Geometric Lateral Control - Pure Pursuit. ~3min52s]{University_of_Toronto2018-fe}.}
\label{cross_track_error-e}
\end{figure}

\begin{equation}\label{eq:cross_track-e}
\sin \alpha = \frac{e}{l_d}
\end{equation}

Então, substituindo a Equação \ref{eq:cross_track-e} na Equação \ref{eq:curvatura}, obtém-se:

\begin{equation}\label{eq:k_combined_cross_track-e}
\kappa = \frac{2}{l_d^2} e
\end{equation}

Esta formulação, destacada por \citeonline{University_of_Toronto2018-fe}, revela uma propriedade fundamental do controlador de perseguição pura: a curvatura gerada é diretamente proporcional ao erro de trajetória cruzada, caracterizando este controlador como essencialmente proporcional. Quanto maior o desvio lateral em relação à trajetória desejada, maior será a curvatura aplicada para corrigi-lo, resultando em comportamento similar ao controle proporcional discutido na Seção \ref{PID}.

Uma consideração importante para aplicações práticas é a adaptação da distância de antecipação $l_d$ em função da velocidade do veículo. Em velocidades mais elevadas, uma distância de antecipação maior é desejável para produzir comandos de direção mais suaves e evitar oscilações. Uma abordagem comum consiste em definir $l_d$ como uma função linear da velocidade \cite{University_of_Toronto2018-fe}, conforme a Equação \ref{eq:antecipacao}:

\begin{equation} \label{eq:antecipacao}
l_d = K_{dd}v_f
\end{equation}

onde $K_{dd}$ é um parâmetro de ajuste e $v_f$ é a velocidade longitudinal do veículo.

Incorporando esta adaptação na Equação \ref{eq:angulo_di_para_curvatura}, obtém-se a forma final do controlador de perseguição pura, conforme visto na Equação \ref{eq:final_eq_pure_pursuit} \cite[p.~10]{snider2009automatic}:

\begin{equation}\label{eq:final_eq_pure_pursuit}
\delta = \tan^{-1} \left( \frac{2L \sin \alpha}{K_{dd} v_f} \right)
\end{equation}

\begin{conditions}
\delta & Ângulo de direção calculado (rad); \\
L & Distância entre eixos do veículo (m); \\
\alpha & Ângulo de busca entre a orientação do veículo e a linha até o ponto-alvo (rad); \\
K_{dd} & Ganho de adaptação da distância de antecipação (adimensional); \\
v_f & Velocidade longitudinal do veículo (m/s).
\end{conditions}

Esta formulação adaptativa do controlador resulta em comportamento particularmente desejável para aplicações em VA: em velocidades reduzidas, como em manobras de estacionamento ou navegação em espaços confinados, a distância de antecipação diminui, proporcionando resposta mais ágil às correções de trajetória; em velocidades elevadas, como em vias expressas, a distância de antecipação aumenta, produzindo comandos de direção mais suaves que priorizam o conforto dos passageiros e a estabilidade do veículo \cite{University_of_Toronto2018-fe}.

O controlador de perseguição pura será implementado no módulo de controle lateral apresentado no Capítulo \ref{Implementação}, integrando-se aos demais componentes da arquitetura de três camadas proposta na Figura \ref{Arquitetura_soft_autor}. Sua simplicidade computacional, comportamento intuitivo e robustez a incertezas no modelo do veículo tornam-no particularmente adequado para a aplicação em ambientes simulados como o CARLA, descrito na Subseção \ref{subsubsec:simulador_carla}.

Para otimização do desempenho em cenários específicos, ajustes adicionais podem ser necessários, como a limitação da taxa de variação do ângulo de direção para prevenir comandos abruptos, ou a adaptação dinâmica do ganho $K_{dd}$ em função de condições ambientais. Tais refinamentos são discutidos em profundidade por \citeonline[p.~11]{snider2009automatic}.

\section{Planejamento de Movimento para Veículos Autônomos} \label{planejamento}

O planejamento de movimento constitui elemento essencial na arquitetura de VA, conforme estabelecido anteriormente na Seção \ref{ar_soft}, sendo responsável pela geração de trajetórias seguras e eficientes que orientam o veículo de sua posição atual até o destino pretendido. Este componente representa a segunda camada da arquitetura hierárquica apresentada na Figura \ref{Arquitetura_soft_autor}, intermediando a percepção ambiental (Seção \ref{per_visual_carro}) e o controle veicular (Seção \ref{modelagem_veiculos}).

A complexidade do planejamento de movimento deriva de sua natureza multidimensional, englobando diversos desafios computacionais interconectados: a determinação de rotas globais em escala macro, a navegação em ambientes dinâmicos com agentes imprevisíveis, e a conversão de decisões estratégicas em comandos de controle executáveis pelo sistema de atuação do veículo. Esta multiplicidade de tarefas, somada às restrições de tempo real inerentes à condução autônoma, demanda uma abordagem metodológica estruturada e hierárquica, que decomponha o problema global em níveis distintos de abstração e escala temporal \cite[Module 2 - Lesson 1: Driving Missions, Scenarios, and Behaviour]{University_of_Toronto2018-mp}.

A implementação do módulo de planejamento proposta neste trabalho alinha-se com a arquitetura conceitual desenvolvida no Capítulo \ref{ModelagemConceitual}, respondendo diretamente aos requisitos estabelecidos nos objetivos específicos (Seção \ref{objetivos_esp}), particularmente no que se refere à capacidade de resposta comportamental a sinalizações de trânsito.

\subsection{Arquitetura Hierárquica de Planejamento} \label{subsec:arquitetura_hierarquica}

O paradigma hierárquico de planejamento fundamenta-se na decomposição do problema complexo de navegação autônoma em subproblemas gerenciáveis, organizados em diferentes níveis de abstração temporal e espacial. Conforme destacado por \citeonline{paden2016survey}, esta estruturação modular apresenta múltiplas vantagens metodológicas: facilita o desenvolvimento independente de módulos específicos, aprimora a manutenção e testabilidade do sistema, e potencializa a robustez do sistema integrado. Adicionalmente, a separação de preocupações entre diferentes escalas temporais viabiliza a execução em tempo real do processo decisório, aspecto crítico para sistemas autônomos operando em ambientes dinâmicos \cite[Module 2 - Lesson 1: Driving Missions, Scenarios, and Behaviour]{University_of_Toronto2018-mp}.

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{Figures/Hierarchical_Planning.pdf}
\caption{Arquitetura hierárquica de planejamento de movimento para VA, evidenciando a decomposição em três níveis de abstração com escalas temporais e espaciais distintas \cite[Module 2 - Lesson 1: Driving Missions, Scenarios, and Behaviour. ~10min55s]{University_of_Toronto2018-mp}.}
\label{Hierarchical_Planning}
\end{figure}

Conforme ilustrado na Figura \ref{Hierarchical_Planning}, a hierarquia de planejamento estrutura-se em três níveis principais, cada um operando em horizontes temporais e granularidades espaciais específicas \cite{lavalle2006planning, wei2014behavioral}:

\begin{enumerate}
    \item \textbf{Planejamento de Missão (Global):} representa o nível estratégico mais elevado da hierarquia, responsável pela definição da rota macroscópica que conecta a posição atual do veículo ao destino. Este módulo opera com representações abstratas do ambiente, como grafos rodoviários e informações de tráfego em larga escala, empregando algoritmos de otimização de caminhos como Dijkstra ou A* para determinar sequências ótimas de segmentos viários. Conforme destacado na Subseção \ref{subsubsec:representacao_grafo}, a função objetivo deste nível de planejamento tipicamente contempla critérios como distância total, tempo estimado de viagem ou eficiência energética, abstraindo detalhes operacionais como obstáculos dinâmicos ou manobras específicas. O horizonte temporal deste nível abrange toda a viagem, podendo estender-se por minutos ou horas;
    
    \item \textbf{Planejamento Comportamental:} constitui o nível tático intermediário, responsável pela seleção de manobras e comportamentos específicos necessários para executar a rota global com segurança e consoante as regulamentações de trânsito. Este módulo, detalhado na Subseção \ref{subsec:planejamento_comportamental}, integra o contexto local do veículo, incluindo obstáculos estáticos e dinâmicos, elementos regulatórios (como semáforos e placas de trânsito) e interações com outros agentes. Utilizando predominantemente, em nosso caso, máquinas de estados finitos ou (FSM), como demonstrado na Subseção \ref{subsubsec:FSM}, o planejador comportamental traduz a rota abstrata em sequências de manobras de alto nível, como manutenção de faixa, mudanças de faixa, desaceleração para parada, ou execução de conversões. O horizonte temporal típico deste nível varia de segundos a dezenas de segundos;
    
    \item \textbf{Planejamento Local:} representa o nível operacional mais concreto da hierarquia, responsável pela tradução das decisões comportamentais em trajetórias precisas e fisicamente executáveis pelo sistema de controle. Operando em horizontes temporais reduzidos (frações de segundo a poucos segundos), este módulo, discutido em profundidade na Subseção \ref{subsec:planejamento_local}, gera trajetórias que simultaneamente satisfazem as restrições cinemáticas e dinâmicas do veículo, conforme modeladas na Seção \ref{modelagem_veiculos}, e evitam colisões com obstáculos fornecidos para o sistema. O planejador local subdivide-se funcionalmente em dois componentes complementares: geração de caminhos espaciais, implementada por meio de técnicas como espirais paramétricas (Subseção \ref{otimizacao_caminho}), e perfis de velocidade temporais (Subseção \ref{subsubsec:geracao_de_perfil_de_velocidade}), posteriormente integrados em trajetórias espaço-temporais completas.
\end{enumerate}

A comunicação eficiente entre estes três níveis hierárquicos é crucial para a funcionalidade integrada do sistema de planejamento. Conforme implementado em nossa arquitetura (Figura \ref{fluxo_percepcao}), cada nível estabelece diretrizes e restrições para o nível subsequente, enquanto recebe \textit{feedback} sobre a viabilidade e progresso da execução, possibilitando adaptações dinâmicas conforme necessário. Esta estrutura bidirecional de comunicação contribui significativamente para a robustez do sistema, permitindo que decisões de alto nível sejam revisitadas quando circunstâncias locais impedirem sua execução conforme originalmente planejado \cite{paden2016survey}.

Esta arquitetura hierárquica alinha-se diretamente com o segundo objetivo específico estabelecido na Seção \ref{objetivos_esp}, particularmente no que se refere à implementação de um sistema de resposta comportamental a sinalizações de trânsito. Conforme será detalhado nas subseções seguintes, o módulo de planejamento comportamental implementará uma máquina de estados finitos capaz de interpretar detecções de placas de trânsito fornecidas para o sistema, como aconteceria pelo módulo de percepção (Seção \ref{percepcao}), e modificar o comportamento do veículo de acordo, demonstrando a integração sistêmica entre os diferentes componentes da arquitetura proposta.

\subsection{Planejamento de Missão} \label{subsec:planejamento_de_missao}

O planejamento de missão representa o nível mais alto na hierarquia de planejamento de movimento para VA, conforme apresentado na Figura \ref{Hierarchical_Planning}. Este componente estratégico é responsável pela determinação da rota que conecta a posição atual do veículo ao destino pretendido, operando em escala espacial de quilômetros e horizontes temporais de minutos a horas \cite{paden2016survey}. Em contraste com os níveis inferiores da hierarquia, que lidam com obstáculos dinâmicos, restrições cinemáticas e regras de trânsito locais (conforme será explorado nas Subseções \ref{subsec:planejamento_comportamental} e \ref{subsec:planejamento_local}), o planejamento de missão foca em aspectos macroscópicos como limites de velocidade, extensões de vias, condições de tráfego e fechamentos de rotas \cite{University_of_Toronto2018-mp}.

A função principal deste módulo consiste em fornecer uma sequência ordenada de \textit{waypoints} que conduzem o veículo desde sua localização inicial até o destino, conforme visto na Subseção \ref{subsubsec:representacao-trajetorias}, otimizando critérios específicos como distância total, tempo de viagem ou eficiência energética, alinhando-se com os requisitos estabelecidos na arquitetura hierárquica apresentada na Seção \ref{ar_soft} \cite{lavalle2006planning}. Esta abstração deliberada das complexidades associadas às manobras específicas e aos obstáculos dinâmicos permite uma decomposição eficiente do problema global de navegação, delegando preocupações operacionais aos níveis subsequentes do planejamento hierárquico.

\subsubsection{Representação do Ambiente como Sequência de Waypoints} \label{subsubsec:representacao_grafo}

Para implementar o planejamento de missão em nosso sistema, adotaremos uma abordagem pragmática baseada em \textit{waypoints} predefinidos, explorando a natureza estruturada e controlada do ambiente de simulação CARLA. Embora conceitualmente a rede viária possa ser modelada como um grafo direcionado ponderado $G = (V, E)$ \cite{lavalle2006planning}, onde \textit{waypoints} representariam vértices e suas conexões representariam arestas, nossa implementação utiliza uma estrutura de dados mais simplificada: uma sequência ordenada de pontos que define implicitamente um caminho unidirecional a ser seguido.

Esta abordagem elimina a necessidade de algoritmos complexos de busca em grafos como Dijkstra ou A* \cite{nilsson1996artificial}, substituindo-os por operações diretas de consulta e indexação sobre a sequência predefinida. Esta escolha está alinhada com o escopo e objetivos específicos deste trabalho, que foca na integração dos sistemas de percepção e controle, mais do que na navegação autônoma em ambientes desconhecidos.

O arquivo \texttt{waypoints.txt} constitui o elemento central desta representação, contendo coordenadas tridimensionais $(x, y, v)$ onde $x$ e $y$ representam posições no plano cartesiano e $v$ específica a velocidade desejada em cada ponto. Esta estrutura permite não somente definir a trajetória espacial do veículo, mas também seu perfil de velocidade ao longo do percurso. O formato deste arquivo é exemplificado no Trecho de Código \ref{lst:waypoints-estrutura}:

\begin{lstlisting}[language=Python, caption=Estrutura do arquivo de \textit{waypoints} com coordenadas e velocidades associadas., label=lst:waypoints-estrutura]
317.74, 129.49, 8.333
314.73, 129.49, 8.333
311.63, 129.49, 8.333
...
\end{lstlisting}

O algoritmo fundamental que opera sobre esta estrutura é a função \texttt{get\_closest\_index()}, que determina o \textit{waypoint} mais próximo à posição atual do veículo por meio de uma busca linear baseada na distância euclidiana. Este algoritmo, detalhado no Pseudocódigo \ref{lst:closest_waypoint_algorithm}, representa a interface primária entre o estado atual do veículo e o caminho global predefinido:

\begin{lstlisting}[
  caption={Pseudocódigo para determinação do \textit{waypoint} mais próximo.},
  label={lst:closest_waypoint_algorithm},
  mathescape=true,
  frame=single,
  basicstyle=\small\ttfamily
]
Algoritmo: Determinação do waypoint mais próximo à posição atual

Entrada: waypoints (sequência ordenada de coordenadas), ego_state (posição atual do veículo)
Saída: closest_index (índice do waypoint mais próximo), closest_distance (distância)

1. Inicializar closest_distance $\leftarrow \infty$
2. Inicializar closest_index $\leftarrow 0$
3. Para cada i de 0 até |waypoints| - 1:
   3.1. Calcular distance $\leftarrow \sqrt{(ego\_state.x - waypoints[i].x)^2 + (ego\_state.y - waypoints[i].y)^2}$
   3.2. Se distance < closest_distance:
        3.2.1. Atualizar closest_distance $\leftarrow$ distance
        3.2.2. Atualizar closest_index $\leftarrow$ i
4. Retornar closest_index, closest_distance
\end{lstlisting}

Complementando esta função, o sistema implementa um mecanismo de antecipação que identifica um \textit{waypoint} objetivo situado a uma distância predefinida (\textit{lookahead distance}) à frente na sequência. Este método é conceitualmente similar à técnica empregada no controlador de perseguição pura (\textit{pure pursuit}) descrito na Subseção \ref{pure_persuit}, e permite antecipar curvas e variações de velocidade, adaptando o comportamento do veículo proativamente.

A abordagem baseada em \textit{waypoints} predefinidos oferece vantagens significativas para nossa implementação \cite{University_of_Toronto2018-mp}:

\begin{itemize}
    \item \textbf{Simplicidade computacional}: elimina a complexidade algorítmica associada à busca de caminhos em grafos arbitrários;
    \item \textbf{Determinismo}: garante comportamento previsível e reprodutível, facilitando validação e análise;
    \item \textbf{Eficiência em tempo real}: operações de busca linear em uma sequência ordenada apresentam custo computacional modesto, adequado para execução em ciclos de controle de alta frequência;
    \item \textbf{Integração direta}: permite foco nos aspectos de percepção e controle, centrais aos objetivos deste trabalho.
\end{itemize}

Desta forma, embora nossa implementação não utilize algoritmos sofisticados de busca em grafos, ela mantém a essência conceitual do planejamento de missão: fornecer uma sequência de pontos de referência que orientam o veículo do ponto inicial ao destino. Esta sequência estabelece o contexto global para as decisões táticas e operacionais implementadas pelos níveis inferiores da hierarquia de planejamento, particularmente o planejador comportamental (Subseção \ref{subsec:planejamento_comportamental}) e o planejador local (Subseção \ref{subsec:planejamento_local}).

\subsection{Planejamento Comportamental} \label{subsec:planejamento_comportamental}

O planejamento comportamental ocupa posição intermediária na hierarquia de planejamento apresentada na Figura \ref{Hierarchical_Planning}, atuando como elemento de articulação entre o planejamento de missão (Subseção \ref{subsec:planejamento_de_missao}) e o planejamento local (Subseção \ref{subsec:planejamento_local}). Este módulo cumpre função essencial na arquitetura de três camadas proposta na Figura \ref{Arquitetura_soft_autor}, sendo responsável pela conversão da rota global abstrata em uma sequência de manobras táticas executáveis, considerando simultaneamente o contexto dinâmico do ambiente, a legislação de trânsito e as interações com outros agentes \cite{University_of_Toronto2018-mp}.

A complexidade do planejamento comportamental reside na necessidade de tomada de decisões de alto nível que orientam a navegação do veículo em ambientes estruturados, respondendo a questões fundamentais: quando parar em sinalizações de trânsito, como responder a veículos mais lentos, quando ceder passagem em interseções ou como integrar-se a fluxos de tráfego convergentes. Este nível decisório caracteriza-se por incorporar regras e normativas que garantem comportamento veicular conforme a legislação de trânsito, elemento crítico para a operação segura de VA em ambientes urbanos \cite{wei2014behavioral, paden2016survey}.

A implementação do planejador comportamental neste trabalho alinha-se diretamente ao objetivo específico estabelecido na Seção \ref{objetivos_esp}, particularmente no desenvolvimento de um "sistema de resposta comportamental a sinalizações de trânsito". Conforme será demonstrado nesta subseção, o sistema proposto utiliza informações fornecidas para adaptar dinamicamente o comportamento do veículo em resposta às condições ambientais informadas.

\subsubsection{Máquinas de Estados Finitos como Paradigma de Modelagem Comportamental} \label{subsubsec:FSM}

Dentre as diversas abordagens para modelagem comportamental em sistemas de condução autônoma, as Máquinas de Estados Finitos (FSM, do inglês \textit{Finite State Machines}) destacam-se pela clareza conceitual, eficiência computacional e interpretabilidade intrínseca \cite{wei2014behavioral}. Esta metodologia de modelagem fundamenta-se na teoria de autômatos, representando comportamentos complexos como um conjunto discreto de estados bem definidos e regras explícitas de transição entre estes estados \cite{lavalle2006planning}.

Formalmente, uma Máquina de Estados Finitos pode ser definida como uma 5-tupla $(Q, \Sigma, \delta, q_0, F)$ onde:

\begin{itemize}
    \item $Q$ representa o conjunto finito de estados do sistema;
    \item $\Sigma$ denota o alfabeto de entrada, compreendendo eventos ou condições ambientais;
    \item $\delta: Q \times \Sigma \rightarrow Q$ define a função de transição entre estados;
    \item $q_0 \in Q$ estabelece o estado inicial;
    \item $F \subseteq Q$ identifica o conjunto (possivelmente vazio) de estados finais.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/FSM.png}
\caption{Representação esquemática de uma Máquina de Estados Finitos para planejamento comportamental em VA, ilustrando estados comportamentais (nós) e condições de transição (arestas) \cite[Module 2 - Lesson 4: Hierarchical Motion Planning. ~7min54s]{University_of_Toronto2018-mp}.}
\label{FSM}
\end{figure}

Conforme ilustrado na Figura \ref{FSM}, no contexto específico de VA, os estados da máquina representam padrões comportamentais distintos, como navegação em faixa, desaceleração para parada, permanência em estado estacionário ou execução de manobras específicas. A transição entre estes estados ocorre em resposta a eventos específicos detectados pelo sistema, como identificação de sinalizações de trânsito, detecção de obstáculos ou conclusão de manobras em andamento \cite{University_of_Toronto2018-mp}.

As vantagens desta abordagem para o planejamento comportamental incluem sua natureza determinística, que facilita a verificação formal e certificação de segurança; sua estrutura intuitiva, que permite modelagem direta de regras de trânsito explícitas; e sua eficiência computacional, fundamental para aplicações em tempo real como sistemas de condução autônoma \cite{wei2014behavioral}.

\subsubsection{Arquitetura da Máquina de Estados para Resposta a Sinalizações de Trânsito}

Em consonância com o objetivo específico de implementar um sistema de resposta comportamental a sinalizações de trânsito (Seção \ref{objetivos_esp}), o planejador comportamental proposto neste trabalho implementa uma Máquina de Estados Finitos com três estados fundamentais, definidos como constantes enumeradas no sistema:

\begin{enumerate}
    \item \textbf{FOLLOW\_LANE} (Seguir Faixa): estado operacional padrão onde o veículo navega ao longo da trajetória especificada pelos \textit{waypoints} gerados pelo planejador de missão (Subseção \ref{subsec:planejamento_de_missao}), mantendo-se nos limites da faixa designada e procurando atingir a velocidade de referência estabelecida para cada segmento. Este estado representa o comportamento nominal do sistema na ausência de restrições operacionais específicas;
    
    \item \textbf{DECELERATE\_TO\_STOP} (Desacelerar para Parar): estado transitório ativado quando o sistema identifica sinalizações de parada obrigatória ou quando o módulo de verificação de colisões (Subseção \ref{verificacao_colisoes}) detecta obstáculos na trajetória planejada. Neste estado, o planejador modifica o perfil de velocidade (Subseção \ref{subsubsec:geracao_de_perfil_de_velocidade}) para estabelecer uma desaceleração controlada, com velocidade-alvo igual a zero no ponto de parada;
    
    \item \textbf{STAY\_STOPPED} (Permanecer Parado): estado estacionário mantido após a completa imobilização do veículo, garantindo conformidade com requisitos regulatórios como paradas obrigatórias em sinalizações específicas. A permanência neste estado é controlada por um contador interno (\texttt{\_stop\_count}) que deve atingir um limiar predeterminado (\texttt{STOP\_COUNTS = 10}) antes que o sistema possa retornar ao estado \texttt{FOLLOW\_LANE}, implementando assim o tempo mínimo de parada exigido pela legislação de trânsito.
\end{enumerate}

A dinâmica de transição entre estes estados será governada por uma função de transição, \texttt{transition\_state()}, que avaliará três categorias principais de condições:

\begin{enumerate}
    \item \textbf{Condições Cinemáticas}: parâmetros relacionados ao estado dinâmico do veículo, incluindo sua velocidade atual, posição e orientação. Por exemplo, a transição de \texttt{DECELERATE\_TO\_STOP} para \texttt{STAY\_STOPPED} ocorre quando a velocidade instantânea do veículo cai abaixo de um limiar mínimo predefinido (\texttt{STOP\_THRESHOLD = 0.02 m/s}), indicando imobilização efetiva;
    
    \item \textbf{Condições Ambientais}: informações sobre o contexto operacional enviadas para o sistema, incluindo detecção de sinalizações de trânsito, obstáculos e veículos adjacentes. A transição de \texttt{FOLLOW\_LANE} para \texttt{DECELERATE\_TO\_STOP}, por exemplo, é desencadeada quando o sistema detecta a interseção da trajetória planejada com uma cerca virtual associada a sinalização de parada;
    
    \item \textbf{Condições Temporais}: restrições relacionadas à duração de permanência em estados específicos, implementadas por contadores internos. A transição de \texttt{STAY\_STOPPED} para \texttt{FOLLOW\_LANE} ocorre somente após o contador \texttt{\_stop\_count} atingir o valor \texttt{STOP\_COUNTS}, garantindo o tempo mínimo de parada.
\end{enumerate}

Esta estrutura da Máquina de Estados Finitos representa uma solução computacionalmente eficiente para implementação do comportamento de resposta a sinalizações de trânsito, conforme especificado nos objetivos do trabalho (Seção \ref{objetivos_esp}). A simplicidade conceitual desta abordagem facilita tanto a implementação quanto a verificação de conformidade com requisitos de segurança, aspectos críticos em sistemas autônomos de condução.

\subsubsection{Cercas Virtuais para Sinalização de Tráfego} \label{subsubsec:cercas_virtuais}

A operacionalização da resposta comportamental a sinalizações de trânsito requer um mecanismo eficiente para representação espacial das restrições impostas por estas sinalizações. Neste trabalho, adotamos o conceito de cercas virtuais (\textit{virtual fences}), que constituem representações geométricas das restrições operacionais associadas a elementos específicos do ambiente de tráfego \cite{wei2014behavioral}.

Para implementação deste conceito, utilizamos uma abordagem baseada em conhecimento prévio do ambiente, onde as posições exatas dos elementos de sinalização são fornecidas estaticamente por arquivos de configuração. Especificamente, as informações sobre a localização de placas de parada são disponibilizadas em um arquivo \texttt{stop\_sign\_params.txt}, como exemplificado no Trecho de Código \ref{lst:stop_sign_params}:

\begin{lstlisting}[language=Python, caption=Exemplo de arquivo de parâmetros de placa de parada., label=lst:stop_sign_params]
X(m), Y(m), Z(m), YAW(deg)
100.70, 127.00, 38.10, -90
\end{lstlisting}

Esta abordagem desacopla o processo de detecção de sinalizações do processo de planejamento comportamental, permitindo que o sistema de percepção visual (Seção \ref{per_visual_carro}) focalize em funções complementares de monitoramento e verificação, enquanto o planejamento comportamental opera com dados determinísticos para garantir robustez e previsibilidade.

As cercas virtuais são implementadas como segmentos de linha perpendiculares à direção longitudinal da via, posicionados precisamente nos pontos especificados no arquivo de configuração. Esta representação geométrica simplificada facilita a verificação eficiente de interseções entre a trajetória planejada do veículo e os pontos de parada obrigatória, desencadeando transições apropriadas na Máquina de Estados Finitos descrita na Subseção \ref{subsubsec:FSM}.

O algoritmo de verificação de interseção implementa uma abordagem baseada em projeção geométrica, calculando distâncias perpendiculares entre a trajetória prevista e os segmentos de linha que representam cercas virtuais. Esta operação é executada a cada ciclo de planejamento, utilizando a posição atual do veículo e os \textit{waypoints} de referência para determinar se alguma cerca virtual está sendo cruzada. Quando tal interseção é detectada, o sistema inicia a transição para o estado \texttt{DECELERATE\_TO\_STOP}, conforme detalhado na Subseção \ref{subsubsec:FSM}.

Similarmente, as informações sobre obstáculos estáticos, como veículos estacionados, são fornecidas via um arquivo \texttt{parked\_vehicle\_params.txt}, contendo dados de posição, orientação e dimensões, como ilustrado no Trecho de Código \ref{lst:parked_vehicle_params}:

\begin{lstlisting}[language=Python, caption=Exemplo de arquivo de parâmetros de veículo estacionado., label=lst:parked_vehicle_params]
X(m), Y(m), Z(m), YAW(deg), BOX_X_RADIUS(m), BOX_Y_RADIUS(m), BOX_Z_RADIUS(m)
280.10, 128.30, 38.10, 180.0, 2.49658310, 0.97084373, 0.78984779
\end{lstlisting}

Esta abordagem determinística para representação do ambiente oferece vantagens significativas no contexto experimental deste trabalho:

\begin{itemize}
    \item \textbf{Reprodutibilidade}: permite execução de experimentos em condições idênticas, facilitando análises comparativas;
    \item \textbf{Controle experimental}: elimina variáveis relacionadas a erros de detecção, focalizando a avaliação no desempenho dos algoritmos de planejamento;
    \item \textbf{Robustez}: garante comportamentos previsíveis e verificáveis, fundamentais para validação de sistemas críticos de segurança.
\end{itemize}

É importante notar que, embora o sistema de percepção visual baseado em YOLO (Seção \ref{per_visual_carro}) não seja utilizado diretamente para o planejamento comportamental, ele desempenha papel complementar importante, dando \textit{feedback} visual ao condutor e dados para validação do sistema. Esta separação entre percepção e planejamento reflete uma arquitetura de redundância comum em sistemas críticos de segurança, onde múltiplas fontes de informação são utilizadas para aumentar a confiabilidade global do sistema.

Em cenários de implementação real, a integração dinâmica entre percepção visual e planejamento comportamental seria necessária, traduzindo detecções de sinalizações em cercas virtuais em tempo real. Contudo, para terceiro Objetivo Específico \ref{objetivos_esp} deste trabalho, focados na validação da arquitetura hierárquica de planejamento e na resposta comportamental a sinalizações, a abordagem baseada em conhecimento prévio do ambiente proporciona um ambiente experimental controlado e reprodutível.

\subsubsection{Determinação de Estados Objetivos para Planejamento Local}

A principal saída do planejador comportamental para os níveis subsequentes da hierarquia de planejamento é a especificação de estados objetivos (\textit{goal states}) que orientam o planejamento local detalhado (Subseção \ref{subsec:planejamento_local}). Estes estados objetivos constituem representações compactas do comportamento desejado para o veículo em um horizonte de tempo limitado, combinando aspectos espaciais (posição e orientação) e dinâmicos (velocidade e aceleração) \cite{University_of_Toronto2018-mp}.

O processo de determinação destes estados objetivos integra informações de múltiplas fontes:

\begin{enumerate}
    \item \textbf{Trajetória Global}: utilizando o método \texttt{get\_closest\_index()} apresentado na Subseção \ref{subsec:planejamento_de_missao}, o sistema identifica o \textit{waypoint} mais próximo na rota global, estabelecendo a referência espacial básica;
    
    \item \textbf{Horizonte de Antecipação}: a partir do \textit{waypoint} mais próximo, o sistema seleciona um ponto-objetivo a uma distância de antecipação (\textit{lookahead distance}) adaptativa, calculada em função da velocidade atual do veículo. Esta abordagem implementa um horizonte de planejamento dinâmico que se expande com o aumento da velocidade, garantindo tempo adequado para manobras em todas as condições operacionais;
    
    \item \textbf{Verificações de Segurança}: antes de confirmar o estado objetivo, o sistema verifica a presença de cercas virtuais ou obstáculos no intervalo espacial entre a posição atual e o ponto-objetivo selecionado. Quando restrições são identificadas, o estado comportamental é atualizado conforme as regras de transição da Máquina de Estados Finitos;
    
    \item \textbf{Ajuste de Velocidade}: com base no estado comportamental atual, o sistema define a velocidade desejada associada ao estado objetivo. Em estado \texttt{FOLLOW\_LANE}, esta velocidade corresponde àquela especificada no \textit{waypoint} objetivo; em estado \texttt{DECELERATE\_TO\_STOP}, uma desaceleração controlada é calculada para atingir velocidade zero no ponto de parada; em estado \texttt{STAY\_STOPPED}, a velocidade é mantida em zero.
\end{enumerate}

Os estados objetivos determinados pelo planejador comportamental são então transmitidos ao planejador local (Subseção \ref{subsec:planejamento_local}), que utiliza técnicas de otimização de trajetórias baseadas em espirais paramétricas (Subseção \ref{otimizacao_caminho}) para gerar caminhos detalhados e perfis de velocidade (Subseção \ref{subsubsec:geracao_de_perfil_de_velocidade}) que satisfazem tanto as restrições cinemáticas do veículo quanto os objetivos comportamentais especificados.

\subsubsection{Limitações da Abordagem e Perspectivas de Extensão}

Apesar da eficácia demonstrada pelas Máquinas de Estados Finitos no contexto específico deste trabalho, é importante reconhecer suas limitações intrínsecas como paradigma de modelagem comportamental para VA em ambientes de complexidade arbitrária.

A principal limitação é o crescimento exponencial no número de estados e transições necessários para modelar comportamentos em ambientes de tráfego complexos. Conforme demonstrado por \citeonline{wei2014behavioral}, o número de estados requeridos para representar todas as combinações possíveis de situações de tráfego em ambientes urbanos densos pode tornar-se computacionalmente intratável, resultando no fenômeno conhecido como "explosão de estados".

Adicionalmente, as Máquinas de Estados Finitos apresentam limitada capacidade para lidar com incertezas e representações probabilísticas do ambiente, características inerentes aos sistemas de percepção baseados em visão computacional (Seção \ref{per_visual_carro}). A natureza determinística das FSMs dificulta a incorporação de informações incertas ou parciais, potencialmente resultando em comportamentos sub-ótimos em cenários de alta ambiguidade perceptual \cite{University_of_Toronto2018-mp}.

Para superar estas limitações em aplicações futuras, diversas abordagens alternativas ou complementares podem ser consideradas:

\begin{enumerate}
    \item \textbf{Máquinas de Estados Hierárquicas}: estruturas que introduzem relações de composição entre estados, permitindo modelagem em múltiplos níveis de abstração e reduzindo significativamente o número de estados necessários para representar comportamentos complexos \cite{wei2014behavioral};
    
    \item \textbf{Modelos Probabilísticos}: formalismos como Processos de Decisão de Markov Parcialmente Observáveis que incorporam explicitamente incertezas perceptuais e transições probabilísticas, possibilitando comportamentos robustos em ambientes com informação incompleta \cite{sutton1998reinforcement};
    
    \item \textbf{Técnicas de Aprendizado por Reforço}: metodologias que permitem aprendizado automático de políticas comportamentais a partir de experiência acumulada, adaptando-se a novos ambientes e situações sem reprogramação explícita \cite{sutton1998reinforcement}.
\end{enumerate}

No entanto, para o escopo dos Objetivos Específico \ref{objetivos_esp} deste trabalho, focado na implementação de resposta comportamental a sinalizações de trânsito em ambientes urbanos estruturados, a abordagem baseada em Máquinas de Estados Finitos oferece equilíbrio adequado entre expressividade, eficiência computacional e interpretabilidade. Estas características são particularmente relevantes no contexto de sistemas críticos de segurança, onde comportamentos previsíveis e verificáveis constituem requisito fundamental para validação e certificação.

\subsection{Planejamento Local} \label{subsec:planejamento_local}

O planejamento local representa o nível operacional mais detalhado na hierarquia de planejamento de movimento em VA, conforme apresentado anteriormente na Figura \ref{Hierarchical_Planning}. Este componente é responsável pela tradução das decisões comportamentais (Subseção \ref{subsec:planejamento_comportamental}) em trajetórias fisicamente executáveis que satisfaçam simultaneamente as restrições cinemáticas e dinâmicas do veículo, modeladas na Seção \ref{modelagem_veiculos}, e os objetivos de alto nível estabelecidos pelo planejador de missão (Subseção \ref{subsec:planejamento_de_missao}). 

Funcionalmente, o planejamento local subdivide-se em duas tarefas complementares: o planejamento espacial do caminho, que determina a sequência de posições a serem ocupadas pelo veículo, e a geração do perfil de velocidade, que estabelece a velocidade ao longo deste caminho, constituindo assim uma trajetória espaço-temporal completa e cinematicamente viável \cite{University_of_Toronto2018-mp}.

A complexidade deste módulo deriva da necessidade de equilibrar múltiplos objetivos concorrentes: segurança (evitando colisões), eficiência (minimizando tempo e energia), conforto (limitando acelerações e solavancos) e progresso consistente em direção ao destino. Esta otimização multiobjetivo deve ainda considerar as restrições não-holonômicas do veículo, apresentadas na modelagem cinemática da Subseção \ref{bicicleta}, enquanto se adapta a um ambiente dinâmico em constante modificação \cite{University_of_Toronto2018-mp}. Tais características exigem algoritmos especializados, entre os quais destacam-se os \textit{Lattice Planners}, que serão explorados na Subseção \ref{lattice_planners} a seguir.

\subsubsection{Lattice Planners} \label{lattice_planners}

Os \textit{Lattice Planners} constituem uma classe de algoritmos particularmente adequada para o planejamento local em VA, oferecendo um equilíbrio ótimo entre completude, eficiência computacional e capacidade de incorporar restrições cinemáticas diretamente na estrutura de planejamento \cite{pivtoraiko2009differentially}. Em contraste com abordagens baseadas em amostragem aleatória, como Rapidly-exploring Random Trees, os \textit{Lattice Planners} adotam uma estratégia determinística que limita deliberadamente o espaço de busca, restringindo as ações possíveis em cada estado do sistema, resultando em maior eficiência computacional sem comprometer significativamente a qualidade das trajetórias geradas \cite{University_of_Toronto2018-mp}.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Figures/lattice.png}
\caption{Representação de um \textit{Lattice Planner} mostrando a discretização do espaço de estados e conexões entre estados por trajetórias cinematicamente viáveis \cite[Module 2 - Lesson 4: Hierarchical Motion Planning. ~15min30s]{University_of_Toronto2018-mp}.}
\label{lattice}
\end{figure}

Conforme ilustrado na Figura \ref{lattice}, o princípio fundamental dos \textit{Lattice Planners} reside na discretização sistemática do espaço de estados do veículo em um conjunto regular de estados alcançáveis, conectados por trajetórias pré-computadas ou geradas em tempo real. Esta abordagem induz naturalmente uma estrutura de grafo no espaço de estados, onde cada nó representa um estado possível do veículo (caracterizado por posição, orientação e, possivelmente, velocidade) e cada aresta representa uma trajetória viável entre estados conectados \cite{pivtoraiko2009differentially}.

A característica distintiva dos \textit{Lattice Planners} é que todas as trajetórias representadas pelas arestas do grafo são, por construção, cinematicamente viáveis, respeitando restrições como curvatura máxima (derivada da geometria Ackermann apresentada na Subseção \ref{bicicleta}) e limites de aceleração do veículo. Segundo \citeonline{pivtoraiko2009differentially}, esta propriedade elimina a necessidade de verificações posteriores de viabilidade cinemática, simplificando significativamente o processo de busca e reduzindo o espaço computacional necessário.

O processo de planejamento em um \textit{Lattice Planner} tipicamente envolve as seguintes etapas \cite{University_of_Toronto2018-mp}:

\begin{enumerate}
    \item Discretização do espaço de estados em uma estrutura regular (\textit{lattice});
    \item Geração de trajetórias candidatas conectando estados próximos na \textit{lattice};
    \item Avaliação das trajetórias candidatas considerando critérios de segurança, conforto e progresso;
    \item Seleção da trajetória ótima segundo uma função de custo multiobjetivo;
    \item Refinamento do caminho selecionado para produzir uma trajetória suave e executável.
\end{enumerate}

Esta abordagem estruturada estabelece um processo robusto de planejamento, mas apresenta desafios específicos em cenários urbanos complexos, principalmente relacionados à eficiência computacional e adaptabilidade a configurações viárias variadas. Para superar estas limitações, foram desenvolvidas variantes especializadas como os \textit{Conformal Lattice Planners}, que incorporam informações contextuais sobre a geometria da via, conforme será discutido na Subseção \ref{conformal_lattice_planners}.

\subsubsection{Conformal Lattice Planners} \label{conformal_lattice_planners}

O \textit{Conformal Lattice Planner}, evolução do \textit{Lattice Planner} convencional, caracteriza-se pela capacidade de adaptar dinamicamente a estrutura da \textit{lattice} para alinhar-se com a geometria da via, como demonstrado na Figura \ref{conformal_lattice}. Esta conformidade geométrica proporciona duas vantagens fundamentais: uma representação mais intuitiva do ambiente de condução e uma redução significativa na dimensionalidade efetiva do espaço de busca em ambientes estruturados como vias urbanas e rodovias \cite{University_of_Toronto2018-mp}.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{Figures/conformal_lattice.png}
\caption{Estrutura de um \textit{Conformal Lattice Planner} evidenciando pontos-objetivo lateralmente deslocados em relação à linha central da via \cite[Module 2 - Lesson 4: Hierarchical Motion Planning. ~15min30s]{University_of_Toronto2018-mp}.}
\label{conformal_lattice}
\end{figure}

A abordagem conformal incorpora informações contextuais sobre a geometria da via diretamente na estrutura da malha, direcionando naturalmente a busca por trajetórias que seguem o fluxo do tráfego. Isto resulta em comportamentos mais previsíveis, eficientes e semelhantes à condução humana, características particularmente desejáveis para a aceitação social de VA, conforme discutido na Seção \ref{levelcla}.

Na implementação, Capítulo \ref{Implementação}, deste trabalho, codificada no arquivo \texttt{local\_planner.py}, o \textit{Conformal Lattice Planner} selecionará pontos-objetivo a uma distância predeterminada à frente do veículo, aplicando deslocamentos laterais calculados perpendicularmente à direção da via. Este método será implementado na função \texttt{get\_goal\_state\_set}, que calcula um conjunto de estados-objetivo a partir de um \textit{waypoint} central, gerando variações laterais que permitem ao veículo explorar diferentes posicionamentos na faixa.

Para cada ponto-objetivo gerado, o sistema otimiza um caminho considerando múltiplos critérios, incluindo comprimento do arco, energia de curvatura (relacionada ao conforto dos passageiros) e desvio da linha central da faixa. O caminho que melhor satisfaz a função objetivo global, mantendo-se simultaneamente livre de colisões (conforme verificado pelo módulo descrito na Subseção \ref{verificacao_colisoes}), é então selecionado para execução \cite{University_of_Toronto2018-mp}.

Uma característica distintiva desta abordagem é sua capacidade de produzir trajetórias que mimetizam naturalmente o comportamento humano, gerando caminhos suaves que desviam ligeiramente para a esquerda ou direita do centro da faixa quando necessário para evitar obstáculos, semelhante ao comportamento intuitivo de condutores em situações análogas.

\subsubsection{Otimização de Caminhos com Espirais Paramétricas} \label{otimizacao_caminho}

A geração de trajetórias suaves que respeitam as restrições não-holonômicas do veículo, apresentadas na Subseção \ref{bicicleta}, é fundamental para garantir conforto, segurança e eficiência energética durante a condução autônoma. Para alcançar este objetivo, este trabalho implementa uma abordagem baseada em espirais paramétricas cúbicas, cuja curvatura varia de forma contínua ao longo do caminho, garantindo transições suaves de direção e minimizando solavancos \cite{University_of_Toronto2018-mp}.

A espiral cúbica é definida matematicamente por uma função de curvatura $\kappa(s)$ expressa como um polinômio de terceiro grau em relação ao comprimento do arco $s$, conforme a Equação \ref{kappas}:

\begin{equation} \label{kappas}
\kappa(s) = a + b \cdot s + c \cdot s^2 + d \cdot s^3
\end{equation}

onde $a$, $b$, $c$ e $d$ são coeficientes determinados pelo processo de otimização.

A orientação $\theta(s)$ ao longo da espiral é obtida pela integração da curvatura em relação ao comprimento do arco, resultando na expressão da Equação \ref{thetaf} \cite{University_of_Toronto2018-mp}:

\begin{equation} \label{thetaf}
\theta(s) = \theta_0 + a \cdot s + \frac{b}{2} \cdot s^2 + \frac{c}{3} \cdot s^3 + \frac{d}{4} \cdot s^4
\end{equation}

onde $\theta_0$ representa a orientação inicial do veículo.

As coordenadas cartesianas $(x,y)$ ao longo da espiral são obtidas pela integração de funções trigonométricas da orientação, conforme as Equações \ref{integral_func_tri_1} e \ref{integral_func_tri_2}:

\begin{equation} \label{integral_func_tri_1}
x(s) = x_0 + \int_{0}^{s} \cos(\theta(\sigma)) \, d\sigma
\end{equation}

\begin{equation} \label{integral_func_tri_2}
y(s) = y_0 + \int_{0}^{s} \sin(\theta(\sigma)) \, d\sigma
\end{equation}

onde $(x_0, y_0)$ representa a posição inicial do veículo.

Na implementação prática deste trabalho, estas integrais são computadas numericamente na função \texttt{sample\_spiral} utilizando o método \texttt{scipy.integrate.cumtrapz}, que implementa a regra do trapézio para integração numérica eficiente.

O problema de otimização consiste em determinar os parâmetros $a$, $b$, $c$ e $d$ da espiral que conectam um estado inicial (tipicamente na posição atual do veículo, com sua orientação) a um estado final (ponto-objetivo gerado pelo \textit{Conformal Lattice Planner}), minimizando uma função de custo que combina \cite{University_of_Toronto2018-mp}:

\begin{enumerate}
    \item Erro na posição final: minimização da distância euclidiana entre o ponto final da espiral e o ponto-objetivo;
    \item Erro na orientação final: minimização da diferença angular entre a orientação final da espiral e a orientação desejada;
    \item Energia de curvatura: minimização da integral $\int \kappa(s)^2 \, ds$ ao longo do caminho, relacionada diretamente ao conforto dos passageiros e à eficiência energética.
\end{enumerate}

Esta otimização é realizada na função \texttt{optimize\_spiral} utilizando o algoritmo L-BFGS-B (Limited-memory Broyden–Fletcher–Goldfarb–Shanno with Bounds) disponível no módulo \texttt{scipy.optimize}. Este método é particularmente adequado para problemas de otimização não-linear com restrições de limites nas variáveis. As restrições impostas limitam a curvatura máxima da espiral a $\pm 0.5$ $m^{-1}$, valor derivado das limitações físicas do modelo de direção Ackermann apresentado na Subseção \ref{bicicleta}, e garantem que o comprimento do arco seja pelo menos igual à distância em linha reta até o objetivo, evitando soluções fisicamente implausíveis.

A abordagem de espirais paramétricas integra-se perfeitamente com o modelo cinemático da bicicleta apresentado na Subseção \ref{bicicleta} e com o controlador de perseguição pura da Subseção \ref{pure_persuit}, formando um sistema coerente que garante trajetórias suaves, confortáveis e executáveis pelo sistema de controle veicular.

\subsubsection{Verificação de Colisões} \label{verificacao_colisoes}

A verificação de colisões, componente crítico para a segurança do sistema autônomo, que será implementada no arquivo \texttt{collision\_checker.py} através de uma representação geométrica simplificada do veículo. Esta abordagem, ilustrada na Figura \ref{collision_circles}, aproxima a geometria retangular do veículo por um conjunto de círculos com centros estrategicamente posicionados ao longo do eixo longitudinal do veículo, permitindo evitar caminho com colisão.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{Figures/collision_circles.pdf}
\caption{Aproximação conservadora do veículo por círculos sobrepostos para verificação eficiente de colisões (Retângulo em vermelho representa o objeto a ser contornado) \cite[Module 8 - Lesson 4: Conformal Lattice Planning. ~10min]{University_of_Toronto2018-mp}.}
\label{collision_circles}
\end{figure}

Esta técnica, conforme descrito por \citeonline{University_of_Toronto2018-mp}, constitui uma aproximação conservadora para verificação de colisões, garantindo máxima segurança operacional. O conceito de aproximação conservadora, neste contexto, significa que o método pode ocasionalmente reportar falsos positivos (indicar colisão quando não existe), mas nunca produzirá falsos negativos (indicar ausência de colisão quando esta de fato existe). Esta propriedade deriva do fato de que a área coberta pelos círculos sobrepostos engloba completamente a área retangular do veículo, assegurando que qualquer trajetória classificada como livre de colisões para a representação circular também será segura para o veículo real.

Para cada caminho candidato gerado pelo planejador, a função \texttt{collision\_check} posiciona sistematicamente os círculos ao longo da trajetória discretizada e verifica se algum deles intersecta os obstáculos identificados no ambiente. Este posicionamento considera tanto a localização quanto a orientação do veículo em cada ponto do caminho, derivadas das equações cinemáticas apresentadas na Subseção \ref{bicicleta}. A verificação é realizada calculando a distância entre os centros dos círculos e os pontos de obstáculos, subtraindo o raio dos círculos. Se esta distância resultar negativa para qualquer círculo, o caminho é classificado como inseguro devido à potencial colisão.

A implementação utilizará a função \texttt{scipy.spatial.distance.cdist} para calcular eficientemente as distâncias entre múltiplos pontos simultaneamente, otimizando o processo de verificação para execução em tempo real, requisito fundamental para aplicações de condução autônoma, conforme estabelecido nos objetivos específicos na Seção \ref{objetivos_esp}.

Além da classificação binária de segurança (livre de colisão ou não), o módulo \texttt{collision\_checker.py} implementará a função \texttt{select\_best\_path\_index}, que seleciona o caminho ótimo entre os candidatos classificados como seguros, considerando critérios adicionais:

\begin{enumerate}
    \item Proximidade à linha central da faixa: calculada como a distância entre o ponto final do caminho e o estado objetivo central, priorizando trajetórias que seguem a referência central sempre que possível;
    \item Margem de segurança: maximização da distância aos caminhos em colisão, privilegiando trajetórias que mantêm maior separação de áreas potencialmente perigosas.
\end{enumerate}

Esta abordagem de seleção de caminho implementa uma estratégia de condução que prioriza seguir o centro da faixa quando o caminho está desobstruído, desviando somente o necessário para evitar obstáculos, e sempre mantendo a maior distância possível de áreas classificadas como inseguras, conforme podemos identificar pela Figura \ref{free-path}.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{Figures/free-path.jpg}
\caption{Seleção do caminho livre de colisão (em azul, linha inferior) \cite[Module 8 - Lesson 4: Conformal Lattice Planning. ~9min]{University_of_Toronto2018-mp}.}
\label{free-path}
\end{figure}

Este comportamento alinha-se naturalmente com as práticas de condução defensiva humana, contribuindo para a segurança global do sistema e para a aceitação social da tecnologia autônoma, aspectos discutidos na Seção \ref{levelcla}.

A integração dos elementos apresentados nesta subseção, \textit{Conformal Lattice Planners}, espirais paramétricas e verificação conservadora de colisões, constitui um sistema de planejamento local robusto e eficiente que satisfaz os requisitos estabelecidos nos objetivos específicos (Seção \ref{objetivos_esp}), permitindo a navegação segura do VA em ambientes urbanos estruturados, como será demonstrado experimentalmente no Capítulo \ref{resultados}.

\subsection{Geração de Perfil de Velocidade}\label{subsubsec:geracao_de_perfil_de_velocidade}

A geração de perfil de velocidade constitui etapa fundamental na conversão do planejamento espacial, apresentado nas Subseções \ref{lattice_planners} e \ref{otimizacao_caminho}, em uma trajetória espaço-temporal completa executável pelo sistema de controle descrito na Seção \ref{modelagem_veiculos}. Este componente estabelece a velocidade apropriada para cada ponto da trajetória espacial, considerando simultaneamente as restrições cinemáticas e dinâmicas do veículo, as condições ambientais e os requisitos operacionais \cite{paden2016survey}.

Em consonância com a arquitetura hierárquica de planejamento apresentada na Figura \ref{Hierarchical_Planning}, a geração de perfil de velocidade representa a integração final entre decisões comportamentais (descritas na Subseção \ref{subsec:planejamento_comportamental}) e características geométricas do caminho, constituindo assim a interface entre planejamento e controle na arquitetura de três camadas proposta na Figura \ref{Arquitetura_soft_autor}. Esta integração é particularmente relevante para o cumprimento do objetivo específico relacionado à "resposta comportamental a sinalizações de trânsito" estabelecido na Subseção \ref{objetivos_esp}.

Neste trabalho, a implementação deste componente no módulo \texttt{velocity\_planner.py} adotará uma abordagem baseada em cenários operacionais distintos, cada um representando uma situação específica de condução. Esta estruturação reflete diretamente os estados comportamentais definidos na máquina de estados finitos da Subseção \ref{subsubsec:FSM}, estabelecendo uma correlação direta entre o comportamento de alto nível e o perfil de velocidade resultante.

\subsubsection{Classificação de Perfis de Velocidade} \label{subsubsec:classificao_perfil}

O sistema implementará três tipos fundamentais de perfis de velocidade, correspondendo aos estados comportamentais principais do VA:

\begin{enumerate}
    \item \textbf{Perfil Nominal:} aplicado em condições de tráfego livre, quando o veículo se encontra no estado comportamental \texttt{FOLLOW\_LANE} (Subseção \ref{subsubsec:FSM}) sem restrições específicas que exijam modificações em sua velocidade. O objetivo principal é que o veículo alcance e mantenha uma velocidade de cruzeiro predeterminada $v_{des}$, respeitando limites de aceleração que garantam o conforto dos ocupantes, conforme estabelecido na modelagem dinâmica da Subseção \ref{mod_longitudinal}.
    
    A dinâmica do perfil nominal fundamenta-se nas equações do movimento uniformemente variado, onde a distância necessária para transição entre velocidades é calculada conforme a Equação \ref{eq:calculo_distancia}, apresentada na Subseção \ref{subsubsec:arquitetura_implementacao_velocidade}.
    
    Na implementação prática, o perfil de velocidade ao longo do caminho é definido por uma função que utiliza interpolação linear entre a velocidade atual e a velocidade desejada, baseada na proporção da distância percorrida em relação à distância total de aceleração.
    
    \begin{equation}\label{eq:perfil_nominal}
    v(s) = 
    \begin{cases} 
    v_{atual} + \frac{s}{d_{accel}} \cdot (v_{des} - v_{atual}) & \text{se } s < d_{accel} \\
    v_{des} & \text{se } s \geq d_{accel}
    \end{cases}
    \end{equation}
    
    onde $s$ representa a distância percorrida ao longo do caminho. Esta formulação baseada em interpolação linear, apresentada na Equação \ref{eq:perfil_nominal}, facilita a implementação computacional e proporciona transições de velocidade mais suaves, evitando descontinuidades na aceleração \cite{University_of_Toronto2018-mp}.
    
    \item \textbf{Perfil de Desaceleração para Parada:} ativado quando o veículo transita para o estado \texttt{DECELERATE\_TO\_STOP} na máquina de estados comportamentais (Subseção \ref{subsubsec:FSM}), tipicamente em resposta à detecção de sinalizações de parada obrigatória através do sistema de cercas virtuais descrito na Subseção \ref{subsubsec:cercas_virtuais}.
    
    Para otimizar simultaneamente o conforto, segurança e eficiência energética, o perfil de desaceleração adota uma estrutura trapezoidal caracterizada por três fases distintas, conforme recomendado por \citeonline{wei2014behavioral}:
    
    \begin{itemize}
        \item \textbf{Fase de Desaceleração Inicial:} redução controlada da velocidade atual ($v_{atual}$) até uma velocidade intermediária ($v_{slow}$);
        \item \textbf{Fase de Velocidade Constante:} manutenção da velocidade intermediária ($v_{slow}$) por uma distância predeterminada;
        \item \textbf{Fase de Desaceleração Final:} redução gradual da velocidade de $v_{slow}$ até a parada completa ($v = 0$).
    \end{itemize}
    
    As distâncias necessárias para as fases de desaceleração são calculadas utilizando as equações derivadas da modelagem longitudinal (Subseção \ref{mod_longitudinal}):
    
    \begin{equation}\label{eq:distancia_desaceleracao}
    d_{decel} = \frac{v_{atual}^2 - v_{slow}^2}{2 \cdot a_{max}}
    \end{equation}
    
    \begin{equation}\label{eq:distancia_frenagem}
    d_{brake} = \frac{v_{slow}^2}{2 \cdot a_{max}}
    \end{equation}
    
    A distância total necessária para uma parada completa incorpora as três fases e uma margem de segurança adicional, conforme Equação \ref{eq:distancia_total}:
    
    \begin{equation}\label{eq:distancia_total}
    d_{total} = d_{decel} + d_{coast} + d_{brake} + d_{buffer}
    \end{equation}
    
    onde $d_{coast}$ representa a distância percorrida na fase de velocidade constante intermediária, calculada com base na distância disponível até a linha de parada após subtrair as distâncias necessárias para desaceleração (Equação \ref{eq:distancia_desaceleracao}) e frenagem final (Equação \ref{eq:distancia_frenagem}), e $d_{buffer}$ é uma margem de segurança adicional em relação à linha de parada (tipicamente entre 2 e 4 metros), garantindo conformidade com as regulamentações de tráfego que exigem parada completa antes da linha de sinalização \cite{University_of_Toronto2018-mp}.
    
    \item \textbf{Perfil de Seguimento de Veículo:} este perfil é ativado em cenários onde veículos são detectados na mesma faixa de tráfego à frente do VA, exigindo ajustes de velocidade para manter uma distância segura.
    
    O princípio fundamental deste perfil baseia-se no conceito de tempo de separação ($t_{gap}$), uma métrica que define o intervalo temporal desejado entre veículos sucessivos, conforme estabelecido na literatura de dinâmica veicular \cite{wei2014behavioral}. Na implementação atual, a distância de separação é calculada, conforme a Equação \ref{eq:distancia_gap}:
    
    \begin{equation}\label{eq:distancia_gap}
    d_{gap} = v_{ego} \cdot t_{gap}
    \end{equation}
    
    onde $v_{ego}$ representa a velocidade do VA e $t_{gap}$ é o tempo de separação desejado (tipicamente entre 1,0 e 2,0 segundos).
    
    Esta formulação adaptativa da Equação \ref{eq:distancia_gap}, em contraste com abordagens baseadas em distância fixa, proporciona margem de segurança adequada em diferentes regimes de velocidade, alinhando-se com o princípio da "regra dos dois segundos" amplamente utilizada em segurança veicular e incorporada nos sistemas ADAS comerciais descritos na Seção \ref{levelcla}.
\end{enumerate}

\subsubsection{Arquitetura de Implementação}\label{subsubsec:arquitetura_implementacao_velocidade}

O módulo \texttt{velocity\_planner.py} implementará uma hierarquia decisória que seleciona o perfil de velocidade apropriado em cada ciclo de planejamento, priorizando requisitos de segurança sobre otimização de eficiência. Esta hierarquia avalia sequencialmente:

\begin{enumerate}
    \item A necessidade de parada em resposta a sinalizações (\texttt{decelerate\_profile});
    \item A necessidade de ajustar velocidade para seguimento de veículo (\texttt{follow\_profile});
    \item A aplicação do perfil nominal na ausência de restrições específicas (\texttt{nominal\_profile}).
\end{enumerate}

Esta estrutura de prioridades reflete a importância primordial da segurança em sistemas autônomos, conforme destacado na classificação SAE apresentada na Seção \ref{levelcla}, onde a resposta segura a sinalizações constitui requisito fundamental para todos os níveis de automação.

Para viabilizar os cálculos de perfil de velocidade, o módulo implementará duas funções fundamentais derivadas diretamente das equações cinemáticas do movimento uniformemente variado \cite{University_of_Toronto2018-mp}:

\begin{enumerate}
    \item \texttt{calc\_distance}: calcula a distância necessária para transição entre velocidades sob aceleração constante, aplicando a Equação \ref{eq:calculo_distancia}:
    
    \begin{equation}\label{eq:calculo_distancia}
    d = \frac{v_f^2 - v_i^2}{2a}
    \end{equation}
    
    Esta equação, derivada da física clássica e apresentada na modelagem longitudinal (Subseção \ref{mod_longitudinal}), permite determinar o espaço necessário para alterar a velocidade do veículo de $v_i$ para $v_f$ sob aceleração constante $a$. A função implementa verificações de validade para tratar casos de aceleração nula ou velocidades iguais, garantindo estabilidade numérica em todas as condições operacionais.
    
    \item \texttt{calc\_final\_speed}: determina a velocidade final após percorrer uma distância específica sob aceleração constante, aplicando Equação \ref{eq:velocidade_final_basica}:
    
    \begin{equation}\label{eq:velocidade_final_basica}
    v_f = \sqrt{v_i^2 + 2ad}
    \end{equation}
    
    Esta implementação inclui verificação do discriminante para tratar casos onde a desaceleração seria suficiente para imobilizar completamente o veículo antes da distância especificada, situação que exige tratamento especial para evitar valores imaginários na solução da Equação \ref{eq:velocidade_final_basica}. A implementação completa é representada pela Equação \ref{eq:velocidade_final_completa}:
    
    \begin{equation}\label{eq:velocidade_final_completa}
    v_f = 
    \begin{cases}
    \sqrt{v_i^2 + 2ad} & \text{se } v_i^2 + 2ad \geq 0 \\
    0 & \text{se } v_i^2 + 2ad < 0
    \end{cases}
    \end{equation}
    
    Esta formulação da Equação \ref{eq:velocidade_final_completa} garante resultados fisicamente consistentes em todos os cenários, inclusive nas situações onde o veículo desacelera até a imobilização completa antes de percorrer toda a distância especificada.
\end{enumerate}

O sistema impõe restrições físicas aos perfis gerados, limitando acelerações e desacelerações aos valores máximos permitidos pela dinâmica veicular e pelos requisitos de conforto. Conforme estabelecido na modelagem dinâmica (Subseção \ref{dinamica_2D}) e corroborado por \citeonline{wei2014behavioral}, os limites típicos para conforto são definidos por:

\begin{equation}\label{eq:limites_aceleracao}
-3,0 \text{ m/s}^2 \leq a_{long} \leq 2,0 \text{ m/s}^2
\end{equation}

Estes limites, implementados como parâmetros configuráveis no sistema, refletem o equilíbrio entre desempenho dinâmico e conforto dos passageiros, aspecto fundamental para a aceitabilidade social dos VA, conforme discutido na Seção \ref{levelcla}.

\subsubsection{Integração com o Sistema de Controle}

O resultado do processo de geração de perfil de velocidade é uma trajetória espaço-temporal na forma da Equação \ref{eq:trajetoria_espaco_temporal}:

\begin{equation}\label{eq:trajetoria_espaco_temporal}
\tau = \{(x_0, y_0, v_0), (x_1, y_1, v_1), ..., (x_n, y_n, v_n)\}
\end{equation}

onde cada ponto espacial $(x_i, y_i)$ da trajetória otimizada (Subseção \ref{otimizacao_caminho}) é associado a uma velocidade objetivo $v_i$. Esta trajetória completa definida pela Equação \ref{eq:trajetoria_espaco_temporal} é então transmitida ao controlador longitudinal PID (Subseção \ref{PID}), que gera os comandos de aceleração e frenagem necessários para seguir o perfil de velocidade planejado.

Um aspecto adicionado para garantir um comportamento natural é a interpolação do perfil de velocidade entre pontos adjacentes da trajetória. Segundo o autor, \citeonline{University_of_Toronto2018-mp} este procedimento evita que o controlador “fique preso” no estado inicial devido à proximidade espacial, proporcionando uma transição mais suave. A interpolação é particularmente importante durante a fase de inicialização do sistema e nas transições entre estados comportamentais, garantindo continuidade nas ações de controle, aspecto fundamental para o conforto dos passageiros, conforme discutido na Subseção \ref{PID} ao analisar as características do controlador PID.

Esta abordagem de geração de perfil de velocidade, integrada com os componentes de planejamento espacial (Subseções \ref{lattice_planners} e \ref{otimizacao_caminho}) e os algoritmos de controle (Seção \ref{modelagem_veiculos}), constitui um sistema completo de planejamento de trajetória que satisfaz os requisitos de segurança, conforto e eficiência estabelecidos nos objetivos deste trabalho (Seção \ref{objetivos}). As equações apresentadas, desde a distância de aceleração (Equação \ref{eq:calculo_distancia}) até a definição da trajetória espaço-temporal (Equação \ref{eq:trajetoria_espaco_temporal}), compõem um modelo matemático coerente que fundamenta a implementação computacional.

A validação experimental deste sistema, apresentada no Capítulo \ref{resultados}, demonstrará sua eficácia em cenários que incluem respostas a sinalizações de trânsito no ambiente simulado CARLA (Subseção \ref{subsubsec:simulador_carla}), contribuindo diretamente para o objetivo específico de implementar um "sistema de resposta comportamental a sinalizações de trânsito" (Seção \ref{objetivos_esp}).

\section{Percepção Visual de Carros Autônomos} \label{per_visual_carro}

A percepção visual constitui o componente fundamental da primeira camada na arquitetura hierárquica de três camadas apresentada na Figura \ref{Arquitetura_soft_autor}, sendo responsável pela transformação de dados sensoriais brutos em representações estruturadas que viabilizam a compreensão do ambiente operacional. Conforme estabelecido na Seção \ref{componentes_da_tarefa_de_conducao}, esta camada representa a base informacional que normalmente alimenta os módulos subsequentes de planejamento (Seção \ref{planejamento}) e controle (Seção \ref{modelagem_veiculos}), determinando significativamente a eficácia global do sistema autônomo.

Esta seção desenvolve os fundamentos teóricos e metodológicos que sustentam a implementação do sistema de percepção visual baseado em algoritmos YOLO, alinhando-se diretamente ao segundo objetivo específico estabelecido na Seção \ref{objetivos_esp}: "desenvolver um módulo de detecção e classificação de objetos em tempo real baseado no algoritmo YOLO, especificamente configurado para identificar placas de parada no simulador CARLA". A abordagem metodológica adotada reflete a hipótese central apresentada na Seção \ref{hipotese}, que propõe a viabilidade de sistemas de assistência à condução capazes de oferecer \textit{feedback} visual de placas de trânsito em tempo real, contribuindo para uma condução mais confiável.

A organização desta seção segue uma progressão lógica que fundamenta o desenvolvimento experimental posteriormente apresentado no Capítulo \ref{Implementação}. Inicialmente, a Subseção \ref{camera} explora os fundamentos da aquisição de imagens via câmeras no contexto automotivo, analisando as características técnicas necessárias para aplicações em sistemas de VA. Em seguida, a Subseção \ref{YOLO_metodo} apresenta os princípios teóricos do algoritmo YOLO, justificando sua seleção como base para o sistema de detecção e comparando-o com abordagens alternativas. Por fim, a Subseção \ref{subsec:arquitetura_tempo_real} estabelece o arcabouço conceitual para implementação de processamento assíncrono e otimizações necessárias para operação em tempo real, incluindo a arquitetura distribuída desenvolvida para superar limitações de compatibilidade entre diferentes versões de Python e bibliotecas.

\subsection{Fundamentos de Visão Computacional Automotiva} \label{camera}

As câmeras constituem sensores exteroceptivos fundamentais em sistemas de percepção veicular, conforme apresentado na Subseção \ref{sensor}, oferecendo vantagens significativas em termos de riqueza informacional e discriminação semântica. Como evidenciado na matriz de adequação sensorial da Figura \ref{all-sense}, as câmeras apresentam pontuação máxima (4) para detecção de sinalização de trânsito, justificando sua seleção como sensor primário para o sistema proposto neste trabalho.

Contudo, para aplicações de detecção de objetos em VA, as configurações de câmera devem considerar parâmetros técnicos que impactam diretamente a qualidade e eficiência do processamento de imagens. Desse modo, a implementação experimental no simulador CARLA, detalhada no Capítulo \ref{Implementação}, utiliza uma configuração otimizada para o algoritmo YOLO, considerando os seguintes parâmetros fundamentais:

\begin{enumerate}
    \item \textbf{Resolução}: a seleção da resolução apropriada representa um compromisso entre riqueza de detalhes e eficiência computacional. Resoluções muito altas proporcionam maior detalhamento, mas exigem maior capacidade de processamento, comprometendo o requisito de tempo real estabelecido nos objetivos específicos (Seção \ref{objetivos_esp}). Por outro lado, resoluções muito baixas reduzem a capacidade de detecção de objetos pequenos ou distantes, como placas de trânsito. Para o algoritmo YOLOv8, resoluções médias como 640×480 \textit{pixels} oferecem equilíbrio ideal entre detalhamento e desempenho computacional, conforme será demonstrado experimentalmente no Capítulo \ref{resultados}.
    
    \item \textbf{Posicionamento}: a localização física da câmera no veículo determina fundamentalmente seu campo de visão e capacidade de detecção. Em veículos reais, câmeras são tipicamente posicionadas na região do para-brisa, na altura dos retrovisores ou nos para-choques, conforme ilustrado na arquitetura sensorial da Figura \ref{figura-sensores}. No contexto de VA, o posicionamento ideal deve simular a perspectiva do condutor humano, maximizando a visibilidade frontal e minimizando obstruções, aspecto especialmente relevante para a integração com o sistema de \textit{feedback} visual proposto.
    
    \item \textbf{Orientação}: o alinhamento do eixo óptico da câmera com relação ao veículo afeta diretamente o campo visual e a perspectiva das imagens capturadas. A orientação padrão alinha o eixo óptico da câmera com o eixo longitudinal do veículo, garantindo máxima visibilidade frontal, essencial para detecção antecipada de sinalização. Esta configuração relaciona-se diretamente com os sistemas de coordenadas e transformações geométricas discutidos na Subseção \ref{trans}, estabelecendo a relação espacial entre o referencial do sensor e o referencial do veículo.
    
    \item \textbf{Campo de Visão (FOV)}: este parâmetro, medido em graus, determina a amplitude angular da cena capturada pela câmera. Um FOV estreito proporciona melhor detalhamento de objetos distantes, enquanto FOVs amplos capturam mais elementos da cena, mas com menor resolução para objetos distantes. Para aplicações de detecção de sinalização de trânsito, FOVs entre 60° e 90° horizontal representam compromisso adequado, conforme evidenciado na matriz de cobertura sensorial apresentada na Figura \ref{coverage}. No contexto da implementação experimental deste trabalho, foi selecionado um FOV de 70°, otimizado para o ambiente urbano simulado do CARLA.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{Figures/000088.png}
\caption{Captura exemplar da câmera configurada no simulador CARLA, demonstrando a qualidade visual e campo de visão utilizados para alimentação do sistema de detecção YOLO. O FOV horizontal é de 70°, com resolução de 640×480 pixels. A imagem permite visualização clara de elementos da infraestrutura viária como pavimento, sinalizações horizontais e outros veículos a distâncias de até aproximadamente 80 metros (Elaborado pelo autor).}
\label{camara_sceneFinal}
\end{figure}

A Figura \ref{camara_sceneFinal} ilustra o resultado visual de uma configuração otimizada para detecção de objetos em ambiente urbano simulado. A resolução, campo de visão e características de imagem resultantes proporcionam dados adequados para detecção robusta de placas de trânsito, alinhando-se aos requisitos estabelecidos na matriz de adequação sensorial da Figura \ref{all-sense} e aos objetivos específicos deste trabalho (Seção \ref{objetivos_esp}). Esta configuração estabelece as condições iniciais para a aplicação do algoritmo YOLO, que será detalhado na Subseção \ref{YOLO_metodo}.

\subsubsection{Limitações Fundamentais da Visão Computacional em Ambientes Automotivos} \label{subsubsec:limitacoes_visao}

Embora as câmeras ofereçam vantagens significativas para sistemas de percepção veicular, é essencial reconhecer suas limitações intrínsecas em contextos automotivos reais. Estas restrições influenciam diretamente o \textit{design} e a implementação de sistemas robustos de percepção visual, sendo particularmente relevantes para a contextualização dos resultados experimentais apresentados no Capítulo \ref{resultados} e para estabelecer direcionamentos futuros no Capítulo \ref{continuidade}:

\begin{enumerate}
    \item \textbf{Sensibilidade às condições de iluminação}: as câmeras convencionais apresentam desempenho comprometido em condições de iluminação extrema, como ofuscamento direto solar, cenas noturnas com baixa luminosidade, ou transições abruptas entre áreas iluminadas e sombreadas, como entradas e saídas de túneis \cite{kim2023challenges}. Esta limitação relaciona-se diretamente com os desafios de robustez em condições ambientais variadas, conforme discutido nos trabalhos relacionados da Seção \ref{trabalhos_relacionados}.
    
    \item \textbf{Vulnerabilidade a condições climáticas adversas}: precipitações intensas, neblina, neve ou poeira atmosférica podem reduzir significativamente a visibilidade e qualidade das imagens capturadas, comprometendo a eficácia dos algoritmos de detecção \cite{kim2023challenges}. O simulador CARLA permite a avaliação controlada destes efeitos através das variações climáticas ilustradas na Figura \ref{carla_weather}, possibilitando análises de robustez em diferentes cenários.
    
    \item \textbf{Limitações na percepção de profundidade}: sistemas monoculares (baseados em uma única câmera) apresentam dificuldades na estimação precisa de distâncias e relações espaciais tridimensionais, frequentemente exigindo complementação por outros sensores como LiDAR ou radar para estimações robustas de profundidade \cite{janai_computer_vision_av}. Esta limitação impacta diretamente a capacidade de cálculo de distâncias para objetos detectados, aspecto relevante para o planejamento comportamental discutido na Seção \ref{subsec:planejamento_comportamental}.
    
    \item \textbf{Desafios de transferência de domínio}: modelos treinados em \textit{datasets} específicos frequentemente apresentam degradação de desempenho quando aplicados em ambientes significativamente diferentes dos dados de treinamento, um fenômeno conhecido como "\textit{domain gap}" \cite{wu_physical_adversarial_attack}. Este desafio é particularmente relevante para a aplicação de modelos pré-treinados em ambientes simulados, conforme implementado neste trabalho e discutido no método da Seção \ref{metodo}.
\end{enumerate}

Estas limitações fundamentais impactam diretamente a confiabilidade e robustez dos sistemas de percepção baseados exclusivamente em visão computacional, especialmente em aplicações críticas de segurança como VA. Sistemas operacionais completos tipicamente adotam abordagens de fusão sensorial, integrando dados de múltiplos sensores complementares (câmeras, LiDAR, radar, ultrassom) para superar as limitações específicas de cada modalidade individual, conforme discutido na matriz de adequação sensorial apresentada na Figura \ref{all-sense}.

No contexto do presente trabalho, focado no ambiente controlado do simulador CARLA, estas limitações são parcialmente mitigadas pela natureza determinística do ambiente simulado. Entretanto, o reconhecimento destas restrições fundamentais é essencial para contextualizar adequadamente os resultados obtidos e estabelecer expectativas realistas quanto à transferência das soluções desenvolvidas para ambientes reais não controlados, conforme será discutido nas considerações finais do Capítulo \ref{concl}.

\subsection{Algoritmo YOLO para Detecção de Objetos em Tempo Real} \label{YOLO_metodo}

O algoritmo YOLO, apresentado inicialmente na Subseção \ref{yolo_section}, representa uma abordagem unificada que proporciona ganhos significativos em velocidade de processamento quando comparado a outros métodos, tornando-o particularmente adequada para aplicações automotivas em tempo real, conforme requerido pelos objetivos específicos estabelecidos na Seção \ref{objetivos_esp}.

\subsubsection{Análise Comparativa entre YOLO e Métodos Alternativos} \label{subsubsec:comparacao_metodos}

A seleção do algoritmo YOLO para este trabalho fundamenta-se em uma análise comparativa sistemática com outras arquiteturas contemporâneas. A Tabela \ref{tab:comparacao_arquiteturas} apresenta métricas de desempenho para as principais abordagens consideradas, estabelecendo base objetiva para a decisão metodológica adotada.

\begin{table}[h] 
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{lcccl} 
\hline
\textbf{Arquitetura} & \textbf{mAP@0.5} & \textbf{FPS} & \textbf{Parâmetros} & \textbf{Características} \\
\hline
YOLO v8s & 58.5\% & 45 & 11.2M & Single-stage, anchor-free \cite{wang2024yolov10realtimeendtoendobject} \\
Faster R-CNN (R-50-FPN) & 61.0\% & 26 & 42.0M & Two-stage, region proposal \cite{liu2020deep} \\
SSD (VGG16) & 53.3\% & 22 & 24.9M & Single-stage, multi-scale \cite{liu2020deep} \\
RetinaNet (R-50-FPN) & 57.5\% & 12 & 36.4M & Single-stage, focal loss \cite{lin2017focal} \\
DETR (R-50) & 62.4\% & 28 & 41.3M & Transformer-based, query matching \cite{carion2020end} \\
\hline
\end{tabular} 
}

\footnotesize{Nota: Os valores apresentados foram compilados diretamente das publicações originais ou de benchmarks padronizados. As métricas de FPS foram normalizadas para GPU NVIDIA V100 conforme reportado por \cite{carion2020end,liu2020deep}. Variações de desempenho podem ocorrer em função de diferentes implementações, condições de teste e configurações de hardware.}
\caption{Análise comparativa entre arquiteturas de detecção de objetos.}
\label{tab:comparacao_arquiteturas}
\end{table}

A análise desta tabela revela importantes considerações sobre o YOLO em relação às abordagens alternativas \cite{redmon2016lookonceunifiedrealtime, wang2024yolov10realtimeendtoendobject}:

\begin{enumerate}
    \item \textbf{Equilíbrio entre precisão e velocidade}: observa-se que embora o YOLOv8s não apresente a maior precisão (mAP@0.5 de 58.5\% em relação a 62.4\% do DETR), sua velocidade de inferência de 45 FPS é significativamente superior ao requisito mínimo de 10 FPS estabelecido na Seção \ref{objetivos_esp}. Esta característica é crucial para a operação em tempo real requerida pelo sistema de assistência à condução proposto na hipótese central deste trabalho (Seção \ref{hipotese});
    
    \item \textbf{Processamento em contexto global}: assim como o YOLO, arquiteturas modernas como DETR também processam a imagem em contexto global, porém via mecanismos distintos: YOLO utiliza uma abordagem de grid e convolução \cite{wang2024yolov10realtimeendtoendobject}, enquanto DETR emprega mecanismos de atenção \cite{carion2020end}. A eficiência do YOLO neste aspecto é particularmente adequada para ambientes urbanos onde o contexto visual é fundamental para identificação correta de sinalização de trânsito;
    
    \item \textbf{Eficiência de recursos computacionais}: com 11.2M parâmetros, o YOLOv8s representa economia significativa de recursos computacionais em comparação com Faster R-CNN (42.0M) \cite{liu2020deep}, RetinaNet (36.4M) \cite{lin2017focal} ou DETR (41.3M) \cite{carion2020end}. Esta característica é determinante para implementação em sistemas embarcados e dispositivos com recursos limitados, conforme requisitos do método experimental estabelecido na Seção \ref{metodo};
    
    \item \textbf{Maturidade e suporte da comunidade}: além das métricas quantitativas, o ecossistema YOLO apresenta extensa documentação, ampla comunidade de usuários e diversas implementações otimizadas \cite{wang2024yolov10realtimeendtoendobject}, facilitando adaptações específicas ao contexto do projeto, incluindo a integração com a arquitetura distribuída que será apresentada na Subseção \ref{subsubsec:arquitetura_distribuida}.
\end{enumerate}

É importante ressaltar que a escolha de uma arquitetura envolve diversos aspectos. Modelos como DETR e Faster R-CNN oferecem maior precisão em determinados cenários e poderiam ser preferíveis em aplicações onde o tempo de processamento não é crítico ou onde recursos computacionais abundantes estão disponíveis. Contudo, considerando o conjunto específico de requisitos deste projeto, particularmente a necessidade de processamento em tempo real em \textit{hardware} com recursos limitados, o YOLOv8s apresenta o melhor compromisso entre precisão, eficiência operacional e maior facilidade na implantação, conforme deliberaremos na Subseção \ref{subsubsec:just_yolo}.

\subsubsection{Princípios Matemáticos da Detecção YOLO} \label{subsubsec:matematica_yolo}

O fundamento matemático do algoritmo YOLO consiste na reformulação da detecção de objetos como um problema único de regressão, mapeando diretamente \textit{pixels} para predições espacialmente distribuídas. Formalmente, o algoritmo divide a imagem de entrada em uma grade $S \times S$ e, para cada célula da grade, prediz $B$ caixas delimitadoras, pontuação de confiança e probabilidades condicionais de classe.

Para cada caixa delimitadora $b$ na célula $(i,j)$, o vetor de predição $\mathbf{p}_{i,j,b}$ é expresso conforme a Equação \ref{eq:yolo_prediction} \cite{redmon2016lookonceunifiedrealtime}:

\begin{equation} \label{eq:yolo_prediction}
\mathbf{p}_{i,j,b} = [x, y, w, h, c, p_1, p_2, \ldots, p_C]
\end{equation}

\begin{conditions}
    x, y & coordenadas relativas do centro da caixa na célula $(i,j)$ \\
    w, h & dimensões relativas da caixa em relação à imagem completa \\
    c & confiança da predição, definida como $\text{Pr}(\text{Object}) \times \text{IOU}_{\text{pred}}^{\text{truth}}$ \\
    p_k & probabilidade condicional da classe $k$, definida como $\text{Pr}(\text{Class}_k|\text{Object})$
\end{conditions}

A confiança específica para cada classe $k$ é calculada através da multiplicação expressa na Equação \ref{eq:class_confidence}:

\begin{equation} \label{eq:class_confidence}
\text{Score}_{i,j,b,k} = c \times p_k = \text{Pr}(\text{Object}) \times \text{IOU}_{\text{pred}}^{\text{truth}} \times \text{Pr}(\text{Class}_k|\text{Object})
\end{equation}

Este valor representa simultaneamente a probabilidade de presença do objeto da classe $k$ e a precisão da localização espacial. Durante o treinamento, o modelo otimiza uma função de perda multitarefa que combina erros de localização, confiança e classificação \cite{redmon2016lookonceunifiedrealtime}.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/omodelo.png}
\caption{Arquitetura conceitual do YOLO. A imagem é dividida em uma grade $S \times S$, onde cada célula prediz $B$ caixas delimitadoras e $C$ probabilidades de classe. O sistema produz um tensor de saída com dimensão $S \times S \times (B \times 5 + C)$, onde cada célula contém informações completas de localização e classificação de objetos \cite[p.~2]{redmon2016lookonceunifiedrealtime}.}
\label{omodelo}
\end{figure}

A Figura \ref{omodelo} ilustra esta abordagem, onde a saída da rede neural constitui um tensor de dimensão $S \times S \times (B \times 5 + C)$, codificando todas as predições para cada célula da grade. Esta formulação matemática fundamenta o treinamento end-to-end da rede, permitindo otimização simultânea dos parâmetros para localização e classificação, em contraste com abordagens de duas etapas como Faster R-CNN.

Esta arquitetura matemática integra-se diretamente com o pipeline de processamento apresentado na Figura \ref{fluxo_percepcao}, onde as imagens capturadas pela câmera configurada conforme os parâmetros da Subseção \ref{camera} são processadas pelo modelo YOLO para gerar detecções que, subsequentemente, alimentam o sistema de \textit{feedback} visual.

\subsubsection{Arquitetura YOLOv8 Selecionada para Implementação}

Para a implementação experimental deste trabalho, selecionamos a arquitetura YOLOv8, evolução mais recente da família YOLO que incorpora avanços significativos em termos de precisão e eficiência conforme ilustrado na Figura \ref{YOLO10} da Subseção \ref{yolo_section}. A arquitetura do YOLOv8 representa uma evolução significativa sobre as versões anteriores, estruturada em três componentes principais conforme documentado por \citeonline{yaseen2024yolov8indepthexplorationinternal}:

\begin{enumerate}
    \item \textbf{Backbone}: baseado em CSPNet (Cross Stage Partial Network) aprimorado, que reduz significativamente a redundância computacional enquanto preserva capacidades de representação, permitindo extração eficiente de características hierárquicas da imagem;
    
    \item \textbf{Neck}: composto por uma arquitetura híbrida FPN+PAN (Feature Pyramid Network + Path Aggregation Network) que agrega características em múltiplas escalas, facilitando a detecção precisa de objetos de diferentes tamanhos;
    
    \item \textbf{Head}: implementa uma abordagem \textit{anchor-free} para predição de caixas delimitadoras, eliminando a necessidade de âncoras predefinidas e simplificando o processo de detecção.
\end{enumerate}

Esta arquitetura está ilustrada na Figura \ref{yolo_detection}, que demonstra o fluxo completo de processamento desde a entrada da imagem até a predição final.

\begin{figure}[H]
\centering
\includegraphics[width=14cm]{Figures/yolov8.png}
\caption{Pipeline completo de processamento do YOLOv8. O sistema processa imagens sequencialmente através dos módulos de entrada, backbone para extração de características, neck para agregação multi-escala, e finalmente a cabeça de predição que gera as detecções. Observe-se os fluxos de informação entre os diferentes estágios de processamento e como características de múltiplas escalas são integradas para otimizar a detecção de objetos de diferentes tamanhos \cite[p.~2]{yaseen2024yolov8indepthexplorationinternal}.}
\label{yolo_detection}
\end{figure}

O YOLOv8 introduz diversas melhorias metodológicas em relação às versões anteriores, particularmente relevantes para nosso contexto de detecção de sinalização de trânsito \cite{yaseen2024yolov8indepthexplorationinternal}:

\begin{itemize}
    \item \textbf{Abordagem Anchor-Free}: elimina a necessidade de caixas de âncora predefinidas, reduzindo a complexidade computacional e melhorando a detecção de objetos com proporções variadas - característica comum em sinalização de trânsito;
    
    \item \textbf{Perda Focal para Classificação}: atribui maior peso a exemplos difíceis de classificar, melhorando a detecção de objetos pequenos ou parcialmente obstruídos;
    
    \item \textbf{Técnicas Avançadas de Aumento de Dados}: incorpora métodos como aumentação mosaico e mixup, expondo o modelo a maior variedade de escalas e configurações espaciais;
    
    \item \textbf{Treinamento de Precisão Mista}: utiliza precisão de ponto flutuante de 16 bits durante o treinamento e inferência, acelerando significativamente o processamento em GPUs compatíveis enquanto mantém a precisão.
\end{itemize}

O modelo específico selecionado para nossa implementação é o YOLOv8s (small), que oferece um equilíbrio otimizado entre precisão (mAP@0.5 de 58,5\%) e velocidade de processamento (90ms em CPU, 6ms em GPU com \textit{hardware} adequado). Esta escolha fundamenta-se na análise de desempenho documentada por \citeonline{yaseen2024yolov8indepthexplorationinternal}, que demonstra que o YOLOv8s atinge uma relação precisão-velocidade ideal para aplicações em tempo real, evitando tanto o excesso de parâmetros quanto a insuficiência de capacidade de representação.

\subsubsection{Justificativa para a Seleção da Versão YOLO} \label{subsubsec:just_yolo}

Embora o presente trabalho reconheça o surgimento de versões mais recentes do algoritmo YOLO, notadamente o YOLOv10 \cite{wang2024yolov10realtimeendtoendobject}, optou-se deliberadamente pela utilização do YOLOv8s como base para implementação. Esta decisão fundamenta-se em considerações metodológicas relevantes para o contexto específico da pesquisa. Primeiramente, o YOLOv8 apresenta maturidade e estabilidade significativamente superiores, com extensa validação em diversos cenários aplicativos, enquanto o YOLOv10, publicado em 2024, ainda se encontra em fase inicial de adoção pela comunidade científica. Adicionalmente, os ganhos marginais de desempenho oferecidos pela versão mais recente não justificariam os custos de adaptação e as potenciais instabilidades de implementação, considerando os objetivos específicos e restrições temporais deste trabalho. O ecossistema de desenvolvimento consolidado em torno do YOLOv8, incluindo documentação abrangente, diversidade de modelos pré-treinados e ferramentas de otimização, também constituiu fator determinante para esta escolha metodológica.

\subsubsection{Configuração e Hiperparâmetros Críticos} \label{subsubsec:hiperparametros_yolo}

Para garantir desempenho ótimo no contexto específico de detecção de placas de trânsito no ambiente simulado CARLA, foram configurados os seguintes hiper parâmetros críticos do algoritmo YOLOv8:

\begin{enumerate}
    \item \textbf{IoU Threshold para NMS}: 0.45 - Este valor, ligeiramente inferior ao padrão de 0.5, foi selecionado para aumentar a precisão na detecção de placas parcialmente oclusas, permitindo a consideração de detecções sobrepostas quando apropriado;
    
    \item \textbf{Limiar de Confiança}: 0.25 - Estabelecido experimentalmente para equilibrar sensibilidade e precisão, permitindo detecção de placas a maiores distâncias sem gerar falsos positivos excessivos;
    
    \item \textbf{Imgsz (Tamanho de Entrada)}: 640 - Dimensão padronizada para processamento da imagem, otimizada para o modelo YOLOv8s, proporcionando equilíbrio entre resolução e eficiência computacional;
    
    \item \textbf{Batch Size}: 1 - Processamento de uma imagem por vez, otimizado para inferência em tempo real com restrição de latência;
    
    \item \textbf{Device}: 0 - Direcionamento do processamento para a primeira GPU disponível (quando aplicável), maximizando desempenho via aceleração por \textit{hardware}.
\end{enumerate}

A seleção destes hiper parâmetros foi realizada por meio de processo iterativo de experimentação no ambiente CARLA, avaliando o desempenho em termos de precisão, recall e FPS. Os valores selecionados representam o equilíbrio ótimo entre estes fatores para o cenário específico de detecção de placas de parada em ambiente urbano simulado.

Após o processamento neural, o resultado consiste em um conjunto de caixas delimitadoras, cada uma associada a uma classe específica e um valor de confiança, que serão utilizadas para o \textit{feedback} visual ao condutor. Os detalhes específicos da implementação deste algoritmo serão apresentados no Capítulo \ref{Implementação}.

\subsection{Arquitetura de Processamento em Tempo Real} \label{subsec:arquitetura_tempo_real}

A implementação de um sistema de percepção visual para VA requer arquiteturas computacionais robustas capazes de processar fluxos contínuos de imagens sob restrições temporais rigorosas. Conforme estabelecido no segundo objetivo específico (Seção \ref{objetivos_esp}), o sistema deve processar \textit{frames} de vídeo em tempo real, com taxa superior a 10 FPS, fornecendo \textit{feedback} visual instantâneo das detecções realizadas. Esta subseção estabelece os fundamentos teóricos das arquiteturas de processamento assíncrono desenvolvidas para satisfazer estes requisitos operacionais.

\subsubsection{Restrições Temporais em Sistemas Automotivos} \label{subsubsec:restricoes_temporais}

No contexto de sistemas automotivos, o conceito de “tempo real” refere-se à capacidade de processar informações e gerar respostas em prazos temporais predeterminados e críticos para a segurança \cite{kopetz2011real}. Esta definição alinha-se às arquiteturas de software para VA apresentadas na Seção \ref{ar_soft}, onde a responsividade temporal constitui requisito fundamental para módulos de percepção ambiental.

Para sistemas de detecção e reconhecimento de placas de trânsito, a literatura especializada estabelece requisitos temporais baseados na velocidade do veículo, distância de visibilidade e tempo necessário para resposta adequada \cite{janai_computer_vision_av}. Formalmente, o limite máximo aceitável para o tempo de resposta pode ser definido pela Equação \ref{eq:real_time_constraint}:

\begin{equation} \label{eq:real_time_constraint}
T_{response} \leq T_{deadline} - T_{safety\_margin}
\end{equation}

\begin{conditions}
    T_{response} & tempo total de resposta do sistema, desde a aquisição da imagem até a decisão; \\
    T_{deadline} & prazo máximo aceitável para a aplicação específica; \\
    T_{safety\_margin} & margem de segurança para compensar variabilidades do sistema.
\end{conditions}

Para detecção de placas de parada em ambiente urbano simulado com velocidades moderadas $(\leq 30$ km/h$)$, estabelecemos $T_{deadline} = 100$ ms e $T_{safety\_margin} = 20$ ms, resultando em requisito de $T_{response} \leq 80$ ms para o sistema completo, correspondendo a uma taxa mínima de 12,5 FPS. Este requisito temporal alinha-se diretamente ao objetivo específico de processamento em tempo real (>10 FPS) estabelecido na Seção \ref{objetivos_esp}.

\subsubsection{Modelos Arquiteturais para Processamento em Tempo Real} \label{subsubsec:modelos_arquiteturais}

Para satisfazer as restrições temporais estabelecidas, sistemas de percepção visual para VA geralmente adotam arquiteturas de processamento assíncrono baseadas no modelo produtor-consumidor. Este paradigma arquitetural, consistente com a decomposição modular que separa o processo de aquisição de imagens (produtor) do processo de análise e detecção (consumidor), operando em \textit{threads} paralelos que se comunicam via estruturas de dados sincronizadas como filas \cite{kato2015open}.

Formalmente, o modelo assíncrono pode ser representado conforme a Equação \ref{eq:async_model}:

\begin{equation} \label{eq:async_model}
\mathcal{P}(t) \rightarrow \mathcal{Q} \rightarrow \mathcal{C}(t + \Delta t)
\end{equation}

\begin{conditions}
    \mathcal{P}(t) & processo produtor (aquisição de \textit{frames}) no tempo $t$; \\
    \mathcal{Q} & fila intermediária com capacidade máxima $N$; \\
    \mathcal{C}(t + \Delta t) & processo consumidor (inferência YOLO) com atraso $\Delta t$.
\end{conditions}

Esta abordagem arquitetural incorpora três mecanismos fundamentais para garantir operação em tempo real \cite{kato2015open}:

\begin{enumerate}
    \item \textbf{Processamento paralelo:} a separação entre aquisição de \textit{frames} e inferência em \textit{threads} distintos permite sobreposição temporal de operações, maximizando a taxa de \textit{throughput} do sistema;
    
    \item \textbf{\textit{Buffering} controlado:} a fila intermediária com tamanho limitado evita consumo excessivo de memória enquanto proporciona elasticidade para acomodar variações temporárias na velocidade de processamento;
    
    \item \textbf{Controle adaptativo de taxa:} o sistema implementa mecanismos para ajustar dinamicamente a taxa de processamento via \textit{frame skipping} ou variação dinâmica de resolução, garantindo resposta em tempo hábil mesmo em condições de alta carga computacional.
\end{enumerate}

A eficácia deste modelo depende criticamente da calibração adequada de parâmetros-chave, particularmente a dimensão da fila $N$ e a prioridade relativa dos \textit{threads} produtor e consumidor. Um valor de $N$ muito pequeno pode resultar em subutilização do processador quando o produtor supera momentaneamente o consumidor, enquanto um valor excessivamente grande pode introduzir latência inaceitável no sistema. 

\subsubsection{Arquitetura Distribuída para Sistemas de Percepção Visual} \label{subsubsec:arquitetura_distribuida}

A implementação eficiente do algoritmo YOLOv8, discutido na Seção \ref{yolo_section}, no contexto da arquitetura modular proposta na Figura \ref{Arquitetura_soft_autor}, frequentemente enfrenta limitações técnicas relacionadas à compatibilidade entre diferentes componentes de \textit{software} e \textit{hardware}. No presente trabalho, identificou-se um desafio de integração entre o simulador CARLA, que opera com Python 3.6, e as implementações otimizadas do YOLOv8, que exigem Python 3.12 e bibliotecas recentes para aceleração por GPU \cite{wang2024yolov10realtimeendtoendobject}.

Para superar esta limitação, adotou-se uma arquitetura distribuída baseada no modelo cliente-servidor, fundamentada em princípios da teoria de sistemas distribuídos \cite{iordache2021smart}. Esta abordagem permite desacoplar o componente de detecção de objetos do sistema principal, possibilitando que cada componente opere em seu ambiente otimizado sem comprometer a funcionalidade integrada, conforme ilustrado na Figura \ref{fig:distributed_architecture}.

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{Figures/arquitetura_distribuida.pdf}
\caption{Arquitetura distribuída do sistema de percepção visual. O componente cliente integrado ao CARLA (Python 3.6) captura e transmite \textit{frames} de vídeo via \textit{socket} TCP/IP para o servidor de detecção (Python 3.12), que executa o algoritmo YOLOv8 com aceleração GPU e retorna os resultados serializados. Esta separação permite otimização independente de cada componente enquanto mantém comunicação em tempo real (Elaborado pelo autor).}
\label{fig:distributed_architecture}
\end{figure}

A comunicação entre os componentes distribuídos fundamenta-se no conceito de passagem de mensagens síncronas com semântica de invocação remota. Formalmente, o modelo de comunicação implementa uma variante do padrão \textit{Request-Reply}, onde:

\begin{equation} \label{eq:distributed_communication}
C(t) \xrightarrow{request(frame)} S(t) \xrightarrow{process(frame)} S(t+\Delta t) \xrightarrow{reply(detections)} C(t+\Delta t+\delta)
\end{equation}

\begin{conditions}
    C(t) & cliente no tempo $t$; \\
    S(t) & servidor no tempo $t$; \\
    \Delta t & tempo de processamento do \textit{frame} pelo algoritmo YOLO; \\
    \delta & latência de comunicação na rede;
\end{conditions}

Esta arquitetura distribuída introduz desafios específicos que precisam ser tratados para garantir operação em tempo real \cite{kopetz2011real}:

\begin{enumerate}
    \item \textbf{Serialização eficiente:} a transferência de \textit{frames} de vídeo e resultados de detecção exige serialização otimizada para minimizar latência. Adotou-se o protocolo MessagePack combinado com compressão NumPy específica para \textit{arrays}, garantindo \textit{overhead} mínimo na transmissão;
    
    \item \textbf{Tolerância a falhas de conexão:} o sistema incorpora mecanismos de reconexão automática com retentativas exponenciais para manter a operacionalidade mesmo em condições de instabilidade de rede;
    
    \item \textbf{Gerenciamento de recursos computacionais:} o servidor de detecção implementa gerenciamento dinâmico de memória GPU, liberando recursos quando não utilizados e realizando pré-carregamento adaptativo de modelos conforme carga operacional;
    
    \item \textbf{Consistência temporal:} o sistema implementa \textit{timestamping} de mensagens e descarte seletivo de resultados excessivamente atrasados para garantir que as detecções permaneçam temporalmente relevantes para o estado atual do veículo.
\end{enumerate}

%Esta arquitetura distribuída representa uma solução robusta para integração de componentes tecnologicamente heterogêneos, permitindo utilizar implementações \textit{state-of-the-art} do YOLOv8 com aceleração GPU completa, mesmo em ambientes com restrições de compatibilidade como o simulador CARLA. A separação de responsabilidades entre cliente e servidor facilita ainda atualizações independentes de cada componente, aumentando a manutenibilidade e extensibilidade do sistema.

Embora a arquitetura cliente-servidor apresente vantagens significativas para o cenário de implementação atual, é importante reconhecer suas limitações inerentes. O modelo de comunicação baseado em Sockets TCP/IP introduz latência sistêmica devido ao \textit{overhead} de rede, mesmo em configurações locais, criando um limite teórico para a taxa máxima de processamento atingível \cite{kato2015open}. Adicionalmente, a abordagem de requisição-resposta, embora robusta para o caso de uso atual com um único cliente, apresenta limitações de escalabilidade para cenários envolvendo múltiplos agentes ou sensores \cite{iordache2021smart}. Nestes casos, o servidor de detecção poderia se tornar um gargalo centralizado, comprometendo o desempenho geral do sistema.

A arquitetura distribuída adotada neste trabalho representa um compromisso pragmático que permite compatibilizar ambientes tecnologicamente heterogêneos enquanto mantém desempenho adequado para os objetivos estabelecidos na Seção \ref{objetivos_esp}. Para aplicações futuras envolvendo múltiplos agentes autônomos ou integração de diversos sensores, abordagens baseadas em memória compartilhada poderia proporcionar melhor desempenho e escalabilidade, conforme será discutido no Capítulo \ref{continuidade}. Em particular, tecnologias como ZeroMQ ou ROS (\textit{Robot Operating System}) representam alternativas promissoras para comunicação de menor latência em arquiteturas distribuídas mais complexas \cite{kato2015open}.

\subsubsection{Sistema de Feedback Visual para Assistência ao Condutor} \label{subsubsec:feedback_visual}

O terceiro componente fundamental do sistema de percepção visual proposto, consistente com a arquitetura apresentada na Figura \ref{fluxo_percepcao}, envolve a transformação de detecções brutas em informações acionáveis e contextualmente relevantes para o condutor. Conforme estabelecido na Hipótese \ref{hipotese}, a efetividade de sistemas de assistência à condução depende não somente da precisão na detecção de elementos viários, mas também da capacidade de comunicar estas informações claramente, não-intrusiva e temporalmente apropriada.

A arquitetura do sistema de \textit{feedback} visual implementa cinco princípios fundamentais estabelecidos na literatura de fatores humanos para interfaces automotivas \cite{endsley2016designing}:

\begin{enumerate}
    \item \textbf{Saliência proporcional ao risco:} elementos visuais apresentam saliência (tamanho, cor, contraste) proporcional ao nível de risco que representam. Objetos com maior potencial de risco (pedestres, veículos em rota de colisão) recebem tratamento visual mais proeminente que objetos de menor risco;
    
    \item \textbf{Codificação cromática consistente:} utilização de esquema cromático padronizado onde cores específicas comunicam consistentemente níveis de urgência (vermelho para alto risco, amarelo para atenção moderada, verde para informação);
    
    \item \textbf{Persistência contextual:} duração da apresentação visual adaptada à criticidade da informação e contexto operacional. Informações críticas de segurança (como detecção de pedestres) mantêm persistência visual superior à de informações auxiliares;
    
    \item \textbf{Degradação gradual:} em situações de sobrecarga informacional, o sistema prioriza informações conforme hierarquia de relevância para segurança, reduzindo gradualmente elementos não-críticos para preservar capacidade cognitiva do condutor;
    
    \item \textbf{Consistência posicional:} informações específicas são consistentemente apresentadas nas mesmas regiões da interface, reduzindo carga cognitiva associada à localização de informações.
\end{enumerate}

Este sistema de \textit{feedback} visual está diretamente integrado à arquitetura distribuída apresentada na Subseção \ref{subsubsec:arquitetura_distribuida}, recebendo os resultados de detecção processados pelo servidor YOLO e transformando-os em visualizações significativas para o condutor. Esta abordagem exemplifica a implementação concreta do fluxo da execução da solução ilustrado na Figura \ref{fluxo_percepcao}, onde cada componente executa uma função especializada enquanto mantém interfaces bem definidas com os demais elementos do sistema.

A implementação específica deste sistema de \textit{feedback}, incluindo elementos de interface, integração com o detector YOLO e mecanismos de filtragem temporal, será detalhada no Capítulo \ref{Implementação}, demonstrando como os princípios teóricos aqui estabelecidos são concretizados na solução proposta. Esta implementação constitui componente essencial para validação da Hipótese \ref{hipotese}, que propõe a capacidade do sistema de oferecer \textit{feedback} visual de placas de trânsito em tempo real para promoção de uma condução mais confiável.

\chapter{Implementação} \label{Implementação}

Este capítulo apresenta a implementação do sistema de assistência à condução baseado em detecção de objetos em tempo real, utilizando o simulador CARLA. O propósito central é demonstrar como os fundamentos teóricos discutidos nos capítulos anteriores, especificamente os Controladores \ref{modelagem_veiculos}, Planejamento de Movimento \ref{planejamento} e Percepção Visual \ref{per_visual_carro}, foram traduzidos em uma arquitetura modular e funcional.

A implementação segue os princípios de decomposição hierárquica das funções de condução autônoma, alinhando-se à taxonomia de automação veicular da SAE (\ref{levelcla}), com ênfase nos níveis 1-2 de automação, onde sistemas de assistência fornecem suporte ao condutor mediante a \textit{feedback} visual e alertas em tempo real.

\section{Ambiente de Validação Experimental} \label{sec:ambiente_validacao}

Para validação experimental, foi selecionada uma trajetória predefinida no mapa Town01 do simulador CARLA, conforme ilustrado na Figura \ref{trecho_circuito_carla}. Neste percurso, o marcador (\textbf{1}) denota o ponto inicial da trajetória, enquanto o marcador (\textbf{0}) representa o ponto final. A escolha deste ambiente controlado permite a avaliação sistemática das capacidades do sistema em condições padronizadas.

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{Figures/trajectory_onMap.png}
\caption{Trecho selecionado no Mapa Town01 do simulador CARLA para validação experimental \cite{dosovitskiy2017carla} (Modificado pelo Autor).}
\label{trecho_circuito_carla}
\end{figure}

\section{Estrutura do Projeto} \label{sec:estrutura_projeto}

A implementação foi organizada seguindo uma arquitetura modular que reflete a decomposição funcional da tarefa de condução apresentada na Seção \ref{componentes_da_tarefa_de_conducao}, com módulos especializados para percepção, planejamento e controle. A Figura \ref{project_structure} apresenta a estrutura do projeto, evidenciando a organização hierárquica dos componentes.

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{Figures/file_structure.png}
\caption{Estrutura modular do projeto implementado, evidenciando a decomposição funcional em subsistemas especializados e a arquitetura distribuída para processamento de percepção visual.}
\label{project_structure}
\end{figure}

Dessa forma, o sistema implementado compreende os seguintes módulos principais, organizados conforme as camadas funcionais:

\begin{itemize}
    \item \textbf{Módulos de Percepção:}
    \begin{itemize}
        \item \texttt{detector\_socket/detector\_server.py} – Implementa o servidor de detecção YOLO otimizado com GPU, seguindo os princípios descritos na Seção \ref{yolo_section}. Utiliza processamento paralelo para maximizar o desempenho.
        
        \item \texttt{detector\_socket/detector\_client.py} – Cliente que conecta o sistema de controle veicular com o serviço de detecção, transmitindo imagens comprimidas e recebendo resultados de detecção.
        
        \item \texttt{threaded\_detector.py} – Implementa o processamento assíncrono de detecção, garantindo resposta em tempo real.
    \end{itemize}
    
    \item \textbf{Módulos de Planejamento:}
    \begin{itemize}
        \item \texttt{behavioural\_planner.py}: implementa a máquina de estados finitos para planejamento comportamental, conforme descrito na Subseção \ref{subsec:planejamento_comportamental};
        \item \texttt{local\_planner.py}: responsável pela geração de trajetórias locais utilizando \textit{Conformal Lattice Planning}, alinhado com a teoria apresentada na Subseção \ref{subsec:planejamento_local};
        \item \texttt{path\_optimizer.py}: implementa a otimização de caminhos utilizando espirais paramétricas, conforme detalhado na Subseção \ref{otimizacao_caminho};
        \item \texttt{collision\_checker.py}: realiza a verificação de colisões utilizando a técnica de aproximação por círculos, conforme apresentado na Subseção \ref{verificacao_colisoes};
        \item \texttt{velocity\_planner.py}: gera perfis de velocidade para as trajetórias, seguindo os princípios estabelecidos na Subseção \ref{subsubsec:geracao_de_perfil_de_velocidade}.
    \end{itemize}
    
    \item \textbf{Módulos de Controle:}
    \begin{itemize}
        \item \texttt{controller2d.py} – Implementa controle longitudinal PID e controle lateral de perseguição pura, conforme teorias apresentadas nas Seções \ref{PID} e \ref{intro_controle_lateral}.
    \end{itemize}
    
    \item \textbf{Módulos de Análise de Desempenho:}
    \begin{itemize}
        \item \texttt{performance\_metrics.py} – Coleta e analisa métricas de desempenho em tempo real, incluindo tempos de detecção, precisão e taxa de quadros.
        
        \item \texttt{results\_reporter.py} – Gera relatórios detalhados e visualizações a partir das métricas coletadas.
    \end{itemize}
    
    \item \textbf{Arquivos de Configuração e Dados:}
    \begin{itemize}
        \item \texttt{waypoints.txt}: define a sequência ordenada de \textit{waypoints} que constitui a rota global, conforme discutido na Subseção \ref{subsubsec:representacao_grafo};
        \item \texttt{stop\_sign\_params.txt}: especifica a localização das placas de parada para implementação das cercas virtuais descritas na Subseção \ref{subsubsec:cercas_virtuais};
        \item \texttt{parked\_vehicle\_params.txt}: define a localização e dimensões de veículos estacionados que atuam como obstáculos estáticos descritos na Subseção \ref{subsubsec:cercas_virtuais}.
    \end{itemize}
\end{itemize}

A integração destes módulos estabelece um \textit{pipeline} completo que implementa o ciclo percepção-planejamento-ação característico de sistemas autônomos.

Destacamos que, visando à manutenção da transparência e oferecendo ao leitor a oportunidade de um aprofundamento técnico, todos os códigos, arquivos de configuração, códigos auxiliares e dados gerados durante a pesquisa foram organizados e disponibilizados em um repositório público, cujo link pode ser encontrado no Capítulo (\ref{apendices}) de Apêndices. Incentivamos fortemente que interessados em replicar, estender ou adaptar a solução, consultem o material completo acessível via o link: \url{https://github.com/ARRETdaniel/CARLA_simulator_YOLO-openCV_realTime_objectDetection_for_autonomousVehicles}.

\section{Configurando o Carla}
\label{configuracao_carla}

Nesta seção, apresentamos a configuração do simulador Carla utilizada para o desenvolvimento da solução proposta. Inicialmente, é necessário atender aos pré-requisitos descritos na documentação oficial do simulador \cite{University_of_Toronto2018-fe}. Todos os arquivos necessários encontram-se disponíveis no repositório da solução, conforme indicado nos Apêndices \ref{apendices}.

Para a execução e testes da solução, foram empregados dois ambientes computacionais distintos:

\begin{itemize}
    \item \textbf{Dell XPS 8960 (Linux)}: Este equipamento, disponibilizado pelo Laboratório P5 da Universidade Estadual do Norte Fluminense (UENF), possui as seguintes especificações:
    \begin{itemize}
        \item \textbf{Processador}: Intel Core i7-13700, com 16 núcleos (8 de desempenho e 8 de eficiência) e 24 threads, frequência base de 2.1 GHz e turbo de até 5.2 GHz;
        \item \textbf{Memória RAM}: 32 GB DDR5-4800 MHz, configurada em dois módulos de 16 GB cada, operando em modo dual-channel;
        \item \textbf{Armazenamento}: SSD NVMe PCIe de 1 TB;
        \item \textbf{Placa de Vídeo}: NVIDIA GeForce RTX 4060 com 8 GB de memória GDDR6;
        \item \textbf{Sistema Operacional}: Distribuição Linux compatível com o simulador Carla.
    \end{itemize}
    
    \item \textbf{Lenovo Legion 5i 82CF0002BR (Windows)}: Este notebook, pertencente ao pesquisador responsável por este trabalho, apresenta as seguintes configurações:
    \begin{itemize}
        \item \textbf{Processador}: Intel Core i7-10750H (10ª geração), com 6 núcleos e 12 threads, frequência base de 2.6 GHz e turbo de até 5.0 GHz;
        \item \textbf{Memória RAM}: 16 GB DDR4-2933 MHz;
        \item \textbf{Armazenamento}: SSD NVMe PCIe de 512 GB;
        \item \textbf{Placa de Vídeo}: NVIDIA GeForce RTX 2060 com 6 GB de memória GDDR6;
        \item \textbf{Sistema Operacional}: Windows 11 Home.
    \end{itemize}
\end{itemize}

\subsubsubsection*{Pré-requisitos}
%\subsubsubsubsection*{Hardware}
\textbf{Especificações de Hardware recomendadas:}
\begin{itemize}
  \item Processador Intel ou AMD quad-core, 2.5 GHz ou mais rápido
  \item NVIDIA GeForce 470 GTX ou AMD Radeon 6870 HD series ou superior
  \item 8 GB de RAM
  \item Aproximadamente 10GB de espaço em disco para a configuração do simulador
\end{itemize}

\textbf{Nota:} Computadores com especificações inferiores, incluindo sistemas com gráficos integrados, também podem executar o simulador CARLA, embora com desempenho reduzido.

%\subsubsubsubsection*{Software}
\textbf{Especificações de Software:}

\textbf{Windows/Ubuntu:}
 CARLA requer Windows 7 64-bit ou Ubuntu 16.04 (ou superior).
\textbf{Firewall:}
 Foi necessário habilitar a rede e permitir o acesso do firewall ao carregador do CARLA e, por padrão, às portas 2000, 2001 e 2002 (TCP e UDP).

\textbf{Drivers da Placa Gráfica:}
Atualizamos os drivers mais recentes para evitar problemas gráficos. No caso, OpenGL 3.3 ou superior e DirectX 10 como recomendado.

\textbf{Python:}
\begin{itemize}
  \item Foi instalado Python 3.6.0 com $\textit{pip}$. O cliente Python do CARLA funciona com Python 3.5.x ou Python 3.6.x.
  \item Segundo o autor, Python 3.7 atualmente não é compatível.
  \end{itemize}

\subsubsubsection*{Preparando o Simulador CARLA}
\textbf{Baixando e extraindo o Simulador CARLA}
\begin{enumerate}
  \item Baixamos o simulador CARLA (\texttt{CarlaUE4Windows.zip}), o qual pode ser encontrado no capítulo \ref{apendices} (apêndice) deste trabalho. 
  \item Extraímos o conteúdo do \texttt{CarlaUE4Windows.zip}. A extração criou uma pasta chamada \texttt{CarlaSimulator} no diretório de trabalho, que hospeda os arquivos do servidor e cliente CARLA necessários para os projetos. O guia disponibilizado pelo autor \cite{University_of_Toronto2018-fe} assume que o simulador é extraído para \texttt{C:\textbackslash Coursera\textbackslash CarlaSimulator}. \end{enumerate}

\textbf{Instalação de Dependências Python para o Cliente}
As dependências adicionais necessárias para os arquivos do cliente do Simulador CARLA estão detalhadas no arquivo: \texttt{C:\textbackslash Coursera\textbackslash CarlaSimulator\textbackslash requirements.txt.}

Foi executado o seguinte comando para instalar as dependências para o usuário atual: 
\begin{verbatim}> python -m pip install -r C:\Coursera\CarlaSimulator\requirements.txt 
--user[^2^][2]
\end{verbatim}
%De modo a solucionar os erros que ocorreram durante essa instalação, recorremos ao material do Apêndice \ref{apendices}.
%Agora com tudo propriamente instalado, fizemos \textit{download} do projeto nomeado de \textit{Project}, disponibilizado pelo autor \cite{University_of_Toronto2018-fe}, na pasta \textit{PythonClient} da seguinte forma: \textit{PythonClient\textbackslash Project}. Esse mesmo \textit{Project} pode ser encontrado no material complementar do capítulo \ref{apendices}. %A partir disso, iniciamos as nossas implementações do controlador no arquivo \textit{controller2d.py}.
Para mais detalhes e instruções completas para a instalação, ou se houver problemas ao instalar essas dependências do simulador CARLA, consulte o material do capítulo \ref{apendices}. Salientamos que os binários do CARLA utilizados nesta pesquisa são uma versão modificada pelo autor \cite{University_of_Toronto2018-fe} do CARLA original, com mapas adicionais incluídos.

\section{Módulo de Controle} \label{controladores_imple}

O módulo de controle representa a camada final da arquitetura hierárquica de três níveis, conforme apresentado na Figura \ref{Arquitetura_soft_autor}, constituindo a interface entre o planejamento de trajetórias e a atuação física no ambiente simulado. Este módulo implementa os conceitos teóricos fundamentais estabelecidos na Seção \ref{modelagem_veiculos}, concretizando as estratégias de controle longitudinal e lateral necessárias para a execução precisa das trajetórias definidas pelo módulo de planejamento.

A implementação do controlador segue uma estrutura modular que reflete a decomposição funcional proposta na Figura \ref{controlador}, com separação explícita entre controle longitudinal (baseado em algoritmos PID) e controle lateral (implementado via estratégia de perseguição pura). Esta estrutura permite gerenciar a complexidade do sistema e facilita o desenvolvimento e ajuste independente de cada componente.

\subsection{Estrutura Geral do Controlador}

O módulo de controle foi implementado na classe \texttt{Controller2D}, localizada no arquivo \texttt{controller2d.py}. Esta classe encapsula toda a lógica necessária para transformar as trajetórias de referência, geradas pelo planejador de movimento, em comandos de controle para acelerador, freio e direção que são enviados ao simulador CARLA.

O Trecho de Código \ref{lst:controller-init} apresenta o construtor da classe, onde são inicializados os parâmetros fundamentais e as estruturas de dados necessárias para o funcionamento do controlador.

Os parâmetros inicializados no construtor incluem:

\begin{itemize}
    \item \texttt{\_lookahead\_distance}: distância de previsão para o algoritmo de perseguição pura, estabelecida em 2.0 metros conforme as recomendações teóricas discutidas na Subseção \ref{intro_controle_lateral};
    \item \texttt{\_waypoints}: conjunto de pontos de referência que definem a trajetória a ser seguida pelo veículo com mestra estrutura dos \textit{waypoints} do Trecho de Código \ref{lst:waypoints-estrutura};
    \item \texttt{\_conv\_rad\_to\_steer}: fator de conversão entre o ângulo de direção calculado (em radianos) e o comando de direção normalizado (-1 a 1) esperado pelo simulador.
\end{itemize}

O método \texttt{update\_values}, apresentado no Trecho de Código \ref{lst:controller-update}, é responsável por atualizar o estado interno do controlador com os dados mais recentes recebidos do simulador, incluindo posição, orientação, velocidade e tempo atual.

Esta função representa a interface de entrada do controlador, responsável pela aquisição dos dados sensoriais que serão utilizados nos algoritmos de controle, estabelecendo uma ponte direta com o conceito de retroalimentação discutido na Subseção \ref{PID}, onde o estado atual é continuamente comparado com o estado desejado para geração dos sinais de controle apropriados.

\subsection{Implementação do Controle Longitudinal} \label{subsec:PID_implementation}

O controle longitudinal implementa a estratégia PID descrita na Subseção \ref{PID}, responsável por regular a velocidade do veículo conforme o perfil definido pelo planejador. A implementação, apresentada no Trecho de Código \ref{lst:longitudinal-control}, segue fielmente a formulação matemática da Equação \ref{PID_ed}.

Os parâmetros do controlador PID ($K_p = 0.50$, $K_i = 0.30$, $K_d = 0.13$) foram cuidadosamente ajustados para garantir resposta estável e eficiente, considerando as características dinâmicas do veículo simulado. Destaca-se a implementação da limitação \textit{anti-windup} no termo integral, conforme discutido na Subseção \ref{PID}, que previne a saturação do controlador em situações de erro persistente.

A implementação segue diretamente a formulação matemática da Equação \ref{laprace_pid_eq}, onde:

\begin{itemize}
    \item O termo proporcional é representado por \texttt{self.vars.kp * self.vars.v\_error};
    \item O termo integral é implementado como \texttt{self.vars.ki * self.vars.v\_error\_integral};
    \item O termo derivativo é calculado como \texttt{self.vars.kd * v\_error\_rate\_of\_change}.
\end{itemize}

O resultado, \texttt{throttle\_output}, corresponde ao comando de aceleração que será aplicado ao veículo.

\subsection{Implementação do Controle Lateral} \label{subsec:pure_pursuit-implementaion}

O controle lateral implementa o algoritmo de Perseguição Pura conforme apresentado na Subseção \ref{intro_controle_lateral}, responsável por manter o veículo na trajetória planejada. O Trecho de Código \ref{lst:lateral-control} apresenta a implementação deste algoritmo.

Esta implementação segue o modelo matemático apresentado na Subseção \ref{intro_controle_lateral}, calculando o ângulo de direção como função do erro lateral (\texttt{crosstrack\_error}) e do erro de orientação (\texttt{heading\_error}). O algoritmo pode ser dividido em quatro etapas principais:

\begin{enumerate}
    \item Determinação do ponto alvo: utilizando o método \texttt{get\_lookahead\_index} para encontrar o ponto da trajetória que está a uma distância \texttt{\_lookahead\_distance} do veículo;
    
    \item Cálculo do erro lateral: determinando a distância perpendicular entre o veículo e a trajetória desejada;
    
    \item Cálculo do erro de orientação: comparando a orientação atual do veículo com a direção da trajetória no ponto alvo;
    
    \item Geração do comando de direção: aplicando a fórmula do controlador de perseguição pura para calcular o ângulo de direção necessário.
\end{enumerate}

O método \texttt{get\_lookahead\_index}, apresentado no Trecho de Código \ref{lst:lookahead-method}, implementa a lógica para determinar o ponto de referência a uma distância especificada à frente do veículo, conforme requerido pelo algoritmo de perseguição pura.

Este método implementa um algoritmo de busca em duas etapas:

\begin{enumerate}
    \item Encontra o ponto mais próximo da trajetória em relação à posição atual do veículo;
    \item A partir deste ponto, avança ao longo da trajetória até que a distância acumulada seja maior ou igual à distância de lookahead especificada.
\end{enumerate}

A abordagem utilizada corresponde diretamente à definição do ponto alvo no algoritmo de perseguição pura, conforme apresentado na Subseção \ref{intro_controle_lateral}, garantindo que o veículo sempre direcione sua atenção para um ponto que está a uma distância consistente no futuro da trajetória.

\subsection{Integração e Envio de Comandos}

Após o cálculo dos sinais de controle longitudinal e lateral, é necessário integrá-los e convertê-los para o formato esperado pelo simulador CARLA. O Trecho de Código \ref{lst:command-setting} apresenta os métodos responsáveis por esta conversão.

Estes métodos implementam a interface de saída do controlador, garantindo que os comandos gerados estejam dentro dos limites aceitáveis pelo simulador CARLA. Destaca-se a conversão do ângulo de direção de radianos para o formato normalizado (-1 a 1) esperado pelo simulador, utilizando o fator de conversão \texttt{\_conv\_rad\_to\_steer}.

O método \texttt{get\_commands} fornece a interface unificada para obtenção dos comandos de controle (acelerador, direção e freio) que serão enviados ao simulador. Esta abordagem encapsula a complexidade interna do controlador, oferecendo uma interface simples e consistente para o módulo principal do sistema.

\subsection{Método Principal de Atualização}

O ponto central do controlador é o método \texttt{update\_controls}, apresentado no Trecho de Código \ref{lst:update-controls}, que orquestra a execução de todos os componentes discutidos anteriormente, reunindo-os em um fluxo coerente de processamento.

Este método implementa o ciclo completo de controle, que pode ser dividido em quatro etapas principais:

\begin{enumerate}
    \item Obtenção dos dados atuais do simulador: posição, orientação, velocidade e tempo;
    \item Execução dos algoritmos de controle longitudinal (PID) e lateral (perseguição pura);
    \item Definição dos comandos de controle a serem enviados ao simulador;
    \item Armazenamento dos valores atuais para utilização no próximo ciclo de controle.
\end{enumerate}

O fluxo implementado segue rigorosamente a arquitetura de controle de malha fechada discutida na Subseção \ref{PID}, onde o estado atual do sistema é continuamente comparado com o estado desejado, e os comandos de controle são ajustados para minimizar esta diferença.

\subsection{Calibração e Ajuste de Parâmetros}

A eficácia do sistema de controle depende criticamente da calibração adequada dos parâmetros dos controladores. Os valores utilizados na implementação foram determinados através de processo iterativo de ajuste, considerando critérios de desempenho como tempo de resposta, estabilidade e robustez a perturbações.

Os parâmetros do controlador PID longitudinal foram ajustados para garantir:

\begin{itemize}
    \item Resposta rápida a mudanças na velocidade desejada;
    \item Minimização do erro em regime permanente;
    \item Evitar oscilações excessivas durante transições de velocidade.
\end{itemize}

Para o controlador lateral de perseguição pura, o parâmetro crítico é a distância de lookahead (\texttt{\_lookahead\_distance}), definida como 2.0 metros. Este valor foi selecionado considerando:

\begin{itemize}
    \item A velocidade de operação típica do veículo no ambiente simulado;
    \item O compromisso entre precisão de seguimento (favorecida por valores menores) e suavidade de movimento (favorecida por valores maiores);
    \item As características geométricas da trajetória, incluindo curvaturas típicas encontradas no cenário urbano simulado.
\end{itemize}

A calibração destes parâmetros foi realizada no ambiente CARLA, utilizando o cenário específico descrito na Seção \ref{configuracao_carla}, garantindo assim que o controlador esteja otimizado para as condições operacionais do experimento.

\subsection{Integração com o Sistema Completo}

O módulo de controle integra-se ao sistema completo através da arquitetura cliente-servidor do CARLA, conforme apresentado na Subseção \ref{subsubsec:simulador_carla}. O Trecho de Código \ref{lst:system-integration} ilustra esta integração, mostrando como os comandos gerados pelo controlador são enviados ao simulador.

Esta função, localizada no módulo principal (\texttt{module\_7.py}), recebe os comandos de controle gerados pelo controlador e os encapsula no formato esperado pela API do CARLA, realizando verificações adicionais para garantir que os valores estejam dentro dos limites aceitáveis.

A chamada a esta função ocorre no loop principal do sistema, como parte do ciclo de execução que inclui percepção, planejamento e controle:

\begin{lstlisting}[language=Python, caption=Ciclo principal do sistema com atualização do controlador., label=lst:main-loop]
# Atualiza o controlador com informações atuais
controller.update_values(current_x, current_y, current_yaw,
                        current_speed, current_timestamp, frame)
controller.update_controls()
cmd_throttle, cmd_steer, cmd_brake = controller.get_commands()

# Envia comandos ao simulador
send_control_command(client, throttle=cmd_throttle, 
                    steer=cmd_steer, brake=cmd_brake)
\end{lstlisting}

Esta implementação demonstra a integração completa do módulo de controle na arquitetura de três camadas apresentada na Figura \ref{Arquitetura_soft_autor}, onde:

\begin{enumerate}
    \item Os dados de estado são recebidos do simulador CARLA;
    \item As informações de trajetória desejada são obtidas do módulo de planejamento;
    \item O controlador calcula os comandos apropriados com base nestes dados;
    \item Os comandos são enviados de volta ao simulador para execução.
\end{enumerate}

Este fluxo circular representa a materialização da estratégia de controle de malha fechada, fundamental para sistemas autônomos robustos e responsivos, conforme discutido na Seção \ref{modelagem_veiculos}.

\subsection{Considerações Finais sobre o Módulo de Controle}

O módulo de controle implementado representa a concretização dos conceitos teóricos apresentados na Seção \ref{modelagem_veiculos}, traduzindo os princípios matemáticos de modelagem cinemática e controle veicular em código executável capaz de interagir com o ambiente simulado CARLA.

A decomposição do problema de controle em componentes longitudinal e lateral, cada um com estratégias específicas (PID e perseguição pura, respectivamente), demonstra a aplicação prática da abordagem modular.

Esta implementação fornece as capacidades necessárias para o veículo simular comportamentos autônomos, seguindo trajetórias definidas e reagindo apropriadamente a eventos do ambiente, como a presença de placas de parada. Esta resposta, implementada em conjunto com o módulo de planejamento (Seção \ref{implementacao_planejamento}), demonstra a integração horizontal entre os diferentes componentes do sistema, essencial para o funcionamento coeso do VA simulado.

A eficácia dessas implementações serão avaliadas através dos resultados experimentais apresentados no Capítulo \ref{resultados}, onde métricas quantitativas de desempenho permitirão verificar o cumprimento dos objetivos específicos estabelecidos na Seção \ref{objetivos_esp}.

\section{Módulo de Planejamento} \label{implementacao_planejamento}

O módulo de planejamento de movimento constitui um componente essencial do sistema proposto, sendo responsável pela transformação de informações perceptuais em trajetórias seguras e eficientes para o veículo. Conforme estabelecido na Seção \ref{planejamento}, este módulo implementa uma arquitetura hierárquica de três níveis: planejamento de missão, planejamento comportamental e planejamento local. Esta seção detalha a implementação computacional destes componentes, demonstrando a materialização dos conceitos teóricos apresentados anteriormente, seguindo a estrutura e organização do projeto descrita na Seção \ref{sec:estrutura_projeto}.

\subsection{Planejamento de Missão} \label{subsec:implementacao_missao}

Conforme estabelecido na Subseção \ref{subsec:planejamento_de_missao}, o planejamento de missão no sistema proposto utiliza uma abordagem baseada em \textit{waypoints} predefinidos. A implementação deste componente é realizada através da leitura e processamento do arquivo \texttt{waypoints.txt}, que contém coordenadas tridimensionais $(x, y, v)$, onde $x$ e $y$ representam posições no plano cartesiano e $v$ especifica a velocidade desejada em cada ponto, conforme exemplificado no Trecho de Código \ref{lst:waypoints-estrutura}.

A função \texttt{get\_closest\_index()} implementa o algoritmo fundamental para determinação do \textit{waypoint} mais próximo à posição atual do veículo, conforme descrito no Pseudocódigo \ref{lst:closest_waypoint_algorithm}. Esta função é implementada no arquivo \texttt{behavioural\_planner.py}, como demonstrado no Trecho de Código \ref{lst:closest_index_implementation}.

Esta implementação realiza uma busca linear através de todos os \textit{waypoints}, calculando a distância euclidiana entre cada ponto e a posição atual do veículo, retornando o índice do ponto mais próximo e sua distância correspondente.

Complementarmente, o método \texttt{get\_goal\_index()} da classe \texttt{BehaviouralPlanner} do Trecho de Código \ref{lst:get_goal_index_implementation} implementa a lógica para identificação de um \textit{waypoint} objetivo a uma distância predefinida à frente na sequência, similarmente à técnica empregada no controlador de perseguição pura descrito na Subseção \ref{pure_persuit}.

Este método implementa a estratégia de navegação por horizonte de antecipação (\textit{lookahead distance}), acumulando a distância ao longo da trajetória até encontrar um ponto que satisfaça o requisito de distância mínima, permitindo antecipar curvas e variações de velocidade, adaptando o comportamento do veículo proativamente.

\subsection{Planejamento Comportamental} \label{subsec:implementacao_comportamental}

O planejamento comportamental, conforme estabelecido na Seção \ref{subsec:planejamento_comportamental}, é implementado por meio de uma FSM que traduz a rota global em sequências de manobras de alto nível. Esta implementação está centralizada na classe \texttt{BehaviouralPlanner}, definida no arquivo \texttt{behavioural\_planner.py}.

A FSM implementa os três estados fundamentais definidos na Subseção \ref{subsubsec:FSM}: \texttt{FOLLOW\_LANE}, \texttt{DECELERATE\_TO\_STOP} e \texttt{STAY\_STOPPED}, representados como constantes enumeradas, conforme o Trecho de Código \ref{lst:fsm_states_definition}:

\begin{lstlisting}[language=Python, caption=Definição dos estados da FSM., label=lst:fsm_states_definition]
# Define os estados da Máquina de Estados Finitos
FOLLOW_LANE = 0       # Estado para seguimento normal de faixa
DECELERATE_TO_STOP = 1 # Estado para desaceleração controlada até parada
STAY_STOPPED = 2      # Estado para manutenção da posição de parada

# Define o limiar de velocidade para considerar o veículo como parado (m/s)
STOP_THRESHOLD = 0.02

# Define o número de ciclos de controle que o veículo deve permanecer
# parado antes de retomar o movimento (implementa o tempo de parada)
STOP_COUNTS = 10
\end{lstlisting}

O método \texttt{transition\_state()} do Trecho de Código \ref{lst:transition_state_implementation} implementa a função de transição da FSM, conforme teorizado na Subseção \ref{subsubsec:FSM}, avaliando condições cinemáticas, ambientais e temporais para determinar transições entre estados.

A implementação das cercas virtuais para sinalização de tráfego, conforme discutido na Subseção \ref{subsubsec:cercas_virtuais}, é realizada através do método \texttt{check\_for\_stop\_signs()} do Trecho de Código \ref{lst:check_stop_signs_implementation}, que verifica a interseção entre a trajetória planejada e segmentos de linha perpendiculares à direção da via, posicionados nos pontos especificados no arquivo \texttt{stop\_sign\_params.txt}, conforme o formato apresentado no Trecho de Código \ref{lst:stop_sign_params}.

Este método implementa um algoritmo de verificação de interseção de segmentos de linha baseado em produtos vetoriais, calculando eficientemente se a trajetória planejada cruza alguma das cercas virtuais definidas. Quando uma interseção é detectada, o método retorna um novo índice objetivo (anterior ao ponto de interseção) e um sinalizador indicando que uma placa de parada foi encontrada, desencadeando a transição para o estado \texttt{DECELERATE\_TO\_STOP} na FSM.

\subsection{Planejamento Local} \label{subsec:implementacao_local}

O planejamento local, conforme descrito na Seção \ref{subsec:planejamento_local}, é responsável pela geração de trajetórias detalhadas que satisfazem as restrições cinemáticas do veículo. Esta implementação está centralizada na classe \texttt{LocalPlanner}, definida no arquivo \texttt{local\_planner.py}, que coordena os componentes de otimização de caminho, verificação de colisões e planejamento de velocidade.

A classe \texttt{LocalPlanner} implementa o \textit{Conformal Lattice Planner} descrito na Subseção \ref{conformal_lattice_planners}, gerando um conjunto de estados-objetivo lateralmente deslocados em relação ao caminho central, conforme o Trecho de Código \ref{lst:get_goal_state_set_implementation}.

Este método implementa a transformação de coordenadas do referencial global para o referencial local do veículo, gerando múltiplos estados-objetivo lateralmente deslocados que permitem ao veículo explorar diferentes posições na faixa, conforme ilustrado na Figura \ref{conformal_lattice}.

A otimização de caminhos utilizando espirais paramétricas, conforme detalhado na Subseção \ref{otimizacao_caminho}, é implementada na classe \texttt{PathOptimizer} no arquivo \texttt{path\_optimizer.py}. O método \texttt{optimize\_spiral()} do Trecho de Código \ref{lst:optimize_spiral_implementation} implementa o processo de otimização descrito, utilizando o algoritmo L-BFGS-B para minimizar uma função objetivo que considera erro na posição final, erro na orientação final e energia de curvatura.

A implementação da equação de curvatura da espiral cúbica (Equação \ref{kappas}) e a integração para obtenção dos pontos da espiral são realizadas no método \texttt{sample\_spiral()}, conforme o Trecho de Código \ref{lst:sample_spiral_implementation}.

O método \texttt{thetaf()} do Trecho de Código \ref{lst:thetaf_implementation} implementa a Equação \ref{thetaf}, calculando os valores de orientação ao longo da espiral a partir dos coeficientes da equação de curvatura.

A verificação de colisões, conforme descrita na Subseção \ref{verificacao_colisoes}, é implementada na classe \texttt{CollisionChecker} no arquivo \texttt{collision\_checker.py}. O método \texttt{collision\_check()} do Trecho de Código \ref{lst:collision_check_implementation} implementa a aproximação do veículo por círculos, conforme ilustrado na Figura \ref{collision_circles}.

Este método verifica se qualquer um dos círculos que aproximam o veículo intersecta algum dos obstáculos, retornando um \textit{array} de valores booleanos que indica se cada caminho candidato está livre de colisões. Os obstáculos são definidos no arquivo \texttt{parked\_vehicle\_params.txt}, que especifica a localização e dimensões de veículos estacionados, conforme o formato apresentado no Trecho de Código \ref{lst:parked_vehicle_params}.

Complementarmente, o método \texttt{select\_best\_path\_index()} do Trecho de Código \ref{lst:select_best_path_implementation} implementa a lógica para seleção do caminho ótimo entre os candidatos classificados como seguros, considerando proximidade à linha central da faixa e margem de segurança em relação a caminhos em colisão.

\subsection{Geração de Perfil de Velocidade} \label{subsec:implementacao_velocidade}

A geração de perfis de velocidade, conforme detalhado na Subseção \ref{subsubsec:geracao_de_perfil_de_velocidade}, é implementada na classe \texttt{VelocityPlanner} no arquivo \texttt{velocity\_planner.py}. Esta classe implementa os três tipos fundamentais de perfis de velocidade descritos na Subseção \ref{subsubsec:classificao_perfil}: perfil nominal, perfil de desaceleração para parada e perfil de seguimento de veículo.

O método \texttt{compute\_velocity\_profile()} do Trecho de Código \ref{lst:compute_velocity_profile_implementation} implementa a hierarquia decisória que seleciona o perfil de velocidade apropriado em cada ciclo de planejamento.

O método \texttt{decelerate\_profile()} do Trecho de Código \ref{lst:decelerate_profile_implementation} implementa o perfil de desaceleração para parada, aplicando uma estrutura trapezoidal caracterizada por três fases, conforme descrito na Subseção \ref{subsubsec:classificao_perfil}.

As funções utilitárias \texttt{calc\_distance()} e \texttt{calc\_final\_speed()} do Trecho de Código \ref{lst:velocity_utility_functions} implementam as Equações \ref{eq:calculo_distancia} e \ref{eq:velocidade_final_completa}, respectivamente.

Estas funções fundamentam-se nas equações do movimento uniformemente variado, estabelecendo a base matemática para o cálculo de perfis de velocidade que satisfazem as restrições de aceleração e desaceleração do veículo.

\subsection{Integração dos Componentes} \label{subsec:integracao_componentes}

A integração dos componentes de planejamento hierárquico é realizada no arquivo \texttt{module\_7.py}, que funciona como ponto de entrada para o sistema completo. Este módulo coordena a interação entre o planejamento de missão, comportamental e local, bem como a interface com o simulador CARLA e os módulos de percepção e controle.

A inicialização dos componentes de planejamento é realizada com parâmetros específicos que refletem as características operacionais desejadas, conforme o Trecho de Código \ref{lst:planning_initialization}.

O ciclo principal de planejamento implementa o fluxo completo do processo de planejamento hierárquico, desde a atualização do estado do veículo até a geração da trajetória final, conforme o Trecho de Código \ref{lst:planning_main_loop}.

Este ciclo de planejamento integra todos os componentes hierárquicos em um fluxo coerente, desde a determinação do estado comportamental até a geração da trajetória espaço-temporal completa, demonstrando a materialização prática da arquitetura teórica apresentada na Seção \ref{planejamento}.

\section{Módulo de Percepção} \label{implementacao_yolo}

O módulo de percepção constitui o componente fundamental da primeira camada na arquitetura hierárquica de três camadas apresentada na Figura \ref{Arquitetura_soft_autor}, sendo responsável pela detecção e classificação de objetos em tempo real no ambiente simulado. Esta seção detalha a implementação computacional dos conceitos teóricos apresentados na Seção \ref{per_visual_carro}, demonstrando a materialização prática dos algoritmos YOLO para assistência à condução em VA.

\subsection{Arquitetura Distribuída Cliente-Servidor} \label{subsec:implementacao_arquitetura_distribuida}

Conforme discutido na Subseção \ref{subsubsec:arquitetura_distribuida}, a implementação do sistema de percepção adotou uma arquitetura distribuída cliente-servidor para superar as limitações de compatibilidade entre o CARLA (Python 3.6) e o YOLOv8 (Python 3.12). Esta solução, fundamentada no modelo de comunicação da Equação \ref{eq:distributed_communication}, foi implementada via dois componentes principais: um cliente de detecção no ambiente Python 3.6 e um servidor de detecção executando em Python 3.12.

O sistema de detecção distribuído utiliza \textit{sockets} TCP/IP para comunicação, conforme ilustrado na Figura \ref{fig:distributed_architecture}. O Trecho de Código \ref{lst:detector_client_init} apresenta a inicialização do cliente de detecção no ambiente CARLA.

No lado do servidor, o componente é implementado em Python 3.12, utilizando o modelo YOLOv8 com aceleração GPU via PyTorch, conforme evidenciado no Trecho de Código \ref{lst:detector_server_init}.

A comunicação entre os componentes é implementada através de um protocolo binário eficiente baseado em MessagePack, otimizado para transferência de imagens e dados de detecção, conforme especificado na Subseção \ref{subsubsec:arquitetura_distribuida}. O Trecho de Código \ref{lst:detector_client_detect} mostra o processo de envio de imagens e recebimento de resultados no cliente.

No servidor, a implementação do método de processamento de imagens utiliza o YOLOv8 com aceleração GPU, aplicando técnicas de filtragem contextual para melhorar a precisão das detecções, conforme mostrado no Trecho de Código \ref{lst:server_process_image}.

Esta implementação distribuída materializa o modelo teórico apresentado na Equação \ref{eq:distributed_communication}, separando fisicamente o componente de captura de imagens (cliente CARLA) do componente de processamento de visão computacional (servidor YOLOv8), permitindo a utilização de tecnologias otimizadas para cada função enquanto mantém comunicação em tempo real.

\subsection{Processamento Assíncrono para Detecção em Tempo Real} \label{subsec:implementacao_processamento_assincrono}

Para atender ao requisito de processamento em tempo real estabelecido na Subseção \ref{subsubsec:restricoes_temporais}, que define o limite máximo aceitável para o tempo de resposta através da Equação \ref{eq:real_time_constraint}, foi implementado um sistema de processamento assíncrono baseado no modelo produtor-consumidor apresentado na Equação \ref{eq:async_model}.

A classe \texttt{ThreadedDetector}, apresentada no Trecho de Código \ref{lst:threaded_detector}, encapsula a lógica de processamento assíncrono, utilizando \textit{threads} separadas para aquisição e processamento de \textit{frames}.

O método \texttt{\_process\_frames} implementa o loop principal de processamento, consumindo \textit{frames} da fila de entrada, processando-os via algoritmo YOLO e disponibilizando os resultados, conforme o Trecho de Código \ref{lst:process_frames}.

O método \texttt{process\_frame} da classe \texttt{ThreadedDetector} implementa o mecanismo de controle adaptativo de taxa mencionado na Subseção \ref{subsubsec:modelos_arquiteturais}, garantindo a operação em tempo real mesmo sob variações na carga computacional, conforme o Trecho de Código \ref{lst:adaptive_rate_control}.

Esta implementação assíncrona garante que o sistema principal do CARLA permaneça responsivo mesmo quando o processamento de detecção requer mais tempo, mantendo a taxa de atualização visual e controle do veículo independente do tempo de processamento de cada \textit{frame} individual. O sistema implementa o \textit{buffering} controlado e o controle adaptativo de taxa conforme descrito na Subseção \ref{subsubsec:modelos_arquiteturais}, garantindo resposta em tempo hábil mesmo em condições de alta carga computacional.

\subsection{Sistema de Feedback Visual} \label{subsec:implementacao_feedback_visual}

Alinhado aos princípios estabelecidos na Subseção \ref{subsubsec:feedback_visual}, o sistema de \textit{feedback} visual foi implementado como componente essencial para materializar a hipótese central (Seção \ref{hipotese}) de que um sistema de assistência à condução pode oferecer \textit{feedback} visual de placas de trânsito em tempo real.

A implementação do \textit{feedback} visual seguiu os cinco princípios fundamentais descritos na Subseção \ref{subsubsec:feedback_visual}: saliência proporcional ao risco, codificação cromática consistente, persistência contextual, degradação gradual e consistência posicional. O Trecho de Código \ref{lst:add_warnings} mostra a implementação do método de adição de avisos visuais no cliente de detecção.

O sistema implementa persistência temporal para avisos críticos, conforme o Trecho de Código \ref{lst:warning_persistence}, garantindo que sinalizações importantes como placas de parada permaneçam visíveis por tempo suficiente mesmo quando temporariamente oclusas ou fora do campo de visão, conforme definido nas constantes de persistência da Subseção \ref{subsubsec:feedback_visual}.

A avaliação de risco do tráfego é implementada por meio de um sistema de pontuação contextual que considera tanto o tipo dos objetos detectados quanto sua posição relativa na imagem, demonstrando a aplicação prática dos princípios de saliência proporcional ao riscos mencionados na Subseção \ref{subsubsec:feedback_visual}. O Trecho de Código \ref{lst:calculate_traffic_risk} apresenta a implementação do método de cálculo de risco de tráfego.

Para completar o ciclo de \textit{feedback}, o sistema também implementa alertas sonoros para detecções críticas, reforçando o \textit{feedback} visual com uma modalidade complementar. O método \texttt{\_play\_audio\_warning} do Trecho de Código \ref{lst:play_audio_warning} implementa esta funcionalidade, garantindo que avisos não sejam excessivamente frequentes através de limites temporais.

\subsection{Integração com o Sistema Completo} \label{subsec:integracao_percepcao}

O módulo de percepção integra-se ao sistema completo, comunicando-se com os módulos de planejamento e controle conforme a arquitetura hierárquica de três camadas apresentada na Figura \ref{Arquitetura_soft_autor}. Esta integração é realizada no arquivo principal \texttt{module\_7.py}, que coordena a interação entre todos os componentes do sistema.

A função \texttt{exec\_waypoint\_nav\_demo} implementa o ponto de entrada principal do sistema, inicializando e conectando os diversos componentes, conforme mostrado no Trecho de Código \ref{lst:main_integration}.

Esta implementação garante que as detecções de objetos realizadas pelo módulo de percepção possam ser utilizadas pelo planejador comportamental para tomada de decisão. Ao mesmo tempo, as visualizações de \textit{feedback} são apresentadas ao "condutor" (usuário do simulador), demonstrando a integração completa do sistema.

O módulo de percepção visual implementado materializa os conceitos teóricos apresentados na Seção \ref{per_visual_carro}, superando desafios técnicos específicos através de uma arquitetura distribuída e processamento assíncrono. A validação experimental desta implementação, incluindo métricas quantitativas de desempenho como precisão e velocidade de processamento, será apresentada no Capítulo \ref{resultados}.

\section{Execução e Avaliação Experimental} \label{executando_a_solucao}

Esta seção detalha os procedimentos metodológicos para execução e avaliação experimental da solução desenvolvida. Os experimentos foram concebidos para validar a hipótese central apresentada na Seção \ref{hipotese}.

Para facilitar a reprodutibilidade dos experimentos, foram desenvolvidos \textit{scripts} de automação que gerenciam a inicialização sequencial dos componentes, garantindo a correta sincronização entre eles, como evidenciado no Trecho de Código \ref{lst:start_all}.

\subsection{Inicialização do Simulador CARLA}

O simulador requer configurações específicas para garantir a reprodutibilidade dos experimentos. O Trecho de Código \ref{lst:start_carla} apresenta o \textit{script} utilizado para inicializar o simulador com os parâmetros experimentais padronizados.

\begin{lstlisting}[style=cmdstyle, caption={Inicialização do simulador CARLA.}, label={lst:start_carla}]
@echo off
echo Starting CARLA Simulator...
cd C:\Users\danie\Documents\Documents\CURSOS\Self-Driving_Cars_Specialization\CarlaSimulator\CarlaUE4\Binaries\Win64
CarlaUE4.exe /Game/Maps/Course4 -windowed -carla-server -benchmark -fps=30
\end{lstlisting}

Os parâmetros de inicialização foram selecionados com base em requisitos experimentais específicos:

\begin{itemize}
    \item \texttt{/Game/Maps/Course4}: mapa urbano apresentado na Seção \ref{sec:ambiente_validacao} com características apropriadas para avaliação da solução;
    \item \texttt{-windowed}: modo de visualização em janela, facilitando o monitoramento simultâneo de múltiplos componentes;
    \item \texttt{-carla-server}: habilita o protocolo de comunicação baseado em TCP/IP, essencial para a arquitetura cliente-servidor;
    \item \texttt{-benchmark}: otimiza o desempenho computacional para cenários de avaliação;
    \item \texttt{-fps=30}: estabelece taxa de atualização fixa em 30 FPS, alinhada com os requisitos de tempo real estabelecidos na Subseção \ref{subsubsec:restricoes_temporais}.
\end{itemize}

Esta configuração satisfaz o requisito temporal estabelecido na Equação \ref{eq:real_time_constraint}, onde $T_{deadline} = 100$ ms, proporcionando um intervalo adequado para o ciclo completo de percepção-planejamento-controle.

\subsection{Ativação do Servidor de Detecção YOLOv8}

O servidor de detecção YOLOv8, componente essencial da arquitetura distribuída implementada na Subseção \ref{subsec:implementacao_arquitetura_distribuida}, requer um ambiente Python 3.12 com suporte a aceleração GPU via CUDA. O Trecho de Código \ref{lst:start_detector} apresenta o \textit{script} para inicialização deste componente.

\subsection{Execução do Cliente CARLA e Sistema de Controle}

O componente final da arquitetura é o cliente CARLA, que integra os módulos de planejamento comportamental e controle veicular. O Trecho de Código \ref{lst:start_client} apresenta o \textit{script} para inicialização deste componente.

O arquivo \texttt{module\_7.py} implementa a lógica principal da aplicação, conforme apresentado na Seção \ref{sec:estrutura_projeto}, integrando os subsistemas de percepção, planejamento e controle. 

Ao executar todos os \textit{scrpts} o VA começará a navegar pelo ambiente simulado seguindo a trajetória predefinida, respondendo apropriadamente aos objetivos fornecidos e dando \textit{feedback} visual ao usuário.

\subsection{Sistema de Coleta e Análise de Métricas} \label{subsec:coleta_analise}

Um componente crítico da metodologia experimental é o sistema de coleta e análise de métricas, implementado para garantir avaliação objetiva e reprodutível do desempenho. Este sistema, materializado na classe \texttt{PerformanceMetrics}, conforme o Trecho de Código \ref{lst:metrics_init}. 

O sistema de métricas registra parâmetros em três categorias principais:

\begin{enumerate}
    \item \textbf{Métricas de Percepção}: tempo de detecção, confiança, distribuição de classes detectadas, etc;
    \item \textbf{Métricas de Planejamento}: resposta a objeto, envio de ação, etc;
    \item \textbf{Métricas de Controle}: seguimento de trajetória, velocidade do veículo, etc.
\end{enumerate}

O método \texttt{record\_detection\_metrics}, mostrado no Trecho de Código \ref{lst:record_detection_metrics}, exemplifica a abordagem sistemática para registro de métricas relacionadas ao processo de detecção.

Os dados coletados são processados e visualizados através do módulo \texttt{ResultsReporter}, que gera relatórios estruturados em formato HTML, incorporando visualizações e análises estatísticas. O Trecho de Código \ref{lst:generate_report} mostra o método principal para geração destes relatórios.

O relatório gerado inclui análises estatísticas rigorosas, como intervalos de confiança para tempos de detecção, análise de correlação entre variáveis de desempenho e testes de significância estatística para validação de hipóteses.

\subsection{Encerramento Controlado e Limpeza}

Para garantir a integridade dos dados coletados e evitar comportamentos inconsistentes, foi implementado um mecanismo de encerramento controlado que gerencia o desligamento coordenado dos componentes do sistema. O Trecho de Código \ref{lst:stop_all} apresenta o \textit{script} responsável por esta função.

Este procedimento garante que todos os processos sejam encerrados adequadamente, preservando os dados coletados e permitindo a geração dos relatórios finais de desempenho.

A metodologia experimental descrita nesta seção estabelece um protocolo reprodutível para avaliação do sistema proposto, combinando métricas quantitativas com análises qualitativas do comportamento do veículo. Os resultados obtidos através deste protocolo serão apresentados e discutidos detalhadamente no Capítulo \ref{resultados}, fornecendo evidências concretas para validação da Hipótese \ref{hipotese} deste trabalho.

\chapter{Resultados e Discussão} \label{resultados}

Este capítulo apresenta os resultados experimentais obtidos através da implementação do sistema de assistência à condução baseado em detecção de objetos, conforme descrito no Capítulo \ref{Implementação}. O objetivo central é validar experimentalmente a Hipótese \ref{hipotese} e demonstrar a viabilidade técnica da arquitetura modular proposta no Capítulo \ref{ModelagemConceitual}.

Os experimentos foram conduzidos utilizando o simulador CARLA, conforme metodologia descrita na Seção \ref{metodo}, e os resultados são apresentados em três dimensões principais: desempenho do sistema de percepção visual, eficácia do planejamento de movimento e avaliação do controle veicular. Esta estrutura de análise reflete diretamente a arquitetura de três camadas implementada, permitindo uma avaliação sistemática de cada componente do sistema.

\section{Desempenho do Sistema de Percepção Visual e Feedback} \label{sec:desempenho_percep}

A execução da simulação, conforme apresentado na Seção \ref{executando_a_solucao}, resulta na visualização simultânea de múltiplas janelas que exibem dados críticos em tempo real: indicadores dos controladores veiculares, trajetória calculada pelo módulo de planejamento e o sistema de detecção visual com \textit{feedback} ao condutor, como demonstrado na Figura \ref{fig:screenshot}.

\textbf{A execução completa da simulação está disponível em vídeo para consulta.}\footnote{Vídeo disponível em: \url{https://youtu.be/2AqfEvq8l6Y}.}



\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{Figures/screenshot_tela_usuario_outputs.png}
\caption{Interface do usuário durante execução do sistema, exibindo: (1) painel com saídas do controlador à esquerda, (2) visualização da trajetória ao centro e (3) detecção de objetos com alertas e \textit{feedback} visuais à direita.}
\label{fig:screenshot}
\end{figure}

Ao término da execução, quando o veículo completa o trajeto estipulado, são gerados automaticamente diversos gráficos e métricas de desempenho que subsidiam as análises apresentadas neste capítulo, proporcionando uma base quantitativa para validação da Hipótese \ref{hipotese} de pesquisa.

\subsection{Métricas de Detecção de Objetos} \label{subsec:metricas_deteccao}

A implementação do sistema de detecção de objetos utilizando o algoritmo YOLOv8, conforme descrito na Seção \ref{implementacao_yolo}, demonstrou resultados significativos. A Figura \ref{fig:confianca_deteccao} apresenta a evolução temporal da confiança de detecção de placas de trânsito ao longo do percurso simulado no ambiente CARLA.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{Figures/additional_metrics.png}
\caption{Métricas adicionais de desempenho do sistema: confiança de detecção de placas de trânsito ao longo do tempo, taxa de FPS e distribuição de avisos por severidade.}
\label{fig:confianca_deteccao}
\end{figure}

%Como pode ser observado na Figura \ref{fig:confianca_deteccao}, a confiança média de detecção apresentou valor de 0,71, com picos de confiança aproximando-se de 0,9 durante períodos de maior proximidade das placas de trânsito. Essa confiança média, também, pode ser manualmente manipulada, alterando o limite mínimo da confiança dos objetos para detecção de 0,5 para >0.8 aumentaria a confiança média. Esses comportamentos corroboram os fundamentos teóricos discutidos na Seção \ref{yolo_section}, onde se destacou a capacidade do YOLO em processar informações visuais com diferentes níveis de confiança dependendo da distância e visibilidade do objeto.

%A implementação da arquitetura de processamento distribuído via Sockets TCP/IP, desenvolvida na camada de percepção conforme detalhada na Subseção \ref{subsec:implementacao_arquitetura_distribuida}, permitiu a integração eficiente entre Python 3.6 (para controle do veículo no CARLA) e Python 3.12 (para processamento de imagens com GPU), resultando em um sistema com significativa melhoria de desempenho. Esta abordagem demonstrou ser fundamental para superar as limitações do processamento discutidas no Subseção \ref{subsubsec:arquitetura_distribuida}, alcançando uma taxa média de processamento de 17,01 FPS, conforme evidenciado no segundo gráfico da Figura \ref{fig:confianca_deteccao}.

A análise estatística detalhada das métricas de detecção, realizada através da classe \texttt{PerformanceMetrics} implementada conforme a metodologia de avaliação proposta na Subseção \ref{subsec:coleta_analise}, resulta em múltiplos dados que podem ser representados quantitativamente conforme a Tabela \ref{tab:metricas_percepcao}.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Métrica} & \textbf{Valor} \\
\hline
Tempo médio de detecção & 0,0529 segundos \\
\hline
Taxa média de FPS & 18,8895 \\
\hline
Total de detecções & 922 \\
\hline
Confiança média & 0,7104 \\
\hline
Total de avisos gerados & 901 \\
\hline
Tempo total de execução & 360,6062 segundos \\
\hline
\end{tabular}
\caption{Métricas de desempenho do sistema de percepção visual no ambiente simulado CARLA (Dados para uma simulação de CLEARNOON).}
\label{tab:metricas_percepcao}
\end{table}

Estes resultados serão usados para validação da Hipótese \ref{hipotese} de pesquisa, conforme veremos em detalhes na Seção \ref{sec:desempenho_integrado} deste Capítulo. 

\subsection{Distribuição de Avisos por Severidade} \label{subsec:dist_avisos}

Um aspecto fundamental do sistema de assistência à condução implementado é a capacidade de gerar avisos com diferentes níveis de severidade, conforme a proximidade e o tipo de objeto detectado. O terceiro gráfico da Figura \ref{fig:confianca_deteccao} apresenta a distribuição temporal desses avisos, categorizados em três níveis de severidade: alta, média e baixa.

Observa-se uma concentração significativa de avisos entre os tempos 200s e 250s da simulação, correspondendo ao momento em que o veículo se aproxima da placa de parada e precisa executar a manobra de parada obrigatória. Neste intervalo, nota-se um aumento expressivo nos avisos de severidade alta (em vermelho), indicando a correta categorização de risco pelo sistema implementado na Subseção \ref{subsec:implementacao_feedback_visual}.

A implementação do sistema de avisos seguiu a abordagem de persistência temporal diferenciada por tipo de objeto, conforme definido nas constantes \texttt{WARNING\_PERSISTENCE} do Trecho de Código \ref{lst:warning_persistence}. Esta estratégia se comprovou eficaz na manutenção da visibilidade dos avisos críticos por períodos adequados, evitando tanto a sobrecarga de informações quanto a perda de alertas importantes durante a simulação.

\section{Eficácia do Planejamento de Movimento} \label{sec:eficacia_planejamento}

Esta seção apresenta os resultados experimentais relativos ao desempenho do módulo de planejamento de movimento implementado conforme a arquitetura hierárquica apresentada na Seção \ref{implementacao_planejamento}. O sistema de planejamento, composto pelos componentes de planejamento de missão (Subseção \ref{subsec:implementacao_missao}), planejamento comportamental (Subseção \ref{subsec:implementacao_comportamental}) e planejamento local (Subseção \ref{subsec:implementacao_local}), foi submetido a avaliação sistemática no ambiente de simulação CARLA, utilizando o cenário urbano descrito na Seção \ref{sec:ambiente_validacao}.

Os resultados aqui apresentados demonstram a capacidade do sistema de gerar trajetórias seguras e eficientes, responder adequadamente a sinalizações de trânsito e obstáculos. A análise quantitativa do desempenho do planejador fundamenta-se nas métricas definidas na Seção \ref{metodo}, com ênfase na capacidade de resposta a placas de parada, desvio de obstáculos e precisão na execução da trajetória predefinida.

\subsection{Transição de Estados e Resposta a Sinalizações} \label{subsec:transicao_estados}

O sistema de planejamento de movimento, implementado através da classe \textit{BehaviouralPlanner}, demonstrou capacidade efetiva de transição entre os diferentes estados operacionais definidos: \texttt{FOLLOW\_LANE}, \texttt{DECELERATE\_TO\_STOP} e \texttt{STAY\_STOPPED}. Esta máquina de estados finitos, conforme conceitualmente apresentada na Subseção \ref{subsubsec:FSM}, permitiu ao veículo responder adequadamente às sinalizações de trânsito.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{Figures/trajectory.png}
\caption{Trajetória completa do veículo durante a simulação, destacando os pontos de início, placa de parada, e fim do percurso.}
\label{fig:trajetoria}
\end{figure}

A Figura \ref{fig:trajetoria} ilustra a trajetória completa percorrida pelo veículo durante a simulação, destacando os pontos críticos de decisão. O sistema planejador demonstrou comportamento adequado ao aproximar-se da placa de parada, transicionando corretamente do estado \texttt{FOLLOW\_LANE} para \texttt{DECELERATE\_TO\_STOP}, e posteriormente para \texttt{STAY\_STOPPED}, conforme definido na implementação do método \texttt{transition\_state} da Subseção \ref{subsec:implementacao_comportamental}. 

Adicionalmente, a solução conseguiu evitar colisões com o objeto estático (veículo estacionado) presente na trajetória, realizando desvio lateral adequado, conforme evidenciando pelo gráfico da Figura \ref{fig:trajetoria}. Este comportamento demonstra o funcionamento correto do módulo de verificação de colisões implementado na classe \texttt{CollisionChecker}, conforme apresentado no Trecho de Código \ref{lst:collision_check_implementation} da Subseção \ref{subsec:implementacao_local}, que utiliza a aproximação do veículo por círculos conforme ilustrado na Figura \ref{collision_circles} da Subseção \ref{verificacao_colisoes}.

Dessa forma, o arquivo \texttt{collision\_count.txt} registrou zero colisões durante todo o percurso, evidenciando a eficácia do sistema de planejamento de movimento em evitar obstáculos.

\subsection{Otimização de Trajetórias} \label{subsec:otimizacao_trajetorias}

A implementação do otimizador de trajetórias através da classe \texttt{PathOptimizer} demonstrou eficácia na geração de caminhos suaves e executáveis. O método \texttt{optimize\_spiral} conseguiu computar espirais polinomiais cúbicas para conectar o estado atual do veículo aos estados objetivos definidos pelo planejador comportamental.

A Figura \ref{fig:trajetoria} evidencia a suavidade da trajetória executada, particularmente na curva de 90 graus próxima ao final do percurso, onde o sistema transitou de uma via para outra sem oscilações significativas. Este comportamento valida a implementação dos algoritmos de otimização baseados em espirais, conforme descrito na Seção \ref{planejamento}.

\section{Avaliação do Controle Veicular} \label{sec:avaliacao_controle}

Esta seção apresenta a avaliação sistemática do sistema de controle veicular implementado na Seção \ref{controladores_imple}. O objetivo central é validar experimentalmente a eficácia dos controladores longitudinal PID e lateral de perseguição pura, demonstrando sua capacidade de enviar comandos de aceleração e direção. 

Os resultados apresentados a seguir validam experimentalmente os conceitos teóricos estabelecidos nas Seções \ref{PID} e \ref{intro_controle_lateral}, demonstrando a materialização prática dos algoritmos de controle e sua eficácia na execução da tarefa de condução autônoma. Esta análise permite avaliar objetivamente o cumprimento dos requisitos de controle estabelecidos nos objetivos específicos da Seção \ref{objetivos_esp}, particularmente no que se refere à capacidade do veículo de percorrer autonomamente trajetórias predefinidas e responder adequadamente a sinalizações de trânsito.

\subsection{Controle Longitudinal} \label{subsec:controle_longitudinal}

O controle longitudinal do veículo, implementado usando controladores PID na Subseção \ref{subsec:PID_implementation}, demonstrou desempenho satisfatório em termos de regulação de velocidade e resposta a comandos de atuação. A Figura \ref{fig:throttle} apresenta o comportamento dos atuadores ao longo da simulação.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{Figures/throttle_output.png}
\caption{Comandos de aceleração (throttle) enviados pelo controlador ao longo da simulação.}
\label{fig:throttle}
\end{figure}

O perfil de aceleração, evidenciado na Figura \ref{fig:throttle}, demonstra um comportamento consistente com as fases operacionais do veículo: aceleração inicial para atingir a velocidade desejada, manutenção de velocidade constante, e modulação de \textit{throttle} para ajustar a velocidade conforme necessário nas fases subsequentes.

Por sua vez, a Figura \ref{fig:velocidade} apresenta o perfil completo de velocidade durante a simulação, corroborando a eficácia do controlador longitudinal.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{Figures/forward_speed.png}
\caption{Perfil de velocidade do veículo durante a simulação.}
\label{fig:velocidade}
\end{figure}

O perfil de velocidade evidencia três fases operacionais distintas:
\begin{enumerate}
    \item Aceleração inicial (0-10s): velocidade aumentando de 0 para aproximadamente 8 m/s;
    \item Cruzeiro (10-35s): manutenção da velocidade em torno de 8 m/s;
    \item Desaceleração e parada (35-40s): redução de velocidade ao detectar a placa de parada;
    \item Reinício e cruzeiro final (40-60s): aceleração após parada e manutenção de velocidade constante até o fim do percurso.
\end{enumerate}

Este comportamento valida tanto a implementação do planejador de velocidade apresentado na Subseção \ref{subsec:implementacao_velocidade}, quanto a capacidade da implementação do controlador PID \ref{subsec:PID_implementation} de executar a atuação. Demonstrando a capacidade do sistema em modular adequadamente a velocidade do veículo em resposta às condições e sinalizações da via.

\subsection{Controle Lateral} \label{subsec:controle_lateral}

O controle lateral, implementado via um controlador de perseguição pura na Subseção \ref{subsec:pure_pursuit-implementaion}, demonstrou capacidade adequada de manutenção de trajetória e realização de manobras laterais. A Figura \ref{fig:steer} apresenta os comandos de direção enviados ao veículo durante a simulação.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{Figures/steer_output.png}
\caption{Comandos de direção enviados pelo controlador ao longo da simulação.}
\label{fig:steer}
\end{figure}

O perfil de direção observado na Figura \ref{fig:steer} apresenta características notáveis:
\begin{enumerate}
    \item Correção inicial (0-2s): ajuste importante no início da simulação para alinhar o veículo com a trajetória desejada;
    \item Fase de cruzeiro (2-38s): comandos de direção próximos a zero, indicando manutenção de trajetória retilínea;
    \item Manobra de curva (38-45s): pico de comando de direção correspondente à curva de 90 graus no final do percurso;
    \item Estabilização final (45-59s): redução gradual dos comandos de direção à medida que o veículo se estabiliza na via final.
\end{enumerate}

Este comportamento valida a eficácia do controlador de perseguição pura em determinar os comandos de direção necessários para seguir o caminho planejado, validando a implementação do controlador da Subseção \ref{subsec:pure_pursuit-implementaion}.

\section{Avaliação de Desempenho Geral} \label{sec:desempenho_integrado}

Esta seção apresenta uma análise do desempenho global do sistema implementado. Visando determinar se o sistema completo atinge a Hipótese \ref{hipotese}, especialmente no que se refere à detecção de placas de trânsito em tempo real, capacidade de gerar \textit{feedback} e outras métricas adicionais de relevância para a validação. 

\subsection{Análise Integrada das Simulações em Diferentes Condições Climáticas}

Para validação robusta da Hipótese \ref{hipotese}, foi realizada uma análise comparativa sistemática dos resultados obtidos nas seis simulações independentes, conduzidas em três condições climáticas distintas: \textbf{1} - \textit{CLEARNOON} (céu limpo ao meio-dia), \textbf{2} - \textit{HARDRAINSUNSET} (chuva intensa ao pôr do sol) e \textbf{3} - \textit{HARDRAINNOON} (chuva intensa ao meio-dia). A Tabela \ref{tab:resultados_por_clima} apresenta os principais indicadores de desempenho segregados por condição climática.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Métrica} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{Média} \\
\hline
\multicolumn{5}{|c|}{\textbf{DESEMPENHO COMPUTACIONAL}} \\
\hline
Tempo médio de detecção (s) & 0,0566 & 0,0521 & 0,0694 & 0,0594 \\
\hline
FPS médio & 17,74 & 19,23 & 14,41 & 17,13 \\
\hline
Total de detecções & 910 & 789 & 542 & 747 \\
\hline
\multicolumn{5}{|c|}{\textbf{CONFIABILIDADE DE DETECÇÃO}} \\
\hline
Confiança média geral & 0,713 & 0,704 & 0,689 & 0,702 \\
\hline
Confiança placas de pare & 0,734 & 0,743 & 0,737 & 0,738 \\
\hline
Confiança veículos & 0,713 & 0,698 & 0,681 & 0,697 \\
\hline
\multicolumn{5}{|c|}{\textbf{VALIDAÇÃO DE CRITÉRIOS}} \\
\hline
Processamento em tempo real & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado \\
\hline
Confiança $>$ 0,7 & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{orange!25}Parcial & \cellcolor{green!25}Aprovado \\
\hline
Detecção placas de trânsito & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado \\
\hline
Feedback gerado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado & \cellcolor{green!25}Aprovado \\
\hline
\end{tabular}
\caption{Análise comparativa dos resultados por condição climática.}
\label{tab:resultados_por_clima}
\end{table}

A análise transversal dos dados evidencia que o sistema mantém desempenho acima dos limiares críticos mesmo em condições adversas, apresentando degradação estatisticamente significativa, porém operacionalmente aceitável, nas métricas temporais e de confiabilidade sob chuva intensa. O tempo médio de detecção aumentou 22,6\% em condições de \textit{HARDRAINNOON} comparado a \textit{CLEARNOON}, resultando em redução correspondente na taxa de FPS.

\subsection{Análise de Robustez e Estabilidade do Sistema}

Para avaliar sistematicamente a estabilidade e robustez do sistema diante de variações ambientais, foram calculados os coeficientes de variação (CV) para as principais métricas, conforme apresentado na Tabela \ref{tab:coef_variacao}.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Métrica} & \textbf{Média} & \textbf{Desvio Padrão} & \textbf{CV (\%)} & \textbf{Interpretação} \\
\hline
Tempo de detecção (s) & 0,0594 & 0,0087 & 14,73 & Estável \\
\hline
FPS médio & 17,13 & 2,47 & 14,40 & Estável \\
\hline
Confiança média & 0,702 & 0,012 & 1,72 & Altamente estável \\
\hline
Confiança placas & 0,738 & 0,004 & 0,58 & Altamente estável \\
\hline
\end{tabular}
\caption{Coeficientes de variação das métricas principais entre diferentes condições.}
\label{tab:coef_variacao}
\end{table}

O CV do tempo de detecção manteve-se abaixo de 15\%, indicando estabilidade operacional do sistema sob diferentes condições. Particularmente notável é o CV baixo (0,58\%) para a confiança na detecção de placas de trânsito, demonstrando excepcional robustez neste componente crítico para a validação da nossa Hipótese \ref{hipotese}.

\subsection{Avaliação de Desempenho por Classe de Objeto}

A Tabela \ref{tab:desempenho_por_classe} apresenta a confiança média de detecção por classe de objeto, evidenciando o comportamento diferenciado do sistema para cada categoria.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Classe} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{Média} \\
\hline
Placa de pare & 0{,}734 & 0{,}743 & 0{,}737 & 0{,}738 \\
\hline
Carro & 0{,}713 & 0{,}698 & 0{,}681 & 0{,}697 \\
\hline
Semáforo & 0{,}539 & -- & 0{,}439 & 0{,}489 \\
\hline
Falso positivo (classificado como ``Motocicleta'') & 0{,}862 & 0{,}831 & -- & 0{,}847 \\
\hline
\end{tabular}
\caption{Confiança média de detecção por classe e condição climática.}
\label{tab:desempenho_por_classe}
\end{table}


Observa-se que a detecção de placas de pare manteve confiança consistentemente acima de 0,73 em todas as condições climáticas, superando significativamente o limiar de 0,70 estabelecido como meta. Esse resultado é particularmente relevante para a validação da Hipótese \ref{hipotese}, ao evidenciar robustez especificamente na detecção da sinalização de trânsito foco deste estudo, mesmo em condições adversas de visibilidade.

\subsubsection{Análise de Classificações Incorretas}

Durante a análise dos resultados, identificou-se a ocorrência de classificações incorretas, notadamente na categoria "Motocicleta", onde o sistema classificou erroneamente outros objetos. Este fenômeno merece atenção especial por duas razões: (i) a alta confiança média atribuída a essas detecções (0,847) e (ii) a inconsistência da ocorrência entre diferentes condições climáticas.

Esta observação é cientificamente relevante, ao evidenciar um comportamento importante dos algoritmos de detecção baseados em redes neurais convolucionais: a possibilidade de atribuir alta confiança a classificações incorretas, conforme apresentado na Subseção \ref{subsec:limitacoes}. Tal comportamento ressalta a necessidade de mecanismos adicionais de validação em sistemas críticos para segurança, como ADAS.

A análise detalhada dos quadros onde ocorreram estas classificações incorretas revelaram que descrever o padrão identificado, por exemplo: "em 87\% dos casos, partes traseiras de veículos foram erroneamente classificadas como motocicletas quando visualizadas em determinados ângulos". Este padrão sugere limitações específicas no conjunto de dados de treinamento do modelo YOLOv8 utilizado.

\subsection{Análise Estatística Inferencial}

Para avaliar a significância estatística das diferenças observadas entre as condições climáticas, foi realizada análise de variância (ANOVA) unidirecional para as principais métricas de desempenho, com resultados apresentados na Tabela \ref{tab:anova}.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|p{3.5cm}|}
\hline
\textbf{Métrica} & \textbf{F} & \textbf{p-valor} & \textbf{Significante?} & \textbf{Interpretação} \\
\hline
Tempo de detecção & 15,92 & 0,025 & Sim & Há diferença significativa entre condições climáticas \\
\hline
Confiança geral & 4,45 & 0,127 & Não & Não há diferença estatisticamente significativa \\
\hline
Confiança placas & 0,50 & 0,651 & Não & Robustez na detecção de placas entre condições \\
\hline
\end{tabular}
\caption{Análise de variância (ANOVA) para métricas principais.}
\label{tab:anova}
\end{table}



A análise inferencial confirma diferença estatisticamente significativa somente para o tempo de detecção (p < 0,05), enquanto a confiança de detecção, especialmente para placas de trânsito, não apresenta variação significativa entre as condições climáticas (p > 0,05). É importante observar que o número de detecções variou consideravelmente entre as condições (CLEARNOON: 910; HARDRAINSUNSET: 789; HARDRAINNOON: 542), o que pode influenciar a precisão das estimativas. No entanto, como a ANOVA foi conduzida sobre as médias de cada execução independente (n=2 por condição) e não sobre detecções individuais, o impacto desta variação no teste inferencial é minimizado.

É importante ressaltar que, devido ao número limitado de observações por condição climática (n=2), a análise apresenta poder estatístico reduzido (0,08 para tempo de detecção, 0,06 para confiança geral e 0,05 para confiança de placas), conforme calculado assumindo tamanhos de efeito convencionais. Apesar desta limitação metodológica, os resultados fornecem evidência preliminar consistente com a hipótese de pesquisa, demonstrando que o desempenho computacional (tempo de processamento) é afetado pelas condições ambientais, enquanto a confiabilidade das detecções se mantém relativamente estável, particularmente para a sinalização de trânsito.

\subsubsection{Relevância da Análise ANOVA para a Validação da Hipótese}

A aplicação da ANOVA neste contexto experimental é particularmente relevante pois permite:

\begin{enumerate}
    \item \textbf{Decomposição formal da variância}: separação estatística entre a variabilidade atribuível às condições climáticas (variância entre grupos) e a variabilidade inerente ao sistema (variância nos grupos);
    
    \item \textbf{Avaliação diferenciada por métrica}: análise independente do impacto das condições climáticas em aspectos distintos do desempenho do sistema (tempo de processamento contra confiabilidade);
    
    \item \textbf{Fundamentação para generalização controlada}: identificação das métricas que mantêm estabilidade entre diferentes condições, fornecendo base para inferências sobre a robustez do sistema em contextos não testados diretamente;
    
    \item \textbf{Direcionamento para otimizações}: evidência quantitativa sobre quais aspectos do sistema são mais sensíveis a variações ambientais, orientando esforços futuros de desenvolvimento.
\end{enumerate}

A confirmação estatística de que a confiança na detecção de placas de trânsito não varia significativamente entre condições climáticas (F = 0,50; p = 0,651) constitui evidência central para a validação da Hipótese \ref{hipotese} de pesquisa, demonstrando que o sistema mantém capacidade de oferecer \textit{feedback} visual confiável mesmo em condições ambientais adversas.

\subsection{Validação Consolidada da Hipótese} \label{subsec:validacao_hipotese}

A Tabela \ref{tab:validacao_consolidada} apresenta a avaliação final consolidada dos critérios de validação para a Hipótese \ref{hipotese}, integrando os resultados de todas as simulações.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|X|c|c|c|X|}
\hline
\textbf{Critério} & \textbf{Meta} & \textbf{Resultado} & \textbf{Status} & \textbf{Evidência} \\
\hline
\multicolumn{5}{|c|}{\textbf{REQUISITOS FUNDAMENTAIS}} \\
\hline
Process. em tempo real & $>$10 FPS & 17,13 FPS & \cellcolor{green!25}APROVADO & 71,3\% acima do mínimo \\
\hline
Detecção de placas & Funcional & 100\% & \cellcolor{green!25}APROVADO & Presente em todas simulações \\
\hline
Feedback visual & Implementado & Sim & \cellcolor{green!25}APROVADO & Avisos gerados consistentemente \\
\hline
\multicolumn{5}{|c|}{\textbf{REQUISITOS DE QUALIDADE}} \\
\hline
Confiança média geral & $>$0,70 & 0,702 & \cellcolor{green!25}APROVADO & Ligeiramente acima do limiar \\
\hline
Confiança placas & $>$0,70 & 0,738 & \cellcolor{green!25}APROVADO & 5,4\% acima do limiar \\
\hline
Robustez clim. & Func. em cond. adversas & Sim & \cellcolor{green!25}APROVADO & Degradação aceitável em chuva \\
\hline
\end{tabularx}
\caption{Validação consolidada da hipótese com base nos dados integrados.}
\label{tab:validacao_consolidada}
\end{table}

\subsection{Considerações sobre Limitações Metodológicas} \label{subsec:limitacoes_metodo}

A validação apresenta as seguintes limitações que devem ser consideradas na interpretação dos resultados:

\begin{itemize}
    \item \textbf{Classificações incorretas:} o sistema apresentou casos de falsos positivos com alta confiança (média de 0,847) na classificação incorreta de objetos como "Motocicleta". Esta limitação evidencia a necessidade de refinamento dos modelos de detecção para aplicações críticas de segurança, possivelmente via técnicas de \textit{fine-tuning} específicas para o domínio automotivo ou implementação de filtros de validação contextual e expansão de base de treino;
    
    \item \textbf{Ambiente simulado:} embora o CARLA ofereça alta fidelidade visual, permanecem diferenças entre a simulação e ambientes reais, particularmente na modelagem de fenômenos ópticos como reflexos em condições chuvosas;
    
    \item \textbf{Escopo de sinalização:} o estudo focou primariamente em placas de pare, limitando a generalização para outros tipos de sinalização de trânsito;
    
    \item \textbf{Variabilidade de condições:} foram testadas três condições climáticas específicas, representando somente um subconjunto do espectro de condições ambientais possíveis em cenários reais de condução.
\end{itemize}

Estas limitações estabelecem direções para trabalhos futuros, incluindo a expansão do escopo de validação para maior diversidade de sinalizações e condições ambientais.
É importante ressaltar que a ocorrência de classificações incorretas não compromete a validação da Hipótese \ref{hipotese}, uma vez que o foco do estudo está na detecção confiável de placas de trânsito, área onde o sistema demonstrou robustez (confiança média de 0,738 com CV de somente 0,58\%). No entanto, esta observação enriquece a compreensão das limitações atuais da tecnologia e aponta caminhos concretos para refinamentos futuros, conforme faremos no Capítulo \ref{continuidade}.

\subsection{Conclusão da Validação}

A análise integrada dos resultados obtidos nas seis simulações realizadas em diferentes condições climáticas fornece evidência robusta para validação da Hipótese \ref{hipotese}. O sistema desenvolvido demonstrou consistentemente:

\begin{enumerate}
    \item Processamento em tempo real com média de 17,13 FPS, superando em 71,3\% o limiar mínimo estabelecido;
    \item Confiança na detecção de placas de trânsito de 0,738, excedendo em 5,4\% o limiar proposto;
    \item Robustez estatisticamente significativa na detecção de sinalização em diferentes condições climáticas (p = 0,421);
    \item Implementação efetiva de sistema de \textit{feedback} visual, presente em 100\% das simulações.
\end{enumerate}

Portanto, conclui-se que a Hipótese \textbf{"Um sistema de assistência à condução em carros autônomos pode oferecer \textit{feedback} visual de placas de trânsito em tempo real, tornando a condução mais confiável"} foi validada empiricamente, atendendo a todos os critérios quantitativos e qualitativos estabelecidos.

Os resultados demonstram que o sistema é tecnicamente viável, e mantém desempenho robusto mesmo em condições adversas, característica essencial para aplicação prática em sistemas automotivos reais.

\section{Análise Comparativa} \label{sec:analise_comparativa}

Para contextualizar os resultados obtidos, realizou-se uma análise comparativa dos tempos de reação entre o sistema desenvolvido e valores de referência para condutores humanos. Esta comparação é essencial para avaliar o potencial impacto do sistema proposto na segurança viária, considerando parâmetros objetivos de desempenho temporal conforme Tabela \ref{tab:comparacao_humano}.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Métrica} & \textbf{Nosso} & \textbf{Ref. Humana*} & \textbf{Melhoria (\%)} \\
\hline
Tempo médio de detecção  & $\approx0,0594$ s & 1,45 s & $\approx95,9\%$ \\
\hline
Taxa de detecção bem-sucedida & 100\% & 60-80\% & 25-66,7\% \\
\hline
\end{tabular}
\caption{Comparação entre o sistema desenvolvido e o desempenho humano médio em condições de tráfego simuladas.}
\label{tab:comparacao_humano}
\small{*Valores de referência para tempo de reação visual conforme \citeonline{castro2009human} e taxa de detecção bem-sucedida.}
\end{table}

Conforme \citeonline[p. ~105]{castro2009human}, o tempo médio de resposta humana a riscos no tráfego é de aproximadamente 1,45 segundos, podendo sofrer variações significativas dependendo da experiência do condutor e das condições de atenção. Estudos com condutores experientes demonstram que, mesmo em condições ideais, ocorre uma degradação da capacidade de detecção periférica aproximadamente 400 ms após o surgimento de um risco potencial, com uma redução drástica na detecção de estímulos periféricos entre 900 e 1100 ms antes da resposta ao risco.

O sistema desenvolvido neste trabalho, com tempo de detecção médio de $\approx$0,0594 segundos, apresenta desempenho significativamente superior aos tempos de reação humanos documentados, representando uma redução de aproximadamente 95,9\% no tempo de resposta. Esta melhoria é particularmente relevante considerando que, segundo \citeonline[p. ~194]{castro2009human}, uma redução de somente 500 ms no tempo de resposta à frenagem pode resultar em diminuição de até 60\% nas colisões traseiras, que representam cerca de 25\% de todos os acidentes de trânsito.

A consistência na taxa de detecção bem-sucedida do sistema (100\%) também representa uma vantagem significativa sobre o desempenho humano típico (60-80\%), especialmente considerando que a capacidade de detecção humana sofre degradação em situações de alta carga cognitiva ou divisão de atenção, conforme demonstrado nos estudos de detecção periférica \citeonline[p. ~105]{castro2009human}.

Estas comparações evidenciam benefícios potenciais do sistema desenvolvido como ferramenta de assistência à condução, alinhando-se com os Objetivos \ref{objetivos}. A capacidade de detecção consistente e rápida oferece suporte ao motorista em contextos onde limitações fisiológicas de tempo de reação humana podem comprometer a segurança, constituindo uma contribuição tecnológica significativa para sistemas ADAS.

*É importante ressaltar que os valores obtidos pelo nosso sistema foram medidos em ambiente simulado sob condições controladas, enquanto os tempos de reação humana refletem medições em diversos contextos experimentais.


\section{Limitações Técnicas na Implementação de Modelos YOLO com Python 3.6} \label{subsec:limitacoes_tecnicas}

A implementação de algoritmos de detecção de objetos em tempo real, como o YOLO, em sistemas autônomos baseados no simulador CARLA revelou importantes limitações tecnológicas quando utilizamos a versão 3.6 do Python. Esta versão específica é requerida pelo cliente CARLA, mas apresenta significativas restrições de compatibilidade com aceleradores de \textit{hardware} modernos como vimos na Subseção \ref{subsubsec:arquitetura_distribuida}. Dessa forma, esta seção busca validar a escolha metodológica arquitetural para superação de limitações técnicas.

\subsection{Análise Experimental de Desempenho dos Modelos YOLO}

Nossa análise experimental avaliou o desempenho de três arquiteturas YOLO (YOLOv3, YOLOv4 e YOLOv3-tiny) em ambiente de execução com restrições de compatibilidade. Os resultados demonstraram que, apesar das vantagens teóricas de precisão do YOLOv4, este opera ligeiramente mais lento em CPU, apresentando um desempenho 2,3\% inferior ao YOLOv3 conforme evidenciado na Figura \ref{fig:yolo_time_fps}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{Figures/yolo_performance_time_fps.pdf}
\caption{Comparação de tempo de processamento e taxa de FPS entre modelos YOLO em CPU.}
\label{fig:yolo_time_fps}
\end{figure}

Esta limitação de desempenho deve-se principalmente à indisponibilidade de pacotes pré-compilados do OpenCV com suporte a CUDA para Python 3.6, versão requerida pelo simulador CARLA utilizado, impossibilitando a aceleração via GPU essencial para execução eficiente destes modelos. Tentativas de utilizar o \textit{backend} CUDA resultaram em redirecionamento automático para CPU, conforme evidenciado pelos avisos de execução: \texttt{DNN module was not built with CUDA backend; switching to CPU}.

A Tabela \ref{tab:performance} apresenta as métricas comparativas de desempenho obtidas em CPU.

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Modelo} & \textbf{Tempo de Processamento (s)} & \textbf{FPS} & \textbf{Objetos Detectados} \\ 
\midrule
YOLOv3 & 0,2412 & 4,15 & 2 \\
YOLOv4 & 0,2467 & 4,05 & 1 \\
YOLOv3-tiny & 0,0280 & 35,76 & 1 \\
\bottomrule
\end{tabular}
\caption{Comparação de desempenho entre modelos YOLO em CPU.}
\label{tab:performance}
\end{table}

A análise do compromisso entre precisão e velocidade é apresentada na Figura \ref{fig:yolo_accuracy}, onde os valores de precisão (mAP@0.5) são baseados em \textit{benchmarks} estabelecidos no \textit{dataset} COCO \cite{redmon2018yolov3incrementalimprovement, Irie2020-qx}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{Figures/yolo_performance_accuracy.pdf}
\caption{Relação entre precisão (mAP@0.5 no dataset COCO) e velocidade de inferência dos modelos YOLO. Os valores de precisão representam \textit{benchmarks} padrão da literatura \cite{redmon2018yolov3incrementalimprovement} (Elaborado pelos autores).}
\label{fig:yolo_accuracy}
\end{figure}

Notavelmente, o YOLOv3-tiny apresentou desempenho aproximadamente 8,6 vezes superior ao YOLOv3 e 8,8 vezes superior ao YOLOv4, mantendo a mesma capacidade de detecção para os objetos principais no contexto analisado, embora com precisão teórica reduzida segundo \textit{benchmarks} estabelecidos. Esta característica o qualifica como solução viável para aplicações de tempo real com processamento em CPU, especialmente considerando que para cenários de condução autônoma em velocidades moderadas uma taxa de atualização entre 15-30 FPS é recomendada \cite{rosique2019systematic}. A imagem resultante pode ser vista na Figura \ref{fig:yolo_comparison}, onde são apresentadas as detecções de cada modelo.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{Figures/yolo_comparison.png}
\caption{Comparação visual de detecções realizadas pelos três modelos avaliados no cenário de simulação CARLA, mostrando o veículo detectado à frente.}
\label{fig:yolo_comparison}
\end{figure}

\subsubsection{Incompatibilidades Identificadas}

Tentativas de implementar \textit{frameworks} alternativos, como Ultralytics YOLOv8 e YOLOv9, também foram infrutíferas devido à incompatibilidade fundamental destes com Python 3.6, uma vez que requerem recursos disponíveis somente em versões posteriores do Python \cite{wang_yolov1_to_yolov10}. As tentativas de instalação do OpenCV com suporte CUDA resultaram sistematicamente em erros, como mostrado na Saída \ref{lst:opencv_cuda_install}.

\begin{lstlisting}[style=cmdstyle, caption={Erro de instalação do OpenCV com suporte a CUDA.}, label={lst:opencv_cuda_install}]
ERROR: Could not find a version that satisfies the requirement 
opencv-contrib-python-gpu==4.5.1.48 (from versions: none)
ERROR: No matching distribution found for opencv-contrib-python-gpu==4.5.1.48
\end{lstlisting}

Testes de detecção de CUDA confirmaram a ausência de suporte adequado, conforme demonstrado na Saída \ref{lst:cuda_detection}, onde é possível verificar que nenhum dispositivo CUDA foi detectado e o módulo DNN redirecionou automaticamente o processamento para CPU.

\begin{lstlisting}[style=cmdstyle, caption={Resultado do teste de detecção de suporte a CUDA.}, label={lst:cuda_detection}]
OpenCV version: 4.6.0
CUDA-capable devices detected: 0
DNN module was not built with CUDA backend; switching to CPU
\end{lstlisting}

Desta forma, a restrição imposta pela dependência do cliente CARLA ao Python 3.6 constitui um significativo gargalo tecnológico para a implementação de algoritmos de detecção de objetos de última geração. Diante deste desafio, foi necessário desenvolver uma abordagem alternativa que permitisse superar estas limitações sem comprometer o desempenho do sistema, conforme fizemos na Subseção Teórica \ref{subsubsec:arquitetura_distribuida} e Metodológica \ref{metodo}.

\subsection{Solução Técnica Implementada} \label{subsec:solucao_tecnica}

Para superar as limitações de compatibilidade entre o CARLA e modelos avançados de detecção de objetos, desenvolvemos uma arquitetura cliente-servidor que permite integrar o YOLOv8 acelerado por GPU ao sistema de condução autônoma, conforme visto na Subseção \ref{subsubsec:arquitetura_distribuida}. Esta solução contorna as restrições impostas pela dependência do simulador CARLA ao Python 3.6, que não oferece suporte adequado para as bibliotecas modernas de visão computacional, enquanto mantém a integração nativa com o simulador e preserva o fluxo de desenvolvimento original.

\subsubsection{Arquitetura Distribuída Cliente-Servidor}

A solução implementada separa o processamento do sistema em dois componentes independentes, como ilustrado na Figura \ref{fig:distributed_architecture}.


O componente cliente, executando em Python 3.6, mantém a integração com o simulador CARLA, responsável pelo controle do veículo, planejamento de trajetória e visualização. Este módulo captura os \textit{frames} da câmera virtual, constrói as mensagens e envia as imagens para processamento externo.

Por sua vez, o servidor de detecção, executando em Python 3.12 em um ambiente \textit{Conda} dedicado, recebe as imagens via Socket, realiza inferências utilizando o YOLOv8 com aceleração GPU, e retorna os resultados das detecções para o cliente. Esta arquitetura permite utilizar os modelos mais recentes da família YOLO sem comprometer o desempenho do sistema.

Ademais, a comunicação entre os módulos foi implementada utilizando Sockets TCP, com serialização binária através da biblioteca \textit{msgpack}. Este protocolo de comunicação foi otimizado para minimizar a latência na transferência de dados de imagem e metadados de detecção. 

Visando validar a eficácia da solução, conduzimos \textit{benchmarks} comparativos entre diferentes variantes do YOLOv8 (nano, small e medium), em ambiente com aceleração NVIDIA CUDA. Os resultados, apresentados na Figura \ref{fig:yolov8_performance}, demonstram a viabilidade da solução para aplicações em tempo real.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{Figures/yolov8_desempenho_tempo_fps.pdf}
\caption{Comparação de desempenho entre modelos YOLOv8 com aceleração GPU, mostrando o tempo de processamento (ms) e taxa de frames (FPS) para cada variante.}
\label{fig:yolov8_performance}
\end{figure}

Os testes foram executados usando uma GPU NVIDIA GeForce RTX 2060, ambiente CUDA 11.8 e PyTorch 2.1.2. Como mostrado na Figura \ref{fig:yolov8_performance}, todas as variantes alcançaram desempenho significativos para operação em tempo real: YOLOv8n atingiu 56,16 FPS, YOLOv8s obteve 47,15 FPS, e YOLOv8m alcançou 35,08 FPS. Este desempenho representa um ganho de aproximadamente 13,5$\times$ comparado ao YOLOv3 em CPU (4,15 FPS) e 1,6$\times$ em relação ao YOLOv3-tiny em CPU (35,76 FPS).

Além do ganho em velocidade de processamento, a solução implementada permite utilizar modelos com maior precisão. A Figura \ref{fig:yolov8_precision} apresenta a relação entre precisão (medida pelo mAP@0.5-0.95 no dataset COCO) e a velocidade de inferência.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{Figures/yolov8_desempenho_precisao.pdf}
\caption{Análise da relação entre precisão (mAP) e velocidade (FPS) dos modelos YOLOv8, com gráfico inferior evidenciando o número de objetos detectados por modelo.}
\label{fig:yolov8_precision}
\end{figure}

Observa-se que o modelo YOLOv8m oferece precisão significativamente maior (mAP 50,2) com velocidade competitiva (35,08 FPS), permitindo detecções mais confiáveis enquanto mantém o requisito de processamento em tempo real para aplicações de condução autônoma. A Figura \ref{fig:yolov8_comparison} apresenta os exemplos de detecções realizadas pelos três modelos avaliados.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{Figures/yolov8_comparison.png}
\caption{Comparação visual das detecções realizadas pelos modelos YOLOv8n (esquerda), YOLOv8s (centro) e YOLOv8m (direita) no cenário CARLA, mostrando diferentes níveis de confiança na detecção dos mesmos objetos.}
\label{fig:yolov8_comparison}
\end{figure}

A análise visual confirma que todos os modelos detectaram corretamente o veículo principal, com o YOLOv8n e YOLOv8s também identificando uma placa de pare e, somente no caso do YOLOv8s, um hidrante. É interessante notar que, embora o YOLOv8m tenha detectado menos objetos neste \textit{frame} específico (somente 2 objetos em comparação a 3 nos outros modelos), ele apresentou a maior confiança nas detecções realizadas, o que está alinhado com sua maior precisão teórica \cite{wang_yolov1_to_yolov10}.

\chapter{Considerações Finais} \label{concl}

Este trabalho apresentou o desenvolvimento e validação experimental de um sistema integrado de detecção de objetos em tempo real para VA, fundamentado na integração entre algoritmos YOLO e controle veicular em ambiente simulado. A pesquisa demonstrou a viabilidade técnica de soluções baseadas em visão computacional para sistemas de assistência à condução, contribuindo para o avanço do conhecimento na área.

\section{Validação da Hipótese e Resultados Principais}

A validação experimental confirmou integralmente a Hipótese \ref{hipotese}, demonstrando que um sistema de assistência à condução baseado em detecção de objetos pode oferecer \textit{feedback} visual de placas de trânsito em tempo real, contribuindo para uma condução mais confiável, conforme discutido e validado na Subseção \ref{subsec:validacao_hipotese}.

Os resultados quantitativos evidenciam desempenho superior aos critérios estabelecidos nos Objetivos Específicos \ref{objetivos_esp}, conforme evidenciado na Tabela \ref{tab:validacao_consolidada}. Ademais, a análise estatística inferencial, fundamentada em ANOVA unidirecional, confirmou robustez da detecção de placas de trânsito mesmo sob condições climáticas adversas, aspecto central para a validação da Hipótese \ref{hipotese}. 
Embora tenha sido observada degradação estatisticamente significativa no tempo de detecção em cenários de chuva intensa, a confiança na detecção de placas manteve-se estável, corroborando a robustez do sistema para aplicações críticas de segurança.

\section{Contribuições Científicas e Tecnológicas}

O presente trabalho apresenta contribuições relevantes sob diferentes perspectivas:

\begin{enumerate}
    \item \textbf{Metodológica}: desenvolvimento de uma arquitetura modular de VA e distribuída, integrando diferentes versões do Python via Sockets TCP/IP, viabilizando a execução de algoritmos de detecção (YOLOv8) em versões de ambiente simulados legados;
    \item \textbf{Experimental}: proposição de um protocolo de validação quantitativa, com coleta sistemática de métricas de desempenho, análise estatística rigorosa e geração automatizada de relatórios;
    \item \textbf{Tecnológica}: demonstração da viabilidade de sistemas de assistência à condução baseados em visão computacional para aplicações em tempo real, com potencial de superação dos limites fisiológicos humanos em tarefas de detecção e resposta a sinalizações de trânsito.
    \item \textbf{Reprodutibilidade}: disponibilização pública de todo o código-fonte, dados e \textit{scripts} de automação, consoante as melhores práticas da ciência.
\end{enumerate}


\chapter{Perspectiva de Continuidade} \label{continuidade}

Os resultados experimentais apresentados no Capítulo \ref{resultados} demonstram a viabilidade da arquitetura proposta para detecção de objetos e assistência à condução em tempo real. As limitações identificadas na Subseção \ref{subsec:limitacoes_metodo} e a natureza exploratória deste estudo abrem direções específicas para investigações futuras, organizadas por prioridade científica e impacto tecnológico.

\section{Compartilhamento de Memória como Evolução}

O compartilhamento de memória inter-processos emerge como técnica promissora para superar as limitações de comunicação via Sockets TCP/IP identificadas na Seção \ref{subsubsec:arquitetura_distribuida}. Conforme demonstrado por \citeonline{iordache2021smart} em sistemas de VA, a implementação de arquitetura baseada em memória compartilhada pode reduzir latência de comunicação de valores superiores a 20 ms para inferiores a 235 µs, representando melhoria de desempenho superior a 95\%.

\subsection{Impacto Potencial nos Resultados}

A migração para compartilhamento de memória, fundamentada nos resultados de \citeonline{iordache2021smart}, oferece potencial para:

\begin{itemize}
\item \textbf{Aumento de Throughput:} elevação da taxa de processamento de $\approx$17 FPS para 25-30 FPS através da eliminação de \textit{overhead} de serialização;
\item \textbf{Manutenção da Precisão:} preservação da precisão de 100\% alcançada, com redução significativa de latência de comunicação;
\item \textbf{Escalabilidade Multi-Sensorial:} viabilização de processamento simultâneo de múltiplas câmeras sem degradação proporcional de desempenho.
\end{itemize}

Esta otimização representa evolução natural dos resultados obtidos, mantendo a robustez da detecção demonstrada enquanto elimina gargalos de comunicação identificados, essencial para implementação em sistemas automotivos comerciais de próxima geração.

\section{Integração Dinâmica entre Módulos}

A principal limitação identificada refere-se à comunicação estática de dados entre os módulos de percepção e planejamento, conforme documentado na Subseção \ref{subsec:limitacoes_tecnicas}. A implementação atual utiliza arquivos de texto, limitando a capacidade de resposta dinâmica do sistema.

\textbf{Desenvolvimentos Propostos:}
\begin{itemize}
\item Sistema de mapeamento para conversão de coordenadas dos objetos identificados pelo YOLO para sistema global do veículo.
\end{itemize}

\section{Geração Dinâmica de Caminho}

A implementação atual utiliza trajetórias predefinidas (Subseção \ref{subsec:planejamento_de_missao}). O desenvolvimento de geração dinâmica de \textit{waypoints} representa extensão natural para ambientes não mapeados:

\begin{itemize}
\item Integração com algoritmos para mapeamento em tempo real;
\item Planejamento baseado em dados de outros sensores para geração de caminho dinâmica para navegação autônoma.
\end{itemize}

\section{Expansão de Classes de Detecção}

Os experimentos validaram detecção de veículos, e placa de pare com 100\% de precisão no CARLA. Extensões incrementais podem incluir:

\begin{itemize}
\item \textbf{Objetos Móveis:} pedestres, ciclistas, veículos pesados, etc;
\item \textbf{Infraestrutura Avançada:} diferentes tipos de placas de velocidade, sinais de construção, vias irregulares, etc;
\item \textbf{Condições Especiais:} veículos de emergência, obstáculos dinâmicos, perda de sinal sensorial, etc.
\end{itemize}


\section{Fusão Sensorial Multimodal}

A arquitetura atual baseia-se exclusivamente em câmeras. A integração com mais sensores, como: LiDAR, radar e ultrassônicos oferece potencial para maior robustez, especialmente em condições climáticas adversas de baixa visibilidade.

